{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pyventus","text":"<p>Documentation: https://mdapena.github.io/pyventus</p> <p>Source Code: https://github.com/mdapena/pyventus</p> <p>     \u2003\u2003Pyventus is a powerful Python library for event-driven and reactive programming, designed to simplify the development of asynchronous and event-based applications in Python. </p>"},{"location":"#key-features","title":"Key Features","text":"<p>     Pyventus offers several key features, such as: </p> <ul> <li>Event-Driven &amp; Reactive Programming \u2500 Whether you opt for an event-driven design or a reactive approach, Pyventus lets you select the paradigm that best fits your architecture. </li> <li>High Performance \u2500 Pyventus is designed from the ground up with a focus on efficiency, taking into account optimizations for time complexity, memory usage, and Python-specific features. </li> <li>Sync and Async Support \u2500 Whether your code is synchronous or asynchronous, Pyventus allows you to seamlessly work with both sync and async callables, as well as access its API from both contexts. </li> <li>Reliable Asynchronous Processing \u2500 With Pyventus, you have full control over your asynchronous workflows, allowing you to customize how they are processed upon completion, whether they succeed or encounter errors. </li> <li>Intuitive &amp; User-Friendly API \u2500 Pyventus provides a user-friendly API that simplifies the process of working with event-driven and reactive paradigms, enabling you to organize your code around discrete actions and their responses. </li> <li>Comprehensive Documentation \u2500 Pyventus offers a comprehensive documentation suite that includes API references, usage examples, and tutorials to effectively leverage all the features and capabilities of the library. </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>  \u2003\u2003Pyventus is published as a Python package and can be installed using <code>pip</code>, ideally in a virtual environment for proper dependency isolation. To get started, open up a terminal and install Pyventus with the following command: </p> <pre><code>pip install pyventus\n</code></pre> <p>     \u2003\u2003Pyventus by default relies on the Python standard library and requires Python 3.10 or higher with no additional dependencies aside from <code>typing-extensions</code>, which is primarily used to support advanced typing features in older versions of Python. However, this package also includes alternative integrations to access additional features such as asynchronous processing with Redis Queue and Celery. For more information on this matter, please refer to the Optional Dependencies section. </p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>     \u2003\u2003Let\u2019s begin with some introductory examples that will not only illustrate the core concepts and basic usage of the library but also provide a foundation for more complex scenarios. </p>"},{"location":"#a-simple-event-driven-example","title":"A Simple Event-Driven Example","text":"<p>     \u2003\u2003Starting with the event-driven paradigm, let's explore the capabilities of Pyventus through a simple event-based <code>Hello, World!</code> example, where you will learn how to subscribe to events and emit them within your application. </p> Hello, World! Example<pre><code>from pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker\n\n\n@EventLinker.on(\"GreetEvent\")\ndef handle_greet_event():\n    print(\"Hello, World!\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"GreetEvent\")\n</code></pre> You can also work with <code>async</code> functions and contexts... Hello, World! Example (Async version)<pre><code>from pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker\n\n\n@EventLinker.on(\"GreetEvent\")\nasync def handle_greet_event():\n    print(\"Hello, World!\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"GreetEvent\")\n</code></pre> <p>     \u2003\u2003As we can see from the <code>Hello, World!</code> example, Pyventus follows a simple and intuitive workflow for defining and emitting events. Let\u2019s recap the essential steps involved: </p> <ol> <li> Importing Necessary Components: We first imported the required components from the <code>events</code> module of Pyventus, which included the <code>EventLinker</code>, the <code>EventEmitter</code>, and the <code>AsyncIOEventEmitter</code> factory method. </li> <li> Linking Events to Callbacks: Next, we used the <code>@EventLinker.on()</code> decorator to define and link the string event <code>GreetEvent</code> to the function <code>handle_greet_event()</code>, which will print \"Hello, World!\" to the console whenever the <code>GreetEvent</code> is emitted. </li> <li> Instantiating an Event Emitter: After that, and in order to trigger our event, we used the <code>AsyncIOEventEmitter</code> factory method to create an instance of the event emitter class, which in this case is preconfigured with the <code>AsyncIOProcessingService</code>. </li> <li> Triggering the Event: Finally, by using the <code>emit()</code> method of the event emitter instance, we triggered the <code>GreetEvent</code>, resulting in the execution of the <code>handle_greet_event()</code> callback. </li> </ol> <p>     \u2003\u2003Having gained a clear understanding of the workflow showcased in the <code>Hello, World!</code> example, you are now well-equipped to explore more intricate event-driven scenarios and fully harness the capabilities of Pyventus in your own projects. For a deep dive into the package's functionalities, you can refer to the tutorials and API sections. </p>"},{"location":"#a-simple-reactive-example","title":"A Simple Reactive Example","text":"<p>     \u2003\u2003Now, let's take a look at the capabilities of Pyventus within the reactive paradigm through a simple example, where you will not only learn how to define observables and stream data over time, but also how to subscribe to them. </p> Simple Counter Example<pre><code>from pyventus.reactive import as_observable_task, Completed\n\n\n@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\n\nobs = simple_counter(stop=16)\nobs.subscribe(\n    next_callback=lambda val: print(f\"Received: {val}\"),\n    complete_callback=lambda: print(\"Done!\"),\n)\nobs()\n</code></pre> You can also work with <code>async</code> functions and contexts... Simple Counter Example (Async version)<pre><code>from pyventus.reactive import as_observable_task, Completed\n\n\n@as_observable_task\nasync def simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\n\nobs = simple_counter(stop=16)\nobs.subscribe(\n    next_callback=lambda val: print(f\"Received: {val}\"),\n    complete_callback=lambda: print(\"All done!\"),\n)\nobs()\n</code></pre> <p>     \u2003\u2003As shown in the <code>Simple Counter</code> example, Pyventus follows a simple and intuitive workflow for defining observables and streaming data to subscribers. Let\u2019s recap the essential steps involved: </p> <ol> <li> Importing Necessary Components: We first imported the required components from the <code>reactive</code> module of Pyventus, which included the <code>@as_observable_task</code> decorator and the <code>Completed</code> signal. </li> <li> Defining Observables: After that, and using the <code>@as_observable_task</code> decorator in conjunction with the <code>simple_counter()</code> function, we defined our observable task, which, once executed, will yield a count from one up to the specified number and raise a <code>Completed</code> signal when done. </li> <li> Instantiating Observables: Then, we called the <code>simple_counter()</code> function to instantiate the observable task, so that we can subscribe to it and control its execution as needed. </li> <li> Subscribing to Observables: Next, we added a subscriber to the observable instance by calling its <code>subscribe()</code> method and passing the corresponding callbacks. In this case, we used two lambda functions: one to print the received values and another to indicate when the observable has completed emitting values. </li> <li> Executing Observables: Finally, and in order to initiate the execution of the observable, we called its instance, which resulted in the execution of the <code>simple_counter()</code> function and the streaming of its results. </li> </ol> <p>     \u2003\u2003With a clear understanding of the workflow showcased in the <code>Simple Counter</code> example, you are now well-equipped to explore more intricate reactive scenarios and fully harness the capabilities of Pyventus in your own projects. For a deep dive into the package's functionalities, you can refer to the tutorials and API sections. </p>"},{"location":"#practical-examples","title":"Practical Examples","text":"<p>     \u2003\u2003To truly see Pyventus in action, let\u2019s explore some practical examples that will not only illustrate specific use cases of the library but also showcase its various features and demonstrate how to use them effectively. </p>"},{"location":"#dynamic-voltage-monitoring-an-event-driven-perspective","title":"Dynamic Voltage Monitoring: An Event-Driven Perspective","text":"<p>     \u2003\u2003A common aspect found in many systems is the need to monitor and respond to changes in sensor data. Whether it involves pressure, temperature, or voltage, capturing and reacting accordingly to sensor readings is crucial for any related process. </p> <p>     \u2003\u2003In this practical example, we will focus on voltage sensors, where timely detection of low or high voltage conditions can prevent equipment damage and ensure system reliability. However, designing a sensor architecture that is both easy to extend and flexible can be challenging, especially if we want users to simply attach their logic without needing to understand or modify the underlying implementation. This complexity also increases if we aim for an architecture that enables a proper separation of concerns. </p> <p>     \u2003\u2003One way to effectively address this challenge is by implementing an event-driven architecture, where each voltage sensor encapsulates its own logic for reading values and only exposes a series of events that users can utilize to attach their domain logic. To translate this into code, we will define a <code>VoltageSensor</code> class that reads voltage levels and emits events based on predefined thresholds using Pyventus. The code below illustrates the implementation of this use case. </p> Dynamic Voltage Monitoring (Event-Driven Implementation)<pre><code>import asyncio\nimport random\n\nfrom pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker\n\n\nclass VoltageSensor:\n\n    def __init__(self, name: str, low: float, high: float, event_emitter: EventEmitter) -&gt; None:\n        # Initialize the VoltageSensor object with the provided parameters\n        self._name: str = name\n        self._low: float = low\n        self._high: float = high\n        self._event_emitter: EventEmitter = event_emitter\n\n    async def __call__(self) -&gt; None:\n        # Start voltage readings for the sensor\n        print(f\"Starting voltage readings for: {self._name}\")\n        print(f\"Low: {self._low:.3g}v | High: {self._high:.3g}v\\n-----------\\n\")\n\n        while True:\n            # Simulate sensor readings\n            voltage: float = random.uniform(0, 5)\n            print(\"\\tSensor Reading:\", \"\\033[32m\", f\"{voltage:.3g}v\", \"\\033[0m\")\n\n            # Emit events based on voltage readings\n            if voltage &lt; self._low:\n                self._event_emitter.emit(\"LowVoltageEvent\", sensor=self._name, voltage=voltage)\n            elif voltage &gt; self._high:\n                self._event_emitter.emit(\"HighVoltageEvent\", sensor=self._name, voltage=voltage)\n\n            await asyncio.sleep(1)\n\n\n@EventLinker.on(\"LowVoltageEvent\")\ndef handle_low_voltage_event(sensor: str, voltage: float):\n    print(f\"\ud83e\udeab Starting low-voltage protection for '{sensor}'. ({voltage:.3g}v)\\n\")\n    # Perform action for low voltage...\n\n\n@EventLinker.on(\"HighVoltageEvent\")\ndef handle_high_voltage_event(sensor: str, voltage: float):\n    print(f\"\u26a1 Starting high-voltage protection for '{sensor}'. ({voltage:.3g}v)\\n\")\n    # Perform action for high voltage...\n\n\n@EventLinker.on(\"LowVoltageEvent\", \"HighVoltageEvent\")\nasync def handle_voltage_event(sensor: str, voltage: float):\n    print(f\"\\033[31m\\nSensor '{sensor}' out of range.\\033[0m (Voltage: {voltage:.3g})\")\n    # Perform notification for out of range voltage...\n\n\nasync def main():\n    # Initialize the sensor and run the sensor readings\n    sensor = VoltageSensor(name=\"CarSensor\", low=0.5, high=3.9, event_emitter=AsyncIOEventEmitter())\n    await asyncio.gather(sensor(), )  # Add new sensors inside the 'gather' for multi-device monitoring\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"#non-blocking-http-fetcher-a-responsive-approach","title":"Non-Blocking HTTP Fetcher: A Responsive Approach","text":"<p>     \u2003\u2003In today's interconnected world, retrieving information from the network is essential for many applications. Whether through WebSocket connections, RESTful APIs, or HTTP requests, these methods facilitate vital data exchange. However, blocking network retrievals can severely impact user experience, making it imperative for applications to remain responsive. </p> <p>     \u2003\u2003In this practical example, we will explore the design and implementation of a non-blocking HTTP getter function, along with its integration into a console-style application that mimics the behavior of a simplified web browser. While there are various mechanisms for implementing non-blocking HTTP fetchers, such as Python threads or the asyncio library, we will leverage the reactive paradigm of Pyventus due to its readability, declarative style, and ease of implementation. </p> <p>     \u2003\u2003To accomplish this, we will first define a basic blocking HTTP function called <code>http_get()</code>. This function will then be transformed into an observable using the <code>@as_observable_task</code> decorator from Pyventus, allowing us to attach subscribers for result notifications. Finally, we will utilize the <code>ThreadPoolExecutor</code> for concurrent execution of the observables, enabling us to handle multiple requests seamlessly while maintaining an interactive user experience. </p> Non-Blocking HTTP Fetcher (Reactive Implementation)<pre><code>from concurrent.futures import ThreadPoolExecutor\nfrom http.client import HTTPConnection, HTTPException, HTTPResponse, HTTPSConnection\nfrom urllib.parse import ParseResult, urlparse\n\nfrom pyventus.reactive import as_observable_task\n\n\n@as_observable_task\ndef http_get(url: str) -&gt; str:\n    \"\"\"Perform an HTTP GET request and return the response data.\"\"\"\n    parsed_url: ParseResult = urlparse(url)  # Parse the URL\n\n    # Create a connection based on the URL scheme (HTTP or HTTPS)\n    if parsed_url.scheme == \"https\":\n        connection: HTTPConnection = HTTPSConnection(parsed_url.netloc)\n    else:\n        connection: HTTPConnection = HTTPConnection(parsed_url.netloc)\n\n    # Send the request, retrieve the response, and close the connection\n    connection.request(\"GET\", parsed_url.path)\n    response: HTTPResponse = connection.getresponse()\n    data: str = response.read().decode()\n    connection.close()\n\n    # Raise an exception for HTTP errors; otherwise, return the response\n    if response.status &gt;= 400:\n        raise HTTPException(response.status, data)\n    return data\n\n\ndef main():\n    print(\n        \"\ud83c\udf10  Welcome to the Reactive HTTP Fetcher!\\n\\n\ud83d\udca1  Try searching for:\\n\"\n        \"    1. - https://httpbin.org/get\\n\"\n        \"    2. - https://httpbin.org/uuid\\n\"\n        \"    3. - https://httpbin.org/ip\\n\"\n        \"    4. - https://httpbin.org/404\"\n    )\n\n    prompt = \"\\n\ud83d\udd17  Enter the URL (Type '\\033[36mexit\\033[0m' to quit): \"\n    metrics = {\"success_count\": 0, \"error_count\": 0}  # Initialize metrics\n    executor = ThreadPoolExecutor()  # Create a thread pool for concurrent execution\n\n    while True:\n        # Get user input\n        url = input(prompt)\n        if url.lower() == \"exit\":\n            break\n\n        # Call the HTTP function, which returns an observable\n        obs = http_get(url)\n\n        # Subscribe to the observable using a subscription context\n        with obs.subscribe() as subctx:\n\n            @subctx.on_next\n            def next(result: str) -&gt; None:\n                metrics[\"success_count\"] += 1  # Increment success count\n                print(f\"\\r{' ' * len(prompt)}\\r\u2705  HTTPResponse: {result!r}\\n\", end=f\"{prompt}\")\n\n            @subctx.on_error\n            def error(error: Exception) -&gt; None:\n                metrics[\"error_count\"] += 1  # Increment error count\n                print(f\"\\r{' ' * len(prompt)}\\r\u26a0\ufe0f   HTTPException: {error!r}\\n\", end=f\"{prompt}\")\n\n        obs(executor)  # Execute the observable with the thread pool\n        print(f\"\ud83d\udd0d  Requested URL: \\033[32m{url!r}\\033[0m \\n\u23f3  Fetching data... \")\n\n    # Shutdown the executor\n    executor.shutdown()\n\n    # Print summary of requests\n    print(\n        f\"\\n\ud83c\udfaf  Summary:\\n\"\n        f\"    - Total Requests: {metrics['success_count'] + metrics['error_count']}\\n\"\n        f\"    - Successful Requests: \\033[32m{metrics['success_count']}\\033[0m\\n\"\n        f\"    - Error Requests: \\033[31m{metrics['error_count']}\\033[0m\"\n    )\n\n\nmain()\n</code></pre>"},{"location":"#event-driven-programming-key-highlights-of-pyventus","title":"Event-Driven Programming: Key Highlights of Pyventus","text":"<p>     \u2003\u2003Alongside the standard functionalities of event-driven programming, Pyventus also introduces some unique aspects that set it apart from other implementations. In this section, we will cover some of these key features and how to use them effectively. </p> <ul> <li> <p><p>Event Objects \u2500          Besides supporting string-based events, as we've seen in previous examples, Pyventus also supports Event Objects, which provide a structured way to define events and encapsulate relevant data payloads.     </p></p> <pre><code>@dataclass  # Define a Python dataclass to represent an event and its payload.\nclass OrderCreatedEvent:\n    order_id: int\n    payload: dict\n\n\n@EventLinker.on(OrderCreatedEvent)  # Use the event class to attach subscribers.\ndef handle_order_created_event(event: OrderCreatedEvent):\n    # The event instance is automatically passed as the first argument.\n    # In methods with self or cls, the event is passed after those arguments.\n    print(f\"Event Object: {event}\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\n    event=OrderCreatedEvent(  # Emit an instance of the event!\n        order_id=6452879,\n        payload={},\n    ),\n)\n</code></pre> </li> <li> <p><p>Global Events \u2500          In addition to Event Objects and string-based events, Pyventus also provides support for global events, which are particularly useful for implementing cross-cutting concerns such as logging, monitoring, and analytics. By subscribing event callbacks to <code>...</code>, you can capture all events that may occur within that specific <code>EventLinker</code> context.     </p></p> <pre><code>@EventLinker.on(...)\ndef logging(*args, **kwargs):\n    print(f\"Logging:\\n- Args: {args}\\n- Kwargs: {kwargs}\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"AnyEvent\", name=\"Pyventus\")\n</code></pre> </li> <li> <p><p>Success and Error Handling \u2500          With Pyventus, you can customize how events are handled upon completion, whether they succeed or encounter errors. This customization is achieved through the configuration of the success and failure callbacks in the event workflow definition, which is done during the subscription process.     </p></p> <pre><code>from pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker\n\n# Create a subscription context for the \"DivisionEvent\" event\nwith EventLinker.on(\"DivisionEvent\") as subctx:\n\n    @subctx.on_event\n    def divide(a: float, b: float) -&gt; float:\n        return a / b\n\n    @subctx.on_success\n    def handle_success(result: float) -&gt; None:\n        print(f\"Division result: {result:.3g}\")\n\n    @subctx.on_failure\n    def handle_failure(e: Exception) -&gt; None:\n        print(f\"Oops, something went wrong: {e}\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()  # Create an event emitter\nevent_emitter.emit(\"DivisionEvent\", a=1, b=0)  # Example: Division by zero\nevent_emitter.emit(\"DivisionEvent\", a=1, b=2)  # Example: Valid division\n</code></pre> <p> You can also set up your callbacks using the <code>subscribe()</code> method... <p><p>     \u2003\u2003Alternatively, for more straightforward definitions, such as lambda functions, or when you have existing functions defined elsewhere in your code, you can utilize the <code>subscribe()</code> method to set up these callbacks. </p></p> <pre><code>from pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker\n\nEventLinker.subscribe(\n    \"DivisionEvent\",\n    event_callback=lambda a, b: a / b,\n    success_callback=lambda result: print(f\"Division result: {result:.3g}\"),\n    failure_callback=lambda e: print(f\"Oops, something went wrong: {e}\"),\n)\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()  # Create an event emitter\nevent_emitter.emit(\"DivisionEvent\", a=1, b=0)  # Example: Division by zero\nevent_emitter.emit(\"DivisionEvent\", a=1, b=2)  # Example: Valid division\n</code></pre> <li> <p><p>Sync and Async Support \u2500          Pyventus is designed from the ground up to seamlessly support both synchronous and asynchronous programming models. Its unified sync/async API allows you to define event callbacks as either <code>sync</code> or <code>async</code> callables, as well as emit events from both contexts.     </p></p> <pre><code>@EventLinker.on(\"MyEvent\")\ndef sync_event_callback():\n    pass  # Synchronous event handling\n\n\n@EventLinker.on(\"MyEvent\")\nasync def async_event_callback():\n    pass  # Asynchronous event handling\n</code></pre> <p> You can optimize the execution of your callbacks based on their workload... <p><p>     \u2003\u2003By default, event subscribers in Pyventus are executed concurrently during an event emission, running their <code>sync</code> and <code>async</code> callbacks as defined. However, if you have a <code>sync</code> callback that involves I/O or non-CPU bound operations, you can enable the <code>force_async</code> parameter to offload it to a thread pool, ensuring optimal performance and responsiveness. The offloading process is handled by the <code>asyncio.to_thread()</code> function. </p></p> <pre><code>@EventLinker.on(\"BlockingIO\", force_async=True)\ndef blocking_io():\n    print(f\"start blocking_io at {time.strftime('%X')}\")\n    # Note that time.sleep() can be replaced with any blocking\n    # IO-bound operation, such as file operations.\n    time.sleep(1)\n    print(f\"blocking_io complete at {time.strftime('%X')}\")\n</code></pre> <pre><code>def sync_function(event_emitter: EventEmitter):\n    # Emitting events from sync functions\n    event_emitter.emit(\"MyEvent\")\n\n\nasync def async_function(event_emitter: EventEmitter):\n    # Emitting events from async functions\n    event_emitter.emit(\"MyEvent\")\n</code></pre> <p> Considerations on the processing of event emissions... <p>     \u2003\u2003It's important to note that, while Pyventus provides a unified sync/async API, the processing of each event emission will depend on the concrete implementation of the <code>ProcessingService</code> used in the event emitter. For example, an event emitter configured with the <code>AsyncIOProcessingService</code> will leverage the <code>AsyncIO</code> framework to handle the execution of the event emission, whereas other implementations may structure their propagation differently. </p> </p> <li> <p><p>Runtime Flexibility \u2500          At its core, Pyventus utilizes a modular event emitter design that, along with the <code>EventLinker</code>, allows you to change the event emitter at runtime without needing to reconfigure all subscriptions or apply complex logic.     </p></p> <pre><code>from concurrent.futures import ThreadPoolExecutor\n\nfrom pyventus.events import AsyncIOEventEmitter, EventEmitter, EventLinker, ExecutorEventEmitter\n\n\n@EventLinker.on(\"Event\")\ndef handle_event(msg: str):\n    print(msg)\n\n\ndef main(event_emitter: EventEmitter) -&gt; None:\n    event_emitter.emit(\"Event\", msg=f\"{event_emitter}\")\n\n\nif __name__ == \"__main__\":\n    executor = ThreadPoolExecutor()\n    main(event_emitter=AsyncIOEventEmitter())\n    main(event_emitter=ExecutorEventEmitter(executor))\n    executor.shutdown()\n</code></pre> <p><p></p></p> </li>"},{"location":"#reactive-programming-key-highlights-of-pyventus","title":"Reactive Programming: Key Highlights of Pyventus","text":"<p>     \u2003\u2003In addition to the standard functionalities of reactive programming, Pyventus also provides some unique aspects that set it apart from other implementations. In this section, we will explore some of these key features and how to use them effectively. </p> <ul> <li> <p><p>Python Callables as Observable Tasks \u2500         Whether you are working with generators or regular functions, Pyventus allows you to easily convert any Python callable into an observable task. These tasks are specialized observables that encapsulate a unit of work and provide a mechanism for streaming their results to a series of subscribers.     </p></p> <pre><code>@as_observable_task\ndef compute_square(n):\n    return n * n\n\nobs = compute_square(2)\nobs.subscribe(print)\nobs()\n</code></pre> <p> You can also work with <code>async</code> functions... <pre><code>@as_observable_task\nasync def fetch_data():\n    await asyncio.sleep(1)\n    return {\"data\": \"Sample Data\"}\n\nobs = fetch_data()\nobs.subscribe(print)\nobs()\n</code></pre> <pre><code>@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\n\nobs = simple_counter(stop=16)\nobs.subscribe(print)\nobs()\n</code></pre> <p> You can also work with <code>async</code> generators... <pre><code>@as_observable_task\nasync def async_counter(stop: int):\n    for count in range(1, stop + 1):\n        await asyncio.sleep(0.25)\n        yield count\n    raise Completed\n\nobs = async_counter(stop=16)\nobs.subscribe(print)\nobs()\n</code></pre> <li> <p><p>Multicast Support \u2500         Observables in Pyventus are designed from the ground up to efficiently support both unicast and multicast scenarios. So, it doesn't matter if you need to work with either single or multiple subscribers; Pyventus allows you to utilize these notification models and even optimizes the processing of each to ensure optimal performance.     </p></p> <pre><code>@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\n\nobs = simple_counter(stop=16)\nobs.subscribe(next_callback=lambda val: print(f\"Subscriber 1 - Received: {val}\"))\nobs.subscribe(next_callback=lambda val: print(f\"Subscriber 2 - Received: {val}\"))\nobs.subscribe(next_callback=lambda val: print(f\"Subscriber 3 - Received: {val}\"))\nobs()\n</code></pre> </li> <li> <p><p>Success and Error Handling \u2500     With Pyventus, you can customize how data streams are handled upon completion, whether they succeed or encounter errors. This customization is achieved through the configuration of the complete and error callbacks in the observer definition, which is done during the subscription process.     </p></p> <pre><code>@as_observable_task\nasync def interactive_counter():\n    stop: int = int(input(\"Please enter a number to count up to: \"))  # Can raise ValueError\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\n\nobs = interactive_counter()\nobs.subscribe(\n    next_callback=lambda val: print(f\"Received: {val}\"),\n    error_callback=lambda err: print(f\"Error: {err}\"),\n    complete_callback=lambda: print(\"All done!\"),\n)\nobs()\n</code></pre> </li> <li> <p><p>Declarative Subscription Model \u2500         Alongside standard subscription models, such as using lambda functions or predefined callbacks, Pyventus also provides a declarative subscription model that allows you to not only define the observer's callbacks inline and in a step-by-step manner but also to do so right before the subscription takes place.     </p></p> <pre><code>with obs.subscribe() as subctx:\n\n    @subctx.on_next\n    def next(value: int) -&gt; None:\n        print(f\"Received: {value}\")\n\n    @subctx.on_error\n    def error(error: Exception) -&gt; None:\n        print(f\"Error: {error}\")\n\n    @subctx.on_complete\n    def complete() -&gt; None:\n        print(\"All done!\")\n</code></pre> <p> You can also use the <code>subscribe()</code> method as a decorator... <p><p>     \u2003\u2003The <code>subscribe()</code> method, besides being used as a regular function and a context manager, can also be utilized as a decorator. When used this way, it creates and subscribes an observer, using the decorated function as its next callback. </p></p> <pre><code>@obs.subscribe()\ndef next(value: int) -&gt; None:\n    print(f\"Received: {value}\")\n</code></pre> <li> <p><p>Simplified Execution for Observable Tasks \u2500         Having to explicitly call each observable task to initiate their execution can be tedious and easily overlooked, especially when working with multiple observables at the same time. However, by using observable tasks within a <code>with</code> statement block, you can avoid this manual work and enable what is known as their execution context, which will allow you to work with them as usual while ensuring that they are called upon exiting the context block.     </p></p> <pre><code>@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\nwith simple_counter(stop=16) as obs:\n    obs.subscribe(lambda val: print(f\"Subscriber 1 - Received: {val}\"))\n    obs.subscribe(lambda val: print(f\"Subscriber 2 - Received: {val}\"))\n</code></pre> </li> <li> <p><p>Thread Offloading for Observable Tasks \u2500         By default, the processing of each observable task is handled by the AsyncIO framework, either synchronously or asynchronously depending on the context. However, for multithreaded environments, Pyventus also provides support for running these observable tasks in separate threads. </p></p> <pre><code>from concurrent.futures import ThreadPoolExecutor\nfrom pyventus.reactive import as_observable_task, Completed\n\n@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\nif __name__ == \"__main__\":\n\n    with ThreadPoolExecutor() as executor:\n\n        obs1 = simple_counter(16)\n        obs1.subscribe(print)\n        obs1(executor)\n\n        obs2 = simple_counter(16)\n        obs2.subscribe(print)\n        obs2(executor)\n</code></pre> <p> Thread offloading is also available for the execution context of observable tasks... <pre><code>from concurrent.futures import ThreadPoolExecutor\nfrom pyventus.reactive import as_observable_task, Completed\n\n@as_observable_task\ndef simple_counter(stop: int):\n    for count in range(1, stop + 1):\n        yield count\n    raise Completed\n\nif __name__ == \"__main__\":\n\n    with ThreadPoolExecutor() as executor:\n\n        with simple_counter(16).to_thread(executor) as obs1:\n            obs1.subscribe(print)\n\n        with simple_counter(16).to_thread(executor) as obs2:\n            obs2.subscribe(print)\n</code></pre> <p><p></p></p>"},{"location":"#additional-highlights","title":"Additional Highlights","text":"<p>     \u2003\u2003Beyond the core functionalities of event-driven and reactive programming, Pyventus also includes some additional features that are worth noting. In this section, we will explore these aspects and how to use them effectively. </p> <ul> <li> <p><p>Debugging Utilities \u2500         Debugging plays a crucial role in the development of asynchronous and event-driven applications, as it allows you to understand what\u2019s going on under the hood and provides valuable insights when troubleshooting errors. For this reason, Pyventus offers a clear string representation of each component, along with a debug mode flag that lets you view the package's logs for a better understanding of the processes at work.     </p></p> <p><p> </p></p> </li> <li> <p><p>Efficient Import Management \u2500         Pyventus encapsulates each paradigm into its own isolated package, so that you can not only have a clear boundary between event-driven and reactive programming features, but also apply Python import optimizations based on the required paradigm. For example, if you are only working with the events module of Pyventus and never import the reactive package, Python does not load it.     </p></p> </li> </ul> <p></p>"},{"location":"#license","title":"License","text":"<p>     \u2003\u2003Pyventus is distributed as open-source software and is released under the MIT License. For a detailed view of the license, please refer to the <code>LICENSE</code> file located in the Pyventus repository. </p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>     \u2003\u2003Thank you for being interested in contributing to Pyventus! In this section, you will discover how to effectively contribute to this project, as well as best practices for reporting issues, submitting pull requests, and engaging with the community \u2764\ufe0f </p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>     \u2003\u2003Before creating an issue or pull request, please make sure to check if a similar discussion already exists. We encourage you to actively participate by engaging in existing issues. </p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>     \u2003\u2003If you have any questions, bug reports, or feature requests, please open a new issue or discussion. When reporting issues, be sure to provide clear steps to reproduce the problem. For security vulnerabilities, please refer to the Pyventus Security Policy. </p>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<p>     \u2003\u2003We greatly appreciate your contributions and want to ensure they align with the project's goals and quality standards. Unless your proposed change is trivial, such as fixing a typo or tweaking documentation, we recommend creating an issue or discussion to talk about the proposed change before submitting a pull request. This allows us to provide feedback, clarify requirements, and ensure your efforts are focused in the right direction. To make a contribution, please follow these steps: </p> <ol> <li><p>Fork the repository and create a new branch.</p></li> <li><p>Implement your changes in the new branch.</p></li> <li><p>Ensure that formatting, linting, and tests pass.</p></li> <li><p>Include tests whenever possible to cover the lines of code you added or modified.</p></li> <li><p>Commit your changes and submit a pull request with a clear, detailed message.</p></li> </ol> <p>     \u2003\u2003We will review your pull request to ensure it meets the project's quality standards before merging it into the main codebase. Please feel free to ask any questions along the way! </p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>     \u2003\u2003To ensure that project dependencies are isolated and do not interfere with other projects, we recommend using a virtual environment for development. To set up a new virtual environment, please follow these steps: </p> <ol> <li> <p>Create a new virtual environment with: <pre><code>python -m venv venv\n</code></pre> <li> <p>Activate the environment with:</p>  macOS Windows Linux <p> <pre><code>. venv/bin/activate\n</code></pre> </p> <p> <pre><code>. venv/Scripts/activate\n</code></pre> </p> <p> <pre><code>. venv/bin/activate\n</code></pre> </p> </li> <li> <p>Install development dependencies with: <pre><code>pip install -e .[dev]\n</code></pre>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<p>     \u2003\u2003To run the test suite of Pyventus, you can either perform a manual execution with pytest or use Hatch to run the test suite across all supported Python versions. </p>  Manual Using Hatch <p> <pre><code>pytest -v\n</code></pre> </p> <p> <pre><code>hatch run tests:test\n</code></pre> </p>"},{"location":"contributing/#code-coverage","title":"Code Coverage","text":"<p>     \u2003\u2003To evaluate the test coverage of your code, you can either perform a manual evaluation with Coverage.py or use Hatch to evaluate test coverage across all supported Python versions. </p>  Manual Using Hatch <p> <pre><code>coverage run -m pytest -v\n</code></pre> </p> <p> <pre><code>hatch run tests:cov\n</code></pre> </p>"},{"location":"contributing/#checking-types","title":"Checking Types","text":"<p>     \u2003\u2003To check the static typing of your code, you can either perform a manual check with mypy or use Hatch to check static typing across all supported Python versions. </p>  Manual Using Hatch <p> <pre><code>mypy\n</code></pre> </p> <p> <pre><code>hatch run tests:typing\n</code></pre> </p>"},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<p>     \u2003\u2003To check the linting and formatting of your code, you can either manually use Ruff or use Hatch to perform these checks across all supported Python versions. </p>  Manual Using Hatch <p> <pre><code>ruff check &amp; ruff format --check\n</code></pre> </p> <p> <pre><code>hatch run tests:style\n</code></pre> </p>"},{"location":"contributing/#pyventus-documentation","title":"Pyventus Documentation","text":"<p>     \u2003\u2003The Pyventus documentation is written in Markdown and built with Material for MkDocs. To get started in development mode, run one of the following commands: </p>  Manual Using Hatch <p> <pre><code>mkdocs serve --dev-addr localhost:8000\n</code></pre> </p> <p> <pre><code>hatch run docs:serve\n</code></pre> </p>"},{"location":"contributing/#project-structure-and-conventions","title":"Project Structure and Conventions","text":"<p>     \u2003\u2003This project follows the src-layout convention for Python packages. This convention improves code organization, facilitates easy testing and usage, and allows developers to install the package in editable mode. By adhering to this convention, we can validate the package thoroughly in a realistic environment, leading to a higher quality and user-friendly product. </p>"},{"location":"contributing/#code-standards","title":"Code Standards","text":"<p>     \u2003\u2003At Pyventus, ensuring a high-quality and maintainable codebase is essential. Therefore, the following code standards have been established to guide the development process as well as promote consistency: </p> <ul> <li> <p><p>PEP-8 Compliance \u2500          Follow the guidelines outlined in PEP-8 to ensure clean and readable Python code. Adhering to these standards promotes consistency, enhances code comprehension, and facilitates collaboration among contributors.     </p></p> </li> <li> <p><p>Meaningful Naming \u2500          Use descriptive and meaningful names for variables, functions, and classes. Clear and intuitive naming enhances code comprehension, making it easier for everyone to understand and work with the code.     </p></p> </li> <li> <p><p>Modularity and Reusability \u2500          Encourage the development of modular and reusable code. Breaking down complex tasks into smaller, self-contained components promotes maintainability, reduces complexity, and allows for scalability and extensibility.     </p></p> </li> <li> <p><p>Optimization and Efficiency \u2500          Strive for efficient code by considering algorithmic complexity and optimizing where necessary. Writing code that is both correct and performant ensures responsive and scalable applications.     </p></p> </li> <li> <p><p>Class Structure \u2500          While there are no strict rules for structuring classes in Python beyond common sense and readability, Pyventus has established a recommended class structure that provides a foundation for a consistent codebase.(1)     </p></p> <ol> <li> <p>Recommended Class Structure</p> <pre><code>Class Name\n\n1. Inner Classes and Class Attributes\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n2. Static Methods\n   \u251c\u2500\u2500 @staticmethod\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n3. Class Methods\n   \u251c\u2500\u2500 @classmethod\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n4. Special Attributes\n   \u251c\u2500\u2500 __slots__, __init__, __repr__\n\n5. Properties\n   \u251c\u2500\u2500 @property\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n6. Abstract Methods\n   \u251c\u2500\u2500 @abstractmethod\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n7. Instance Methods\n   \u2514\u2500\u2500 Access Modifiers: private, protected, public\n\n8. Other Magic Methods\n</code></pre> </li> </ol> </li> </ul>"},{"location":"contributing/#documentation-style","title":"Documentation Style","text":"<p>     \u2003\u2003When contributing to Pyventus, please make sure that all code is well documented. The following should be documented using properly formatted docstrings: </p> <ul> <li>Modules.</li> <li>Class definitions.</li> <li>Function definitions.</li> <li>Module-level variables.</li> </ul> <p>     \u2003\u2003Pyventus uses Sphinx docstrings formatted according to PEP 257 guidelines. For more examples and detailed guidance on using Sphinx-style docstrings, please refer to the official Sphinx documentation. </p>"},{"location":"contributing/#pre-submission-testing-and-validation","title":"Pre-Submission Testing and Validation","text":"<p>     \u2003\u2003Before submitting your pull request, it is crucial to ensure that your changes pass all necessary checks. To do so, simply run the following command: </p> <pre><code>hatch run tests:all\n</code></pre> <p>     \u2003\u2003This command will trigger the Hatch project manager to initiate a comprehensive testing process across all supported Python versions. It will run tests, perform type checks, ensure code linting and formatting, and measure code coverage. This ensures that your changes meet the required quality standards. </p> <p>Testing for Specific Python Versions</p>  Python 3.10 Python 3.11 Python 3.12 Python 3.13 <p> <pre><code>hatch run +py=3.10 tests:all\n</code></pre> </p> <p> <pre><code>hatch run +py=3.11 tests:all\n</code></pre> </p> <p> <pre><code>hatch run +py=3.12 tests:all\n</code></pre> </p> <p> <pre><code>hatch run +py=3.13 tests:all\n</code></pre> </p> <p>Troubleshooting Hatch Environment Errors</p> <p><p>     \u2003\u2003If commands run successfully when executed manually but produce unexpected errors or misbehavior when run within a Hatch environment, even though the dependencies are declared correctly, this could indicate an issue with the Hatch environment cache. To resolve potential cache-related issues, you can remove the environment and clear its cache by running: </p></p> <p> <pre><code>hatch env remove [ENV_NAME]\n</code></pre> </p> <p><p>     \u2003\u2003Alternatively, if you prefer to take a more comprehensive approach by removing all environments and clearing their caches, you can do so by running the following command: </p></p> <p> <pre><code>hatch env prune\n</code></pre> </p>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>     \u2003\u2003This project is committed to fostering a welcoming and inclusive environment for all participants. The Pyventus Code of Conduct applies to this project and everyone involved in it. By participating, you agree to uphold these standards and contribute to a positive experience for everyone. </p> <p>     \u2003\u2003If you witness or experience any unacceptable behavior, we encourage you to report it to the project maintainers. Your feedback is important in helping us maintain a respectful community. </p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>     \u2003\u2003Welcome to the Getting Started section! In this guide, you will learn how to install Pyventus, as well as enable any of its optional dependencies. For more detailed information on how to use this library, you can refer to the Pyventus Tutorials or API Reference. </p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>     \u2003\u2003Pyventus is published as a Python package and can be installed using <code>pip</code>, ideally in a virtual environment for proper dependency isolation. To get started, open up a terminal and install Pyventus with the following command: </p> <pre><code>pip install pyventus\n</code></pre> <p>     \u2003\u2003By default, Pyventus relies on the Python standard library and requires Python 3.10 or higher with no additional dependencies aside from <code>typing-extensions</code>, which is primarily used to support advanced typing features in older versions of Python. </p>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"<p>     \u2003\u2003While Pyventus primarily relies on the Python standard library, it also supports optional dependencies to access additional features, such as different processing services<sup>1</sup>. Below is a list of supported integrations: </p>"},{"location":"getting-started/#supported-library-integrations","title":"Supported Library Integrations","text":"<ul> <li> <p><p>Celery \u2500          Pyventus integrates with Celery through the <code>CeleryProcessingService</code>, which is a concrete implementation of the <code>ProcessingService</code> interface that leverages the Celery framework to handle the execution of calls. To install Pyventus with Celery support, use the following command:     </p></p> <p> <pre><code>pip install pyventus[celery] (1)\n</code></pre> </p> <ol> <li>Optional Package Dependencies <p>         \u2003\u2003This package also includes optional dependencies. For more information, please visit the Celery documentation.     </p></li> </ol> </li> <li> <p><p>Redis Queue (RQ) \u2500          Pyventus integrates with Redis Queue through the <code>RedisProcessingService</code>, which is a concrete implementation of the <code>ProcessingService</code> interface that leverages the Redis Queue framework to handle the execution of calls. To install Pyventus with Redis Queue support, use the following command:     </p></p> <p> <pre><code>pip install pyventus[rq]\n</code></pre> </p> </li> </ul>"},{"location":"getting-started/#supported-framework-integrations","title":"Supported Framework Integrations","text":"<ul> <li> <p><p>FastAPI \u2500          Pyventus integrates with FastAPI through the <code>FastAPIProcessingService</code>, which is a concrete implementation of the <code>ProcessingService</code> interface that utilizes the FastAPI's <code>BackgroundTasks</code> to handle the execution of calls. To install Pyventus with FastAPI integration, use the following command:     </p></p> <p> <pre><code>pip install pyventus[fastapi] (1)\n</code></pre> </p> <ol> <li>Optional Package Dependencies <p>         \u2003\u2003This package also includes optional dependencies. For more information, please visit the FastAPI documentation.     </p></li> </ol> </li> </ul> <p>You can install all of these integrations simultaneously using:</p> <pre><code>pip install pyventus[all]\n</code></pre> <ol> <li> <p>These processing services expand the capabilities of Pyventus by providing different strategies for processing calls. For instance, the <code>EventEmitter</code> class leverages these services to decouple the processing of each event emission from the underlying implementation, resulting in a more flexible and efficient execution mechanism that enhances the responsiveness and scalability of event handling.\u00a0\u21a9</p> </li> </ol>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0.7.0","title":"v0.7.0 Unreleased","text":""},{"location":"release-notes/#0.7.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li> <p>The <code>typing-extensions</code> package is now a required dependency for Pyventus. This dependency has been added to support advanced typing features in older versions of Python.</p> </li> <li> <p>All previous event-driven features must now be imported from the inner package <code>pyventus.events</code> instead of directly from <code>pyventus</code>. These changes were necessary due to the integration of the reactive programming paradigm. This series of refactors were implemented not only to ensure an organized codebase but also to establish a clear boundary between event handling and reactive programming features, enabling optimized imports based on the required paradigm.</p> </li> <li> <p>The inheritance structure of the <code>EventEmitter</code> has been replaced with composition using the new <code>ProcessingService</code> interface. This interface establishes a common ground for processing calls, such as event emissions, in a decoupled and flexible manner. The <code>EventEmitter</code> is now a concrete class that requires a <code>ProcessingService</code> instance, referred to as <code>event_processor</code>, for initialization. These changes not only preserve the overall behavior and workflow of the <code>EventEmitter</code> but also enhance its modularity and flexibility.</p> </li> <li> <p>The <code>EventLinker</code> class has experienced multiple method renames and return type modifications to align with the new redesigned codebase, enhancing the API for improved usability and intuitiveness. Below is a detailed list of the breaking changes made to the <code>EventLinker</code> class:</p> <ul> <li>The inner class <code>EventLinkageWrapper</code> was renamed to <code>EventLinkerSubCtx</code> for consistency with the new concept of a subscription context and now extends from the base class <code>SubscriptionContext</code>. The overall workflow remains roughly the same but was reworked to align with its base class and introduce optimizations based on user needs.</li> <li>The method <code>get_events()</code> now returns a <code>set</code> of all registered events instead of a <code>list</code> with non-duplicated events.</li> <li>The method <code>get_event_handlers()</code> was renamed to <code>get_subscribers()</code> for consistency, and it now returns a <code>set</code>of all registered subscribers instead of a <code>list</code> with non-duplicated subscribers.</li> <li>The method <code>get_events_by_event_handler()</code> was renamed to <code>get_events_from_subscribers()</code> for consistency. It now returns a <code>set</code> of events associated with the specified subscribers instead of a <code>list</code> of non-duplicated events associated with the specified subscribers. This method now also supports retrieving events from multiple subscribers instead of only one at a time.</li> <li>The method <code>get_event_handlers_by_events()</code> was renamed to <code>get_subscribers_from_events()</code> for consistency. It now returns a <code>set</code> of subscribers associated with the specified events instead of a <code>list</code> of non-duplicated subscribers associated with the provided events. Additionally, a new flag called <code>pop_onetime_subscribers</code> was added to remove and return those subscribers that are one-time subscriptions.</li> <li>The method <code>unsubscribe()</code> was renamed to <code>remove()</code> for consistency with the new concept of subscription and the encapsulation of the unsubscription process through the <code>teardown_callback</code>. This method now allows you to remove one event and subscriber from the registry at a time instead of multiple events of the given subscriber.</li> <li>The method <code>remove_event_handler()</code> was renamed to <code>remove_subscriber()</code> for consistency.</li> <li>Parameters named <code>event_handler</code> were renamed to <code>subscriber</code> for consistency.</li> </ul> </li> <li> <p>The <code>EventHandler</code> has been refactored from a class to an interface, outlining the overall workflow and essential protocols for event handling. However, the previous implementation of the <code>EventHandler</code> has been transitioned to one of its concrete classes named <code>EventSubscriber</code>. This new <code>EventSubscriber</code> class not only implements the <code>EventHandler</code> interface but also combines it with the <code>Subscription</code> base class, providing a convenient way to both handle event responses and manage the subscription lifecycle.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-added","title":"Added","text":"<ul> <li> <p>Added a reactive programming module to expand Python's event-driven capabilities for data-oriented processes and the ability to react efficiently to state changes over time.</p> <ul> <li>Added the <code>Observable</code> base class, which defines a lazy push-style notification mechanism for streaming data to subscribers.</li> <li>Added the <code>ObservableTask</code> class, an observable subclass that encapsulates a unit of work and offers a mechanism for streaming its results reactively.</li> <li>Added the <code>as_observable_task()</code> decorator to easily convert any given callable into an observable task.</li> <li>Added the <code>Observer</code> interface, which defines the overall workflow and essential protocols for responding to notifications from an observable.</li> <li>Added the <code>Subscriber</code> class, which combines the <code>Observer</code> interface with the <code>Subscription</code> base class to provide a convenient way to respond to state changes emitted by an observable and manage the subscription lifecycle.</li> </ul> </li> <li> <p>Added the <code>Unsubscribable</code> interface, which provides a standardized method for objects to unsubscribe from a source and release any associated resources.</p> </li> <li> <p>Added the <code>Subscription</code> base class to simplify subscription management and resource cleanup with a <code>teardown_callback</code> that is called during unsubscription.</p> </li> <li> <p>Added the <code>SubscriptionContext</code> base class, which defines the overall workflow for subscription contexts, allowing the user to define step-by-step the object that will later be subscribed to the specified source.</p> </li> <li> <p>Added a new package global exception called <code>PyventusImportException</code>, which is a custom Pyventus exception for handling missing imports within the library.</p> </li> <li> <p>Added the <code>MultiBidict</code> data structure, a generic multikeyed, multivalued bidirectional dictionary that offers a flexible mapping structure for efficient lookups, updates, and deletions of keys and their corresponding values.</p> </li> <li> <p>Introduced the <code>ProcessingService</code> interface to define flexible execution strategies for various use cases. This release includes the following concrete implementations:</p> <ul> <li><code>AsyncIOProcessingService</code>: A processing service that utilizes the <code>AsyncIO</code> framework to handle the execution of calls.</li> <li><code>CeleryProcessingService</code>: A processing service that utilizes the <code>Celery</code> framework to handle the execution of calls.</li> <li><code>ExecutorProcessingService</code>: A processing service that utilizes the Python's <code>Executor</code> to handle the execution of calls.</li> <li><code>FastAPIProcessingService</code>: A processing service that uses FastAPI's <code>BackgroundTasks</code> to handle the execution of calls.</li> <li><code>RedisProcessingService</code>: A processing service that utilizes the <code>Redis Queue</code> framework to handle the execution of calls.</li> </ul> </li> <li> <p>Added the <code>CallableWrapper</code> class to encapsulate callables and provide a unified asynchronous interface for their execution.</p> </li> <li> <p>Added new features to the <code>EventLinker</code> class, including the following methods:</p> <ul> <li>Introduced the <code>get_valid_subscriber()</code> method for a centralized mechanism to validate event subscribers.</li> <li>Added the <code>is_empty()</code> method to efficiently check if the main registry is empty.</li> <li>Added the <code>get_event_count()</code> method to return the total number of events in the registry.</li> <li>Added the <code>get_subscriber_count()</code> method to return the total number of subscribers in the registry.</li> <li>Added the <code>get_event_count_from_subscriber()</code> method to return the number of events for a specific subscriber.</li> <li>Added the <code>get_subscriber_count_from_event()</code> method to return the number of subscribers for a specific event.</li> <li>Added the <code>contains_event()</code> method to check if a specific event is present in the registry.</li> <li>Added the <code>contains_subscriber()</code> method to check if a specific subscriber is present in the registry.</li> <li>Added the <code>are_linked()</code> method to determine if a specific event is linked to a given subscriber.</li> <li>Introduced the <code>stateful_subctx</code> parameter in the <code>once()</code> and <code>on()</code> methods to configure the <code>EventLinkerSubCtx</code> behavior and optimize the subscription context based on user needs.</li> </ul> </li> <li> <p>Introduced the <code>EventSubscriber</code> class, which combines event handling capabilities with subscription lifecycle management.</p> </li> <li> <p>A new <code>benchmarks</code> package has been added to the <code>tests</code> directory for performance evaluation of Pyventus. This release introduces the <code>EventEmitterBenchmark</code>, which measures the efficiency of the <code>EventEmitter</code> in handling event emissions.</p> </li> <li> <p>Added a set of utilities for creating preconfigured event emitter instances, making the setup process easier. These utilities also provide retro compatibility with the previous class-based design.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-changed","title":"Changed","text":"<ul> <li> <p>Enhanced the <code>emit()</code> method in the <code>EventEmitter</code> to support the emission of global events (<code>...</code>).</p> </li> <li> <p>Moved callback utilities to a dedicated module within <code>pyventus.core</code> for improved organization and reusability.</p> </li> <li> <p>Standardized the structure of Python classes and their representation, including the use of the <code>@override()</code> decorator for consistency and <code>mypy</code> static type checking.</p> </li> <li> <p>Standardized the structure of the <code>pyproject.toml</code> file.</p> </li> <li> <p>Enhanced Pyventus logs by adding process and thread IDs for better debugging.</p> </li> <li> <p>Switched from the <code>Black</code> formatter to <code>Ruff</code> for improved development efficiency and enhanced code quality.</p> </li> <li> <p>Refactored all project docstrings to follow a standardized format, enhancing consistency and clarity in the documentation.</p> </li> <li> <p>Upgraded several development dependencies in the <code>pyproject.toml</code>, including <code>pytest-asyncio</code> from version <code>0.21.0</code> to <code>0.24.0</code>, to enable global configuration of the <code>asyncio_mode</code>.</p> </li> <li> <p>Simplified the <code>EventCallbackType</code> type alias by removing the unnecessary <code>ParamSpec</code>.</p> </li> <li> <p>Refactored the test suite to improve validation across all package features, ensuring correctness and achieving 100% code coverage.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-optimized","title":"Optimized","text":"<ul> <li> <p>The time complexity of the <code>emit()</code> method in the <code>EventEmitter</code> class has been significantly optimized. It has been reduced from \\(O(E \\cdot S^2)\\) to \\(O(E \\cdot S)\\), where:</p> <ul> <li>\\(E\\): Denotes the total number of events in the event linker.</li> <li>\\(S\\): Corresponds to the total number of subscribers in the event linker.</li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0This optimization results from the more efficient management of one-time subscribers by the event linker during event emission. Instead of traversing the entire event linker registry to remove each one-time subscriber involved in the event emission, it now iterates solely through the linked events.</p> </li> <li> <p>Major optimizations have been implemented for the <code>EventLinker</code> class through the integration of the <code>MultiBidict</code> data structure. This data structure is a multikeyed, multivalued bidirectional dictionary implementation that enables efficient lookups, updates, and deletions of events and their corresponding subscribers. Despite utilizing a bidirectional mapping structure, its memory footprint remains minimal due to the use of references between keys and values instead of duplication, which limits the impact to the additional dictionary and set data structures.</p> <ul> <li> <p>The time complexity of the method <code>get_subscribers()</code>, previously known as <code>get_event_handlers()</code>, has been reduced from \\(O(E \\cdot S)\\) to \\(O(S)\\), where:</p> <ul> <li>\\(E\\): Denotes the total number of events in the event linker.</li> <li>\\(S\\): Corresponds to the total number of subscribers in the event linker.</li> </ul> </li> <li> <p>The time complexity of the <code>get_events_from_subscribers()</code>, previously known as <code>get_events_by_event_handler()</code>, has been reduced from \\(O(E \\cdot S)\\) to \\(O(E)\\), where:</p> <ul> <li>\\(E\\): Denotes the total number of events in the event linker.</li> <li>\\(S\\): Corresponds to the total number of subscribers in the event linker.</li> </ul> </li> <li> <p>The time complexity of the method <code>remove()</code>, previously known as <code>unsubscribe()</code>, has been enhanced from \\(O(S)\\) to a constant time complexity of \\(O(1)\\), where:</p> <ul> <li>\\(S\\): Corresponds to the total number of subscribers in the event linker.</li> </ul> </li> <li> <p>The time complexity of the method <code>remove_subscriber()</code>, previously known as <code>remove_event_handler()</code>, has been reduced from \\(O(E \\cdot S)\\) to \\(O(E)\\), where:</p> <ul> <li>\\(E\\): Denotes the total number of events in the event linker.</li> <li>\\(S\\): Corresponds to the total number of subscribers in the event linker.</li> </ul> </li> </ul> </li> <li> <p>Introduced <code>__slots__</code> in several classes to optimize memory usage and enhance attribute access speed.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-benchmarks","title":"Benchmarks","text":"<p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Finally, to provide a quick visualization of the overall improvements and illustrate the time complexity enhancements of this release, a series of benchmarks were conducted. These benchmarks were specifically designed for the event emission process, as it encompasses all event-driven features and provides a clear overview of the improvements. Following this, a detailed explanation of the benchmarks and their results is presented.</p> <ul> <li> <p>Methodology: The benchmarks utilized a volume testing approach to assess how different subscription counts affect the event emission time.</p> </li> <li> <p>Environment: The benchmarks were conducted in the following environment:</p> <ul> <li>Operating System: Windows 11 64bit (v10.0.22631)</li> <li>CPU: AMD Ryzen 5 2600, 3400.0 MHz, 6 cores, 12 logical processors</li> <li>Total Memory: 16 GB</li> <li>Python Version: 3.12.7</li> </ul> </li> <li> <p>Setup: The benchmark setup consisted of two key components: a main Python script that managed the overall workflow of the benchmarks and the <code>EventEmitterBenchmark</code> class, which was essential for standardizing and organizing the performance tests. Following this, the main workflow of the benchmarks will be outlined, including the required packages and the adjustable settings available for different tests.</p> <p> Benchmark Workflow and Settings (<code>main.py</code>) <p>Before running the benchmarks, make sure all necessary packages are installed. You can install them using the following <code>pip</code> command:</p> <pre><code>pip install pyventus[tests]\n</code></pre> <p>Additionally, an extra package is required for visualizing the results: <code>matplotlib</code>. You can also install it with a <code>pip</code> command as follows:</p> <pre><code>pip install matplotlib\n</code></pre> <p>Once the packages are installed, you can configure the benchmarks in the <code>main.py</code> script as needed and execute it. The script will first install Pyventus <code>v0.6.0</code>, run the benchmarks in a separate process, and then uninstall it. Next, it will install the current version of Pyventus and run the benchmarks again in another process. Finally, the results for each version will be saved in a <code>JSON</code> file, and plots will be generated based on the benchmark reports.</p> main.py<pre><code>import gc\nimport os\nimport subprocess\nimport sys\nfrom concurrent.futures import ProcessPoolExecutor\nfrom dataclasses import asdict\nfrom json import dumps\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef run_event_emitter_benchmarks():\n    from tests.benchmarks.event_emitter_benchmark import EventEmitterBenchmark\n\n    print(f\"Pyventus v{EventEmitterBenchmark.PYVENTUS_VERSION}\\n\")\n    print(\"Starting benchmarks...\")\n\n    # Define a list of benchmarks to run with different configurations.\n    benchmarks: list[EventEmitterBenchmark] = [\n        # Benchmark with SINGLE event subscription mode and NONE one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.SINGLE,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.NONE,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),\n        # Benchmark with SINGLE event subscription mode and ALL one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.SINGLE,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.ALL,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),\n        # Benchmark with ALL event subscription mode and ALL one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.ALL,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.ALL,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),\n        # Benchmark with RANDOM event subscription mode and RANDOM one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.RANDOM,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.RANDOM,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=3,\n            num_executions=500,\n        ),\n    ]\n\n    # Initialize an empty list to store reports generated by the benchmarks.\n    reports: list[EventEmitterBenchmark.Report] = []\n\n    # Iterate through each benchmark and execute it.\n    for benchmark in benchmarks:\n        reports.append(benchmark())\n\n    # Return the list of reports.\n    return reports\n\ndef plot_event_emitter_benchmark_comparison(\n    title: str, subscription_sizes: list[int], benchmark_bars: dict[tuple[str, str], list[float]], output_file: str\n) -&gt; None:\n    # Prepare the x positions for the bars based on the number of subscription sizes\n    x_positions = np.arange(len(subscription_sizes))\n    bar_width = 0.355  # Width of each bar\n    bar_offset = 0  # Offset for positioning bars\n\n    # Create a figure and axis for the plot\n    fig, ax = plt.subplots(figsize=(9.6, 5), layout=\"constrained\")\n\n    # Initialize the maximum y-value for setting the y-axis limit later\n    max_y_value = 0\n\n    # Loop through each benchmark report to create bars\n    for (label, color), heights in benchmark_bars.items():\n        # Calculate the offset for the current set of bars\n        current_offset = bar_width * bar_offset\n\n        # Create bars for the current benchmark data\n        bars = ax.bar(x=(x_positions + current_offset), height=heights, width=bar_width, label=label, color=color)\n\n        # Add labels on top of the bars with formatted emission times\n        ax.bar_label(bars, padding=2, fontsize=10, fmt=lambda value: f\"{value:.5f}\")\n\n        # Update the maximum y-value if the current heights exceed it\n        max_y_value = max(max(heights), max_y_value)\n\n        # Increment the offset for the next set of bars\n        bar_offset += 1\n\n    # Set plot title and labels\n    ax.set_title(title, fontsize=10, pad=0)\n    ax.legend(loc=\"upper left\", ncols=3)\n    ax.set_xlabel(\"Subscription Count\", labelpad=7)\n    ax.set_ylabel(\"Event Emission Time (seconds)\", labelpad=7)\n\n    # Set x-ticks to correspond to subscription sizes\n    ax.set_xticks(x_positions + (bar_width / 2), subscription_sizes)\n\n    # Set y-axis limit to accommodate the highest bar with some padding\n    ax.set_ylim(ymax=max_y_value + (max_y_value * 0.15), auto=True)\n\n    # Save the plot to the specified filename\n    plt.savefig(output_file)\n\ndef main():\n    def clear_console():\n        \"\"\"Clear the console based on the operating system.\"\"\"\n        if os.name == \"nt\":  # For Windows\n            os.system(\"cls\")\n        else:  # For macOS and Linux\n            os.system(\"clear\")\n\n    def uninstall_pyventus() -&gt; None:\n        \"\"\"Uninstall the currently installed version of pyventus using pip.\"\"\"\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"uninstall\", \"-y\", \"pyventus\"])\n\n    def install_pyventus(version: str = \"\") -&gt; None:\n        \"\"\"Install pyventus using pip, with an optional version parameter.\"\"\"\n        version = (\".\" if version == \".\" else (f\"pyventus=={version}\" if version else \"pyventus\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", version])\n\n    # Uninstall the currently installed version of pyventus to avoid conflicts\n    # and ensure a clean environment for the installation of the specified version (0.6.0).\n    uninstall_pyventus()\n    install_pyventus(version=\"0.6.0\")\n    clear_console()\n\n    # Run the benchmark with pyventus v0.6.0 in a separate process to avoid conflicts.\n    with ProcessPoolExecutor() as executor:\n        fut = executor.submit(run_event_emitter_benchmarks)\n        pyventus_v060_reports = fut.result()\n        clear_console()\n\n    # Remove executor reference\n    del executor\n\n    # Uninstall the current version of pyventus again to prepare for the next version.\n    uninstall_pyventus()\n    install_pyventus(version=\".\")\n    clear_console()\n\n    # Force a garbage collection.\n    gc.collect()\n\n    # Run the benchmark with the current version of pyventus (0.7.0) in a separate process.\n    with ProcessPoolExecutor() as executor:\n        fut = executor.submit(run_event_emitter_benchmarks)\n        pyventus_v070_reports = fut.result()\n        clear_console()\n\n    print(\"Almost done. Saving reports...\")\n\n    # Save the reports for pyventus v0.6.0 to a JSON file.\n    with open(\"dist/pyventus_v060_eeb_reports.json\", \"w\") as f1:\n        f1.write(f\"{dumps([asdict(report) for report in pyventus_v060_reports])}\\n\")\n\n    # Save the reports for pyventus v0.7.0 to a JSON file.\n    with open(\"dist/pyventus_v070_eeb_reports.json\", \"w\") as f2:\n        f2.write(f\"{dumps([asdict(report) for report in pyventus_v070_reports])}\\n\")\n\n    clear_console()\n\n    # Indicate that charts are being generated.\n    print(\"Generating charts...\")\n\n    # Generate comparison charts for the two versions of pyventus.\n    for i, (v060_report, v070_report) in enumerate(zip(pyventus_v060_reports, pyventus_v070_reports, strict=False)):\n        plot_event_emitter_benchmark_comparison(\n            title=(\n                f\"Impact of Subscription Count on Event Emission Time: Comparison of Pyventus v0.6.0 and v0.7.0\\n\"\n                f\"(Event Subscription: {v060_report.event_subscription_mode.capitalize()}, \"\n                f\"One-time Subscription: {v060_report.onetime_subscription_mode.capitalize()}, \"\n                f\"Repeats: {v060_report.num_repeats}, Executions: {v060_report.num_executions})\\n\"\n            ),\n            subscription_sizes=v060_report.subscription_sizes,\n            benchmark_bars={\n                (\"Pyventus v0.6.0\", \"#0aaec4\"): [\n                    measurement.execution_time for measurement in v060_report.measurements\n                ],\n                (\"Pyventus v0.7.0\", \"#fba700\"): [\n                    measurement.execution_time for measurement in v070_report.measurements\n                ],\n            },\n            output_file=f\"dist/pyventus_eeb_chart_{i}.png\",\n        )\n\n    print(\"All Done!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>As shown in the previous script, the <code>EventEmitterBenchmark</code> class provides several parameters that can be configured to tailor the performance tests for various scenarios. This flexibility enables a comprehensive evaluation of the event emission process. Below are the key configurations available in the <code>EventEmitterBenchmark</code> class:</p> <ul> <li> <p>Event Subscription Mode: This parameter defines how event subscriptions behave during the benchmark.</p> <ul> <li>Single: In this mode, each subscriber is limited to a single event.</li> <li>Random: This mode allows subscribers to register for the specified event along with a random selection of additional events from the registry.</li> <li>All: When this mode is selected, subscribers will register for the specified event as well as all other registered events.</li> </ul> </li> <li> <p>One-Time Subscription Mode: This parameter defines how one-time subscriptions are handled in the benchmark.</p> <ul> <li>None: In this mode, no one-time subscribers will be registered; the <code>once</code> property is always set to <code>False</code>.</li> <li>Random: This mode randomizes the <code>once</code> property, allowing for a mix of one-time and regular subscriptions.</li> <li>All: When this mode is selected, all subscriptions are treated as one-time subscriptions; the <code>once</code> property is always set to <code>True</code>.</li> </ul> </li> <li> <p>Subscription Sizes: This parameter specifies a list of varying subscription sizes used in the benchmark.</p> <ul> <li> <p>A mathematical formula is employed to proportionally subdivide the number of events and subscribers based on the specified subscription size.</p> <ul> <li>Number of Events: Calculated as: \\(\\lfloor \\sqrt{num\\_subscriptions} \\rfloor\\).</li> <li>Subscribers per Event: Calculated as: \\(\\lfloor num\\_subscriptions/num\\_events \\rfloor\\).</li> <li>Remaining Subscribers: Calculated as: \\(num\\_subscriptions - num\\_events \\cdot num\\_subscribers\\).</li> </ul> </li> <li> <p>Note that depending on the selected event subscription mode, the number of subscribers per event may exceed the calculated proportion. For instance, if the event subscription mode is set to <code>ALL</code>, each subscriber will be registered across all event sets, resulting in each event set's length being equal to the subscription size.</p> </li> </ul> </li> <li> <p>Number of Repeats: This parameter indicates how many times the benchmark is repeated.</p> </li> <li>Number of Executions: This parameter represents the total number of executions performed during the benchmark.</li> </ul> <li> <p>Metrics Collected: The main metric used to assess the efficiency of the event emission process during the performance tests is the Event Emission Time. This metric tracks the time (in seconds) that it takes to complete the event emission process for each subscription size.</p> </li> <li> <p>Calculation Method: To determine the event emission time for a given subscription size, the event emission process is executed multiple times (as specified by <code>num_executions</code>) and repeated for a number of iterations (as declared by <code>num_repeats</code>). The elapsed time for each execution is recorded, and the median of these recorded times is calculated to establish the event emission time for that repetition, which helps reduce the impact of outliers. Once all repetitions are completed, the final event emission time is determined by calculating the mean of the medians from each repetition. Additionally, to minimize timing noise, the garbage collector is disabled during the tests, and the <code>perf_counter</code> function is used for accurate measurements.</p> </li> <li> <p>Results:</p> <ul> <li> <p>Event Emitter Benchmark 01: This benchmark was configured with the event subscription mode set to Single and the one-time subscription mode set to None. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=NONE)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 1555.6348432,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"None\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0021713468276594356\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.0022923071408520593\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.002319530000003561\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.00234521428777057\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.002376250000902652\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=NONE)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 2232.0822847000018,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"None\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0021696501370083562\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.002224228570831580\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00229092857083158\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.002311342857417113\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.00235225142652442\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00217135 0.00216965 0.08% faster 500 Event Emission Time (s) 0.00229231 0.00222423 2.97% faster 1000 Event Emission Time (s) 0.00231953 0.00229093 1.23% faster 1000 Event Emission Time (s) 0.00234521 0.00231134 1.44% faster 10000 Event Emission Time (s) 0.00237625 0.00235225 1.01% faster </p> </li> <li> <p>Event Emitter Benchmark 02: This benchmark was configured with the event subscription mode set to Single and the one-time subscription mode set to All. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 1613.8905598000001,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.00215918000001238\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.002478313333360442\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00263769000002866\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.0049624499999026707\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.009284669999897231\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 2257.228092499994,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.002121700000892163\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.0022747199998723815\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00231161000054562\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.0023325299973394723\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.0023679700057022275\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00215918 0.00212170 1.74% faster 500 Event Emission Time (s) 0.00247831 0.00227472 8.21% faster 1000 Event Emission Time (s) 0.00263769 0.00231161 12.36% faster 5000 Event Emission Time (s) 0.00496245 0.00233253 53% faster 10000 Event Emission Time (s) 0.00928467 0.00236797 74.5% faster </p> </li> <li> <p>Event Emitter Benchmark 03: This benchmark was configured with the event subscription mode set to All and the one-time subscription mode set to All. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=ALL, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 16962.5048258,\n  \"event_subscription_mode\": \"All\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0032661600000665203\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.009857880000072327\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.02087080000010246\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.30020038000020577\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 1.607526350000171\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=ALL, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 9898.425464699998,\n  \"event_subscription_mode\": \"All\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.002867740001238417\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.007017190001351992\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.01340035999965039\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.10753672999926493\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.2562398899979598\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00326616 0.00286774 12.2% faster 500 Event Emission Time (s) 0.00985788 0.00701719 28.82% faster 1000 Event Emission Time (s) 0.02087080 0.01340036 35.79% faster 5000 Event Emission Time (s) 0.30020038 0.10753673 64.18% faster 10000 Event Emission Time (s) 1.60752635 0.25623989 84.06% faster </p> </li> <li> <p>Event Emitter Benchmark 04: This benchmark was configured with both the event and one-time subscription modes set to Random. The test was repeated 3 times, with 500 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>    {\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=RANDOM, onetime_subscription_mode=RANDOM)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 12883.082557200003,\n  \"event_subscription_mode\": \"Random\",\n  \"onetime_subscription_mode\": \"Random\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 3,\n  \"num_executions\": 500,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0020576499997938904\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.007661850000052557\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.026361883333568887\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 1.1266335333342188\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 6.6018846833333855\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>    {\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=RANDOM, onetime_subscription_mode=RANDOM)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 1836.9729208999997,\n  \"event_subscription_mode\": \"Random\",\n  \"onetime_subscription_mode\": \"Random\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 3,\n  \"num_executions\": 500,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0020046499994350597\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.004163983332546195\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.006543066667897317\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.03050753333324489\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.07419393333475455\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00205765 0.00200465 2.64% faster 500 Event Emission Time (s) 0.00766185 0.00416398 45.65% faster 1000 Event Emission Time (s) 0.02636188 0.00654307 75.18% faster 5000 Event Emission Time (s) 1.12663353 0.03050753 97.29% faster 10000 Event Emission Time (s) 6.60188468 0.07419393 98.88% faster </p> </li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0As shown in the previous tables, reports, and charts, the improvements made to the event-driven features are significant, especially when one-time subscribers are involved and randomized. It's important to note that these optimizations apply not only to the event emission process but also to other components, such as the <code>EventLinker</code>.</p> </li>"},{"location":"release-notes/#0.6.0","title":"v0.6.0 October 19, 2024","text":""},{"location":"release-notes/#0.6.0-added","title":"Added","text":"<ul> <li>Added support for Python <code>3.13</code>, ensuring compatibility with the latest features and improvements.</li> <li>Added <code>mike</code> package integration to <code>mkdocs-material</code> for documentation versioning. This allows users to access previous documentation alongside new changes, ensuring that legacy content remains intact for reference. Additionally, a new <code>dev</code> documentation has been introduced to showcase the current development of the package, including unreleased features and updates.</li> </ul>"},{"location":"release-notes/#0.6.0-changed","title":"Changed","text":"<ul> <li>Updated documentation links from absolute to relative paths to prevent broken links and avoid redirecting users to incorrect documentation versions, ensuring consistent navigation throughout the docs.</li> <li>Upgraded the <code>download-artifact</code> and <code>cache</code> actions to <code>v4</code> in the <code>publish-to-pypi.yml</code> workflow.</li> <li>Updated the <code>deploy-docs.yml</code> workflow to deploy both <code>dev</code> and versioned documentation using <code>mike</code>'s CLI commands.</li> </ul>"},{"location":"release-notes/#0.6.0-fixed","title":"Fixed","text":"<ul> <li>Fixed broken links to non-versioned documentation by adding a custom <code>404.html</code> page to <code>gh-pages</code>, which redirects users to the first version of the documentation when no version is specified, or to a new custom 404 page with helpful suggestions.</li> </ul>"},{"location":"release-notes/#0.5.0","title":"v0.5.0 April 9, 2024","text":""},{"location":"release-notes/#0.5.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed the base <code>Event</code> class due to improved event semantics and unnecessary redundancy.</li> <li>Renamed the <code>get_event_registry()</code> method of <code>EventLinker</code> to <code>get_registry()</code>.</li> <li>Renamed the <code>__event_registry</code> inner property of <code>EventLinker</code> to <code>__registry</code>.</li> <li>Renamed the <code>get_events_by_handler()</code> method of <code>EventLinker</code> to <code>get_events_by_event_handler()</code>.</li> <li>Renamed the <code>get_handlers_by_events()</code> method of <code>EventLinker</code> to <code>get_event_handlers_by_events()</code>.</li> <li>Renamed the protected method <code>_executor_callback()</code> of the <code>ExecutorEventEmitter</code> to <code>_callback()</code>.</li> <li>Renamed the task name of <code>CeleryEventEmitter</code> from <code>_executor</code> to <code>pyventus_executor</code> to avoid collisions with other task names.</li> </ul>"},{"location":"release-notes/#0.5.0-added","title":"Added","text":"<ul> <li>Added <code>__slots__</code> to <code>EventLinkageWrapper</code> class for more efficient memory usage.</li> <li>Extended support for subscription and emission of any <code>dataclass</code> object, removing the limitation of only <code>Event</code> subclasses.</li> <li>Added the <code>force_async</code> parameter to the <code>EventHandler</code> class and <code>EventLinker</code> subscription methods to be able to optimize the execution of <code>sync</code> callbacks based on their workload.</li> <li>Introduced a new event semantic where the Python <code>...</code> (Ellipsis) is now used to refer to all events on a subscription, like the <code>onAny()</code> method but with a Pythonic syntax.</li> <li>Added the <code>mkdocs-material social cards</code> plugin, which provides a preview of the documentation content when shared on social media platforms.</li> </ul>"},{"location":"release-notes/#0.5.0-changed","title":"Changed","text":"<ul> <li>Standardized the order of static methods, class methods, and instance methods for improved readability.</li> <li>Applied Python best practices to optimize the methods within the <code>EventLinker</code> and <code>EventEmitter</code> classes.</li> <li>Improved validation of variable instances in the event emitters, <code>EventLinker</code>, and <code>EventHandler</code>.</li> <li>Updated and improved the test suite to ensure accurate validation and consistency.</li> <li>Enabled creation date for the mkdocs <code>git-revision-date-localized</code> plugin.</li> <li>Replaced the mkdocs <code>git-authors</code> plugin with the <code>git-committers</code> plugin.</li> <li>Updated and improved the package description.</li> <li>Updated the tutorial section to incorporate recent changes.</li> <li>Enhanced the documentation index page and README file with new examples and better descriptions to showcase the unique features of Pyventus.</li> </ul>"},{"location":"release-notes/#0.5.0-removed","title":"Removed","text":"<ul> <li>Removed the default value of the <code>once</code> flag in the <code>EventHandler</code> class.</li> </ul>"},{"location":"release-notes/#0.5.0-fixed","title":"Fixed","text":"<ul> <li>Fixed and standardized all package docstrings and code comments for consistency and clarity.</li> <li>Addressed minor errors and details in the documentation.</li> </ul>"},{"location":"release-notes/#0.4.1","title":"v0.4.1 January 30, 2024","text":""},{"location":"release-notes/#0.4.1-changed","title":"Changed","text":"<ul> <li>Optimized the size of the source distribution (sdist) build by including only essential files and directories, such as the <code>/src</code> and <code>/tests</code> directories, as well as the following files: <code>.gitignore</code>, <code>pyproject.toml</code>, <code>CITATION.cff</code>, <code>README</code>, and <code>LICENSE</code>.</li> <li>Refactored documentation dependencies into an optional dependency called <code>docs</code>.</li> <li>Updated the <code>deploy-docs.yml</code> GitHub workflow to leverage the new optional dependency <code>docs</code>.</li> <li>Updated the <code>EventEmission</code> class with the <code>@final</code> decorator from the typing module, indicating that it is meant for internal use only and should not be subclassed.</li> </ul>"},{"location":"release-notes/#0.4.1-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors and details in the documentation.</li> </ul>"},{"location":"release-notes/#0.4.0","title":"v0.4.0 January 6, 2024","text":""},{"location":"release-notes/#0.4.0-added","title":"Added","text":"<ul> <li>Added <code>FastAPIEventEmitter</code> implementation to facilitate seamless integration with the <code>FastAPI</code> framework.</li> <li>Added tests for <code>FastAPIEventEmitter</code> to validate its behavior and ensure proper operation.</li> <li>Added documentation for <code>FastAPIEventEmitter</code>, including tutorials and API references.</li> <li>Integrated the <code>Coveralls.io</code> workflow to generate coverage badge and reports.</li> <li>Included coverage badges on the main documentation page and the readme file.</li> <li>Introduced permalinks within the documentation for easy navigation.</li> </ul>"},{"location":"release-notes/#0.4.0-changed","title":"Changed","text":"<ul> <li>Updated <code>pyproject.toml</code> with the new optional dependency for <code>FastAPI</code> integration.</li> </ul>"},{"location":"release-notes/#0.4.0-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors in the Pyventus documentation to improve accuracy and clarity.</li> </ul>"},{"location":"release-notes/#0.3.0","title":"v0.3.0 December 29, 2023","text":""},{"location":"release-notes/#0.3.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li>Introduced <code>EventEmission</code> object to encapsulate the processing of event emissions. This changes the <code>_execute()</code> method of <code>EventEmitter</code> but provides a cleaner, more scalable, and efficient approach.</li> <li>Renamed all debug flags from <code>debug_mode</code> to <code>debug</code> for enhanced clarity and consistency.</li> <li>Renamed EventEmitter's <code>_execute()</code> method to <code>_process()</code> to better reflect its purpose of processing event emissions.</li> </ul>"},{"location":"release-notes/#0.3.0-added","title":"Added","text":"<ul> <li>Added <code>CeleryEventEmitter</code> implementation to leverage the Celery distributed task queue for event handling.</li> <li>Added tests for <code>CeleryEventEmitter</code> to validate its behavior and ensure proper operation.</li> <li>Added documentation for <code>CeleryEventEmitter</code>, including tutorials and API references.</li> </ul>"},{"location":"release-notes/#0.3.0-changed","title":"Changed","text":"<ul> <li>Restructured the documentation for event emitters tutorials and API references to improve organization and clarity.</li> <li>Updated the <code>contributing.md</code> page to include the Troubleshooting Hatch Environment Errors section.</li> <li>Updated the <code>EventEmitter</code> API documentation to include the <code>EventEmission</code> class reference.</li> <li>Updated <code>pyproject.toml</code> with the new optional dependency for <code>Celery</code> integration.</li> <li>Updated <code>mypy</code> ignore flags to properly silence specific false positive error codes.</li> </ul>"},{"location":"release-notes/#0.3.0-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors in the Pyventus documentation.</li> </ul>"},{"location":"release-notes/#0.2.1","title":"v0.2.1 December 17, 2023","text":""},{"location":"release-notes/#0.2.1-changed","title":"Changed","text":"<ul> <li>Updated docstring links throughout the package to refer to the official documentation.</li> <li>Updated the <code>RQEventEmitter</code> API Reference and Tutorials docs to reflect the new optional import.</li> </ul>"},{"location":"release-notes/#0.2.1-fixed","title":"Fixed","text":"<ul> <li>Resolved the issue where the <code>RQEventEmitter</code> class was automatically imported in the main package, requiring the installation of its optional dependency to use any of the package's core functionalities. It is now fully optional.</li> <li>Fixed issues with invalid links in the documentation.</li> </ul>"},{"location":"release-notes/#0.2.0","title":"v0.2.0 December 16, 2023","text":""},{"location":"release-notes/#0.2.0-added","title":"Added","text":"<ul> <li>Introduced the <code>publish to PyPI</code> workflow, automating the uploading of package builds when new releases are created.</li> <li>Added the <code>mkdocs-git-authors</code> plugin to display git authors of a markdown page in the documentation.</li> <li>Added badges to the main page of the documentation as well as the readme file.</li> <li>Added a code of conduct for the project, using the Contributor Covenant v2.1.</li> <li>Included a <code>CITATION.cff</code> file to facilitate academic citations.</li> </ul>"},{"location":"release-notes/#0.2.0-changed","title":"Changed","text":"<ul> <li>Renamed the <code>tests.yml</code> workflow to <code>run-tests.yml</code>.</li> <li>Updated the <code>deploy-docs.yml</code> workflow with the <code>mkdocs-git-authors</code> plugin dependency.</li> <li>Modified the <code>mkdocs.yml</code> config file by adding the <code>site_url</code> and <code>site_author</code> properties.</li> <li>Updated the <code>pyproject.toml</code> file with the <code>mkdocs-git-authors</code> plugin dependency and python package keywords.</li> </ul>"},{"location":"release-notes/#0.2.0-fixed","title":"Fixed","text":"<ul> <li>Fixed the python version in the <code>deploy-docs.yml</code> workflow.</li> <li>Resolved issues with relative links in the documentation.</li> </ul>"},{"location":"release-notes/#0.1.0","title":"v0.1.0 December 15, 2023","text":""},{"location":"release-notes/#initial-implementation","title":"Initial Implementation","text":"<p>\u2003\u2003This release introduces Pyventus v0.1.0, a modern and robust Python package for event-driven programming. Pyventus provides developers with a comprehensive suite of tools and utilities to define, emit, and orchestrate events. It empowers developers to build scalable, extensible, and loosely-coupled event-driven applications.</p> <ul> <li>Implementation Details: The first implementation includes all the core functionalities of the package, encompassing events, event linkers, event emitters, event handlers, and more.</li> <li>Testing and Coverage: This release includes a test suite that verifies the correctness of the package implementation. It also integrates code coverage, achieving 100% test coverage. The tests are configured to run automatically via GitHub Actions on both push and pull requests to the master branch.</li> <li>Formatter and Lint Configuration: A formatter and lint configuration have been added to the project. This ensures consistent code style, maintainability, and adherence to the established coding standards defined in the project documentation.</li> <li>Documentation: Additionally, this release includes comprehensive documentation for the package. The documentation covers the main page, a detailed getting started guide, tutorials, API reference, and release notes.</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>     \u2003\u2003Welcome to the Pyventus API Reference, a comprehensive guide that provides detailed information about the classes, functions, parameters, attributes, and other components available in Pyventus. </p> <p>     \u2003\u2003In the API Reference, you will find detailed documentation for each component, including clear explanations, parameter details, and return values. You can navigate through the reference using the search functionality or by browsing the different sections and categories to find the specific information you need. </p> <p> </p> <p> Let's explore the Pyventus API Reference! </p>"},{"location":"api/core/","title":"<code>Core</code> module","text":"<p>The essential building blocks of Pyventus.</p>"},{"location":"api/core/collections/multi_bidict/","title":"<code>MultiBidict</code> class","text":"<p>               Bases: <code>Generic[_KT, _VT]</code></p> <p>A generic multikeyed, multivalued bidirectional dictionary.</p> <p>Notes:</p> <ul> <li> <p>This class provides a flexible mapping structure that enables efficient     lookups, updates, and deletions of keys and their corresponding values.</p> </li> <li> <p>Although this class uses a bidirectional mapping structure, its memory     footprint remains minimal due to the use of references between keys and     values instead of duplication, which limits the impact to the additional     dictionary and set data structures.</p> </li> <li> <p>Most methods in this class operate with an average time complexity of O(1),     ensuring high efficiency. However, the performance of removal operations     may vary depending on the relationships between keys and values.</p> </li> <li> <p>This class is not inherently designed for concurrent access; therefore,     thread safety considerations should be taken into account when using it     in multithreaded environments.</p> </li> </ul> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>class MultiBidict(Generic[_KT, _VT]):\n    \"\"\"\n    A generic multikeyed, multivalued bidirectional dictionary.\n\n    **Notes:**\n\n    -   This class provides a flexible mapping structure that enables efficient\n        lookups, updates, and deletions of keys and their corresponding values.\n\n    -   Although this class uses a bidirectional mapping structure, its memory\n        footprint remains minimal due to the use of references between keys and\n        values instead of duplication, which limits the impact to the additional\n        dictionary and set data structures.\n\n    -   Most methods in this class operate with an average time complexity of O(1),\n        ensuring high efficiency. However, the performance of removal operations\n        may vary depending on the relationships between keys and values.\n\n    -   This class is not inherently designed for concurrent access; therefore,\n        thread safety considerations should be taken into account when using it\n        in multithreaded environments.\n    \"\"\"\n\n    # Attributes for the MultiBidict\n    __slots__ = (\"__fwd_dict\", \"__inv_dict\")\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize an instance of `MultiBidict`.\n\n        This constructor sets up two dictionaries: one for storing\n        the forward mapping of keys to values and another for the\n        inverse mapping of values to keys. Both dictionaries are\n        initialized as empty.\n        \"\"\"\n        # Initialize the main dictionary and its inverse\n        self.__fwd_dict: dict[_KT, set[_VT]] = {}\n        self.__inv_dict: dict[_VT, set[_KT]] = {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                fwd_dict=self.__fwd_dict,\n                inv_dict=self.__inv_dict,\n            ),\n        )\n\n    @property\n    def is_empty(self) -&gt; bool:\n        \"\"\"\n        Determine whether the dictionary is empty.\n\n        :return: `True` if the dictionary is empty, `False` otherwise.\n        \"\"\"\n        return not self.__fwd_dict\n\n    @property\n    def keys(self) -&gt; set[_KT]:\n        \"\"\"\n        Retrieve all keys from the dictionary.\n\n        :return: A set of all keys in the dictionary.\n        \"\"\"\n        return set(self.__fwd_dict.keys())\n\n    @property\n    def values(self) -&gt; set[_VT]:\n        \"\"\"\n        Retrieve all values from the dictionary.\n\n        :return: A set of all values in the dictionary.\n        \"\"\"\n        return set(self.__inv_dict.keys())\n\n    @property\n    def key_count(self) -&gt; int:\n        \"\"\"\n        Retrieve the number of unique keys in the dictionary.\n\n        :return: The total count of keys in the dictionary.\n        \"\"\"\n        return len(self.__fwd_dict)\n\n    @property\n    def value_count(self) -&gt; int:\n        \"\"\"\n        Retrieve the number of unique values in the dictionary.\n\n        :return: The total count of values in the dictionary.\n        \"\"\"\n        return len(self.__inv_dict)\n\n    def get_keys_from_values(self, values: set[_VT]) -&gt; set[_KT]:\n        \"\"\"\n        Retrieve a set of keys associated with the specified values.\n\n        :param values: A set of values for which to retrieve the associated keys.\n        :return: A set of keys associated with the given values.\n            Unregistered values are ignored.\n        \"\"\"\n        return {key for value in values for key in self.__inv_dict.get(value, [])}\n\n    def get_values_from_keys(self, keys: set[_KT]) -&gt; set[_VT]:\n        \"\"\"\n        Retrieve a set of values associated with the specified keys.\n\n        :param keys: A set of keys for which to retrieve the associated values.\n        :return: A set of values associated with the given keys.\n            Unregistered keys are ignored.\n        \"\"\"\n        return {value for key in keys for value in self.__fwd_dict.get(key, [])}\n\n    def get_key_count_from_value(self, value: _VT) -&gt; int:\n        \"\"\"\n        Retrieve the number of keys associated with the specified value.\n\n        :param value: The value for which to count the associated keys.\n        :return: The count of keys associated with the specified value,\n            or 0 if the value is not found.\n        \"\"\"\n        return len(self.__inv_dict[value]) if value in self.__inv_dict else 0\n\n    def get_value_count_from_key(self, key: _KT) -&gt; int:\n        \"\"\"\n        Return the number of values associated with a given key.\n\n        :param key: The key for which to count the associated values.\n        :return: The count of values associated with the specified key,\n            or 0 if the key is not found.\n        \"\"\"\n        return len(self.__fwd_dict[key]) if key in self.__fwd_dict else 0\n\n    def contains_key(self, key: _KT) -&gt; bool:\n        \"\"\"\n        Determine if the specified key is present in the dictionary.\n\n        :param key: The key to be checked.\n        :return: `True` if the key is found, `False` otherwise.\n        \"\"\"\n        return key in self.__fwd_dict\n\n    def contains_value(self, value: _VT) -&gt; bool:\n        \"\"\"\n        Determine if the specified value is present in the dictionary.\n\n        :param value: The value to be checked.\n        :return: `True` if the value is found, `False` otherwise.\n        \"\"\"\n        return value in self.__inv_dict\n\n    def are_associated(self, key: _KT, value: _VT) -&gt; bool:\n        \"\"\"\n        Determine whether the given key is associated with the specified value.\n\n        :param key: The key for which the association is being checked.\n        :param value: The value for which the association is being checked.\n        :return: `True` if the value is associated with the key, `False` otherwise.\n        \"\"\"\n        # Ensure that both the key and value are registered\n        if key not in self.__fwd_dict or value not in self.__inv_dict:\n            return False\n\n        # Check if the value is associated with the key\n        return value in self.__fwd_dict[key]\n\n    def insert(self, key: _KT, value: _VT) -&gt; None:\n        \"\"\"\n        Insert the given value with the specified key into the dictionary.\n\n        :param key: The key to which the value will be associated.\n        :param value: The value to be inserted for the key.\n        :return: None.\n        \"\"\"\n        # Add the value to the key's set\n        if key not in self.__fwd_dict:\n            self.__fwd_dict[key] = set()\n        self.__fwd_dict[key].add(value)\n\n        # Add the key to the value's set\n        if value not in self.__inv_dict:\n            self.__inv_dict[value] = set()\n        self.__inv_dict[value].add(key)\n\n    def remove(self, key: _KT, value: _VT) -&gt; None:\n        \"\"\"\n        Remove the specified value from the given key.\n\n        :param key: The key from which the value will be removed.\n        :param value: The value to be removed from the key.\n        :return: None.\n        :raises KeyError: If the key or value is\n            not registered or associated.\n        \"\"\"\n        # Remove the value from the key's set\n        self.__fwd_dict[key].remove(value)\n\n        # If the key has no remaining values,\n        # remove it from the dictionary\n        if not self.__fwd_dict[key]:\n            self.__fwd_dict.pop(key)\n\n        # Remove the key from the value's set\n        self.__inv_dict[value].remove(key)\n\n        # If the value is no longer associated with\n        # any key, remove it from the inverse dictionary\n        if not self.__inv_dict[value]:\n            self.__inv_dict.pop(value)\n\n    def remove_key(self, key: _KT) -&gt; None:\n        \"\"\"\n        Remove the specified key from the dictionary.\n\n        :param key: The key to be removed from the dictionary.\n        :return: None.\n        :raises KeyError: If the key is not registered.\n        \"\"\"\n        # Remove the key and retrieve its associated values\n        values: set[_VT] = self.__fwd_dict.pop(key)\n\n        # Remove the key from each value's set\n        for value in values:\n            self.__inv_dict[value].remove(key)\n\n            # If the value is no longer associated with any\n            # keys, remove it from the inverse dictionary\n            if not self.__inv_dict[value]:\n                self.__inv_dict.pop(value)\n\n    def remove_value(self, value: _VT) -&gt; None:\n        \"\"\"\n        Remove the specified value from the dictionary.\n\n        :param value: The value to be removed from the dictionary.\n        :return: None.\n        :raises KeyError: If the value is not registered.\n        \"\"\"\n        # Remove the value and retrieve its associated keys\n        keys: set[_KT] = self.__inv_dict.pop(value)\n\n        # Remove the value from each key's set\n        for key in keys:\n            self.__fwd_dict[key].remove(value)\n\n            # If the key is no longer associated with\n            # any values, remove it from the dictionary\n            if not self.__fwd_dict[key]:\n                self.__fwd_dict.pop(key)\n\n    def pop_key(self, key: _KT) -&gt; set[_VT]:\n        \"\"\"\n        Remove the specified key from the dictionary and returns the associated values.\n\n        :param key: The key to be removed.\n        :return: A set of values associated with the removed key.\n        :raises KeyError: If the key is not found in the dictionary.\n        \"\"\"\n        # Remove the key and retrieve its associated values\n        values: set[_VT] = self.__fwd_dict.pop(key)\n\n        # Remove the key from each value's set\n        for value in values:\n            self.__inv_dict[value].remove(key)\n\n            # If the value is no longer associated with any\n            # keys, remove it from the inverse dictionary\n            if not self.__inv_dict[value]:\n                self.__inv_dict.pop(value)\n\n        # Return the set of values\n        return values\n\n    def pop_value(self, value: _VT) -&gt; set[_KT]:\n        \"\"\"\n        Remove the specified value from the dictionary and returns the associated keys.\n\n        :param value: The value to be removed.\n        :return: A set of keys associated with the removed value.\n        :raises KeyError: If the value is not found in the dictionary.\n        \"\"\"\n        # Remove the value and retrieve its associated keys\n        keys: set[_KT] = self.__inv_dict.pop(value)\n\n        # Remove the value from each key's set\n        for key in keys:\n            self.__fwd_dict[key].remove(value)\n\n            # If the key is no longer associated with\n            # any values, remove it from the dictionary\n            if not self.__fwd_dict[key]:\n                self.__fwd_dict.pop(key)\n\n        # Return the set of keys\n        return keys\n\n    def clear(self) -&gt; None:\n        \"\"\"\n        Clear the dictionary by removing all keys and values.\n\n        :return: None.\n        \"\"\"\n        self.__fwd_dict.clear()\n        self.__inv_dict.clear()\n\n    def to_dict(self) -&gt; dict[_KT, set[_VT]]:\n        \"\"\"\n        Retrieve a shallow copy of the dictionary.\n\n        :return: A shallow copy of the main dictionary, where\n            each key is mapped to a set of its associated values.\n        \"\"\"\n        return {key: values.copy() for key, values in self.__fwd_dict.items()}\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict-attributes","title":"Attributes","text":""},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.is_empty","title":"is_empty  <code>property</code>","text":"<pre><code>is_empty: bool\n</code></pre> <p>Determine whether the dictionary is empty.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the dictionary is empty, <code>False</code> otherwise.</p>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.keys","title":"keys  <code>property</code>","text":"<pre><code>keys: set[_KT]\n</code></pre> <p>Retrieve all keys from the dictionary.</p> RETURNS DESCRIPTION <code>set[_KT]</code> <p>A set of all keys in the dictionary.</p>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.values","title":"values  <code>property</code>","text":"<pre><code>values: set[_VT]\n</code></pre> <p>Retrieve all values from the dictionary.</p> RETURNS DESCRIPTION <code>set[_VT]</code> <p>A set of all values in the dictionary.</p>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.key_count","title":"key_count  <code>property</code>","text":"<pre><code>key_count: int\n</code></pre> <p>Retrieve the number of unique keys in the dictionary.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of keys in the dictionary.</p>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.value_count","title":"value_count  <code>property</code>","text":"<pre><code>value_count: int\n</code></pre> <p>Retrieve the number of unique values in the dictionary.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of values in the dictionary.</p>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict-functions","title":"Functions","text":""},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an instance of <code>MultiBidict</code>.</p> <p>This constructor sets up two dictionaries: one for storing the forward mapping of keys to values and another for the inverse mapping of values to keys. Both dictionaries are initialized as empty.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize an instance of `MultiBidict`.\n\n    This constructor sets up two dictionaries: one for storing\n    the forward mapping of keys to values and another for the\n    inverse mapping of values to keys. Both dictionaries are\n    initialized as empty.\n    \"\"\"\n    # Initialize the main dictionary and its inverse\n    self.__fwd_dict: dict[_KT, set[_VT]] = {}\n    self.__inv_dict: dict[_VT, set[_KT]] = {}\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.get_keys_from_values","title":"get_keys_from_values","text":"<pre><code>get_keys_from_values(values: set[_VT]) -&gt; set[_KT]\n</code></pre> <p>Retrieve a set of keys associated with the specified values.</p> PARAMETER DESCRIPTION <code>values</code> <p>A set of values for which to retrieve the associated keys.</p> <p> TYPE: <code>set[_VT]</code> </p> RETURNS DESCRIPTION <code>set[_KT]</code> <p>A set of keys associated with the given values. Unregistered values are ignored.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def get_keys_from_values(self, values: set[_VT]) -&gt; set[_KT]:\n    \"\"\"\n    Retrieve a set of keys associated with the specified values.\n\n    :param values: A set of values for which to retrieve the associated keys.\n    :return: A set of keys associated with the given values.\n        Unregistered values are ignored.\n    \"\"\"\n    return {key for value in values for key in self.__inv_dict.get(value, [])}\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.get_values_from_keys","title":"get_values_from_keys","text":"<pre><code>get_values_from_keys(keys: set[_KT]) -&gt; set[_VT]\n</code></pre> <p>Retrieve a set of values associated with the specified keys.</p> PARAMETER DESCRIPTION <code>keys</code> <p>A set of keys for which to retrieve the associated values.</p> <p> TYPE: <code>set[_KT]</code> </p> RETURNS DESCRIPTION <code>set[_VT]</code> <p>A set of values associated with the given keys. Unregistered keys are ignored.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def get_values_from_keys(self, keys: set[_KT]) -&gt; set[_VT]:\n    \"\"\"\n    Retrieve a set of values associated with the specified keys.\n\n    :param keys: A set of keys for which to retrieve the associated values.\n    :return: A set of values associated with the given keys.\n        Unregistered keys are ignored.\n    \"\"\"\n    return {value for key in keys for value in self.__fwd_dict.get(key, [])}\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.get_key_count_from_value","title":"get_key_count_from_value","text":"<pre><code>get_key_count_from_value(value: _VT) -&gt; int\n</code></pre> <p>Retrieve the number of keys associated with the specified value.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value for which to count the associated keys.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The count of keys associated with the specified value, or 0 if the value is not found.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def get_key_count_from_value(self, value: _VT) -&gt; int:\n    \"\"\"\n    Retrieve the number of keys associated with the specified value.\n\n    :param value: The value for which to count the associated keys.\n    :return: The count of keys associated with the specified value,\n        or 0 if the value is not found.\n    \"\"\"\n    return len(self.__inv_dict[value]) if value in self.__inv_dict else 0\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.get_value_count_from_key","title":"get_value_count_from_key","text":"<pre><code>get_value_count_from_key(key: _KT) -&gt; int\n</code></pre> <p>Return the number of values associated with a given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for which to count the associated values.</p> <p> TYPE: <code>_KT</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The count of values associated with the specified key, or 0 if the key is not found.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def get_value_count_from_key(self, key: _KT) -&gt; int:\n    \"\"\"\n    Return the number of values associated with a given key.\n\n    :param key: The key for which to count the associated values.\n    :return: The count of values associated with the specified key,\n        or 0 if the key is not found.\n    \"\"\"\n    return len(self.__fwd_dict[key]) if key in self.__fwd_dict else 0\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.contains_key","title":"contains_key","text":"<pre><code>contains_key(key: _KT) -&gt; bool\n</code></pre> <p>Determine if the specified key is present in the dictionary.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to be checked.</p> <p> TYPE: <code>_KT</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the key is found, <code>False</code> otherwise.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def contains_key(self, key: _KT) -&gt; bool:\n    \"\"\"\n    Determine if the specified key is present in the dictionary.\n\n    :param key: The key to be checked.\n    :return: `True` if the key is found, `False` otherwise.\n    \"\"\"\n    return key in self.__fwd_dict\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.contains_value","title":"contains_value","text":"<pre><code>contains_value(value: _VT) -&gt; bool\n</code></pre> <p>Determine if the specified value is present in the dictionary.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to be checked.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the value is found, <code>False</code> otherwise.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def contains_value(self, value: _VT) -&gt; bool:\n    \"\"\"\n    Determine if the specified value is present in the dictionary.\n\n    :param value: The value to be checked.\n    :return: `True` if the value is found, `False` otherwise.\n    \"\"\"\n    return value in self.__inv_dict\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.are_associated","title":"are_associated","text":"<pre><code>are_associated(key: _KT, value: _VT) -&gt; bool\n</code></pre> <p>Determine whether the given key is associated with the specified value.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for which the association is being checked.</p> <p> TYPE: <code>_KT</code> </p> <code>value</code> <p>The value for which the association is being checked.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the value is associated with the key, <code>False</code> otherwise.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def are_associated(self, key: _KT, value: _VT) -&gt; bool:\n    \"\"\"\n    Determine whether the given key is associated with the specified value.\n\n    :param key: The key for which the association is being checked.\n    :param value: The value for which the association is being checked.\n    :return: `True` if the value is associated with the key, `False` otherwise.\n    \"\"\"\n    # Ensure that both the key and value are registered\n    if key not in self.__fwd_dict or value not in self.__inv_dict:\n        return False\n\n    # Check if the value is associated with the key\n    return value in self.__fwd_dict[key]\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.insert","title":"insert","text":"<pre><code>insert(key: _KT, value: _VT) -&gt; None\n</code></pre> <p>Insert the given value with the specified key into the dictionary.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to which the value will be associated.</p> <p> TYPE: <code>_KT</code> </p> <code>value</code> <p>The value to be inserted for the key.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def insert(self, key: _KT, value: _VT) -&gt; None:\n    \"\"\"\n    Insert the given value with the specified key into the dictionary.\n\n    :param key: The key to which the value will be associated.\n    :param value: The value to be inserted for the key.\n    :return: None.\n    \"\"\"\n    # Add the value to the key's set\n    if key not in self.__fwd_dict:\n        self.__fwd_dict[key] = set()\n    self.__fwd_dict[key].add(value)\n\n    # Add the key to the value's set\n    if value not in self.__inv_dict:\n        self.__inv_dict[value] = set()\n    self.__inv_dict[value].add(key)\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.remove","title":"remove","text":"<pre><code>remove(key: _KT, value: _VT) -&gt; None\n</code></pre> <p>Remove the specified value from the given key.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key from which the value will be removed.</p> <p> TYPE: <code>_KT</code> </p> <code>value</code> <p>The value to be removed from the key.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the key or value is not registered or associated.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def remove(self, key: _KT, value: _VT) -&gt; None:\n    \"\"\"\n    Remove the specified value from the given key.\n\n    :param key: The key from which the value will be removed.\n    :param value: The value to be removed from the key.\n    :return: None.\n    :raises KeyError: If the key or value is\n        not registered or associated.\n    \"\"\"\n    # Remove the value from the key's set\n    self.__fwd_dict[key].remove(value)\n\n    # If the key has no remaining values,\n    # remove it from the dictionary\n    if not self.__fwd_dict[key]:\n        self.__fwd_dict.pop(key)\n\n    # Remove the key from the value's set\n    self.__inv_dict[value].remove(key)\n\n    # If the value is no longer associated with\n    # any key, remove it from the inverse dictionary\n    if not self.__inv_dict[value]:\n        self.__inv_dict.pop(value)\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.remove_key","title":"remove_key","text":"<pre><code>remove_key(key: _KT) -&gt; None\n</code></pre> <p>Remove the specified key from the dictionary.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to be removed from the dictionary.</p> <p> TYPE: <code>_KT</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the key is not registered.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def remove_key(self, key: _KT) -&gt; None:\n    \"\"\"\n    Remove the specified key from the dictionary.\n\n    :param key: The key to be removed from the dictionary.\n    :return: None.\n    :raises KeyError: If the key is not registered.\n    \"\"\"\n    # Remove the key and retrieve its associated values\n    values: set[_VT] = self.__fwd_dict.pop(key)\n\n    # Remove the key from each value's set\n    for value in values:\n        self.__inv_dict[value].remove(key)\n\n        # If the value is no longer associated with any\n        # keys, remove it from the inverse dictionary\n        if not self.__inv_dict[value]:\n            self.__inv_dict.pop(value)\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.remove_value","title":"remove_value","text":"<pre><code>remove_value(value: _VT) -&gt; None\n</code></pre> <p>Remove the specified value from the dictionary.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to be removed from the dictionary.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the value is not registered.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def remove_value(self, value: _VT) -&gt; None:\n    \"\"\"\n    Remove the specified value from the dictionary.\n\n    :param value: The value to be removed from the dictionary.\n    :return: None.\n    :raises KeyError: If the value is not registered.\n    \"\"\"\n    # Remove the value and retrieve its associated keys\n    keys: set[_KT] = self.__inv_dict.pop(value)\n\n    # Remove the value from each key's set\n    for key in keys:\n        self.__fwd_dict[key].remove(value)\n\n        # If the key is no longer associated with\n        # any values, remove it from the dictionary\n        if not self.__fwd_dict[key]:\n            self.__fwd_dict.pop(key)\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.pop_key","title":"pop_key","text":"<pre><code>pop_key(key: _KT) -&gt; set[_VT]\n</code></pre> <p>Remove the specified key from the dictionary and returns the associated values.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to be removed.</p> <p> TYPE: <code>_KT</code> </p> RETURNS DESCRIPTION <code>set[_VT]</code> <p>A set of values associated with the removed key.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the key is not found in the dictionary.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def pop_key(self, key: _KT) -&gt; set[_VT]:\n    \"\"\"\n    Remove the specified key from the dictionary and returns the associated values.\n\n    :param key: The key to be removed.\n    :return: A set of values associated with the removed key.\n    :raises KeyError: If the key is not found in the dictionary.\n    \"\"\"\n    # Remove the key and retrieve its associated values\n    values: set[_VT] = self.__fwd_dict.pop(key)\n\n    # Remove the key from each value's set\n    for value in values:\n        self.__inv_dict[value].remove(key)\n\n        # If the value is no longer associated with any\n        # keys, remove it from the inverse dictionary\n        if not self.__inv_dict[value]:\n            self.__inv_dict.pop(value)\n\n    # Return the set of values\n    return values\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.pop_value","title":"pop_value","text":"<pre><code>pop_value(value: _VT) -&gt; set[_KT]\n</code></pre> <p>Remove the specified value from the dictionary and returns the associated keys.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value to be removed.</p> <p> TYPE: <code>_VT</code> </p> RETURNS DESCRIPTION <code>set[_KT]</code> <p>A set of keys associated with the removed value.</p> RAISES DESCRIPTION <code>KeyError</code> <p>If the value is not found in the dictionary.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def pop_value(self, value: _VT) -&gt; set[_KT]:\n    \"\"\"\n    Remove the specified value from the dictionary and returns the associated keys.\n\n    :param value: The value to be removed.\n    :return: A set of keys associated with the removed value.\n    :raises KeyError: If the value is not found in the dictionary.\n    \"\"\"\n    # Remove the value and retrieve its associated keys\n    keys: set[_KT] = self.__inv_dict.pop(value)\n\n    # Remove the value from each key's set\n    for key in keys:\n        self.__fwd_dict[key].remove(value)\n\n        # If the key is no longer associated with\n        # any values, remove it from the dictionary\n        if not self.__fwd_dict[key]:\n            self.__fwd_dict.pop(key)\n\n    # Return the set of keys\n    return keys\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> <p>Clear the dictionary by removing all keys and values.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"\n    Clear the dictionary by removing all keys and values.\n\n    :return: None.\n    \"\"\"\n    self.__fwd_dict.clear()\n    self.__inv_dict.clear()\n</code></pre>"},{"location":"api/core/collections/multi_bidict/#pyventus.core.collections.MultiBidict.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[_KT, set[_VT]]\n</code></pre> <p>Retrieve a shallow copy of the dictionary.</p> RETURNS DESCRIPTION <code>dict[_KT, set[_VT]]</code> <p>A shallow copy of the main dictionary, where each key is mapped to a set of its associated values.</p> Source code in <code>pyventus/core/collections/multi_bidict.py</code> <pre><code>def to_dict(self) -&gt; dict[_KT, set[_VT]]:\n    \"\"\"\n    Retrieve a shallow copy of the dictionary.\n\n    :return: A shallow copy of the main dictionary, where\n        each key is mapped to a set of its associated values.\n    \"\"\"\n    return {key: values.copy() for key, values in self.__fwd_dict.items()}\n</code></pre>"},{"location":"api/core/exceptions/pyventus_exception/","title":"<code>PyventusException</code> class","text":"<p>               Bases: <code>Exception</code></p> <p>A custom exception class for the Pyventus package.</p> <p>Notes:</p> <ul> <li> <p>This class provides a robust mechanism for handling and identifying potential     exceptions within the Pyventus package.</p> </li> <li> <p>This class inherits from the base <code>Exception</code> class in Python, allowing it to be     raised as needed.</p> </li> </ul> Source code in <code>pyventus/core/exceptions/pyventus_exception.py</code> <pre><code>class PyventusException(Exception):\n    \"\"\"\n    A custom exception class for the Pyventus package.\n\n    **Notes:**\n\n    -   This class provides a robust mechanism for handling and identifying potential\n        exceptions within the Pyventus package.\n\n    -   This class inherits from the base `Exception` class in Python, allowing it to be\n        raised as needed.\n    \"\"\"\n\n    def __init__(self, errors: str | list[str] | None = None):\n        \"\"\"\n        Initialize an instance of `PyventusException`.\n\n        :param errors: The error messages associated with the exception. Defaults to `None`.\n        \"\"\"\n        self.errors: str | list[str] = errors if errors else self.__class__.__name__\n        super().__init__(errors)\n</code></pre>"},{"location":"api/core/exceptions/pyventus_exception/#pyventus.core.exceptions.PyventusException-attributes","title":"Attributes","text":""},{"location":"api/core/exceptions/pyventus_exception/#pyventus.core.exceptions.PyventusException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | list[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/core/exceptions/pyventus_exception/#pyventus.core.exceptions.PyventusException-functions","title":"Functions","text":""},{"location":"api/core/exceptions/pyventus_exception/#pyventus.core.exceptions.PyventusException.__init__","title":"__init__","text":"<pre><code>__init__(errors: str | list[str] | None = None)\n</code></pre> <p>Initialize an instance of <code>PyventusException</code>.</p> PARAMETER DESCRIPTION <code>errors</code> <p>The error messages associated with the exception. Defaults to <code>None</code>.</p> <p> TYPE: <code>str | list[str] | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyventus/core/exceptions/pyventus_exception.py</code> <pre><code>def __init__(self, errors: str | list[str] | None = None):\n    \"\"\"\n    Initialize an instance of `PyventusException`.\n\n    :param errors: The error messages associated with the exception. Defaults to `None`.\n    \"\"\"\n    self.errors: str | list[str] = errors if errors else self.__class__.__name__\n    super().__init__(errors)\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/","title":"<code>PyventusImportException</code> class","text":"<p>               Bases: <code>PyventusException</code></p> <p>A custom Pyventus exception for handling missing imports within the package.</p> <p>Notes:</p> <ul> <li> <p>This class provides a robust mechanism for handling and identifying potential     import exceptions within the Pyventus package.</p> </li> <li> <p>This class inherits from the base <code>PyventusException</code> class, allowing it to be     raised as needed.</p> </li> </ul> Source code in <code>pyventus/core/exceptions/pyventus_import_exception.py</code> <pre><code>class PyventusImportException(PyventusException):\n    \"\"\"\n    A custom Pyventus exception for handling missing imports within the package.\n\n    **Notes:**\n\n    -   This class provides a robust mechanism for handling and identifying potential\n        import exceptions within the Pyventus package.\n\n    -   This class inherits from the base `PyventusException` class, allowing it to be\n        raised as needed.\n    \"\"\"\n\n    def __init__(self, import_name: str, *, is_optional: bool = False, is_dependency: bool = False) -&gt; None:\n        \"\"\"\n        Initialize an instance of `PyventusImportException`.\n\n        :param import_name: The name of the missing import.\n        :param is_optional: A flag indicating whether the missing import is optional\n            or required for the package to work. Defaults to `False` (required).\n        :param is_dependency: A flag indicating whether the missing import is an\n            external dependency or not. Defaults to `False` (local import).\n        \"\"\"\n        # Store the import name and properties.\n        self.import_name: str = import_name\n        self.is_optional: bool = is_optional\n        self.is_dependency: bool = is_dependency\n\n        # Initialize the base PyventusException class with the error message.\n        super().__init__(\n            f\"Missing {'optional ' if is_optional else ''}{'dependency' if is_dependency else 'import'}: {import_name}\",\n        )\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException-attributes","title":"Attributes","text":""},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException.errors","title":"errors  <code>instance-attribute</code>","text":"<pre><code>errors: str | list[str] = errors if errors else __name__\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException.import_name","title":"import_name  <code>instance-attribute</code>","text":"<pre><code>import_name: str = import_name\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException.is_optional","title":"is_optional  <code>instance-attribute</code>","text":"<pre><code>is_optional: bool = is_optional\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException.is_dependency","title":"is_dependency  <code>instance-attribute</code>","text":"<pre><code>is_dependency: bool = is_dependency\n</code></pre>"},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException-functions","title":"Functions","text":""},{"location":"api/core/exceptions/pyventus_import_exception/#pyventus.core.exceptions.PyventusImportException.__init__","title":"__init__","text":"<pre><code>__init__(import_name: str, *, is_optional: bool = False, is_dependency: bool = False) -&gt; None\n</code></pre> <p>Initialize an instance of <code>PyventusImportException</code>.</p> PARAMETER DESCRIPTION <code>import_name</code> <p>The name of the missing import.</p> <p> TYPE: <code>str</code> </p> <code>is_optional</code> <p>A flag indicating whether the missing import is optional or required for the package to work. Defaults to <code>False</code> (required).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>is_dependency</code> <p>A flag indicating whether the missing import is an external dependency or not. Defaults to <code>False</code> (local import).</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> Source code in <code>pyventus/core/exceptions/pyventus_import_exception.py</code> <pre><code>def __init__(self, import_name: str, *, is_optional: bool = False, is_dependency: bool = False) -&gt; None:\n    \"\"\"\n    Initialize an instance of `PyventusImportException`.\n\n    :param import_name: The name of the missing import.\n    :param is_optional: A flag indicating whether the missing import is optional\n        or required for the package to work. Defaults to `False` (required).\n    :param is_dependency: A flag indicating whether the missing import is an\n        external dependency or not. Defaults to `False` (local import).\n    \"\"\"\n    # Store the import name and properties.\n    self.import_name: str = import_name\n    self.is_optional: bool = is_optional\n    self.is_dependency: bool = is_dependency\n\n    # Initialize the base PyventusException class with the error message.\n    super().__init__(\n        f\"Missing {'optional ' if is_optional else ''}{'dependency' if is_dependency else 'import'}: {import_name}\",\n    )\n</code></pre>"},{"location":"api/core/processing/","title":"<code>ProcessingService</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>A base class that defines a common interface for processing calls.</p> <p>Notes:</p> <ul> <li>The main goal of this class is to decouple the process of executing calls from     the underlying implementation, thereby establishing a template for defining a     variety of strategies to manage the execution.</li> </ul> Source code in <code>pyventus/core/processing/processing_service.py</code> <pre><code>class ProcessingService(ABC):\n    \"\"\"\n    A base class that defines a common interface for processing calls.\n\n    **Notes:**\n\n    -   The main goal of this class is to decouple the process of executing calls from\n        the underlying implementation, thereby establishing a template for defining a\n        variety of strategies to manage the execution.\n    \"\"\"\n\n    # Allow subclasses to define __slots__\n    __slots__ = ()\n\n    @abstractmethod\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Submit a callback along with its arguments for execution.\n\n        Subclasses must implement this method to define the specific execution strategy.\n\n        :param callback: The callback to be executed.\n        :param args: Positional arguments to be passed to the callback.\n        :param kwargs: Keyword arguments to be passed to the callback.\n        :return: None.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/processing/#pyventus.core.processing.ProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/#pyventus.core.processing.ProcessingService.submit","title":"submit  <code>abstractmethod</code>","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Submit a callback along with its arguments for execution.</p> <p>Subclasses must implement this method to define the specific execution strategy.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed.</p> <p> TYPE: <code>ProcessingServiceCallbackType</code> </p> <code>args</code> <p>Positional arguments to be passed to the callback.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Keyword arguments to be passed to the callback.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/processing_service.py</code> <pre><code>@abstractmethod\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Submit a callback along with its arguments for execution.\n\n    Subclasses must implement this method to define the specific execution strategy.\n\n    :param callback: The callback to be executed.\n    :param args: Positional arguments to be passed to the callback.\n    :param kwargs: Keyword arguments to be passed to the callback.\n    :return: None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/core/processing/asyncio_processing_service/","title":"<code>AsyncIOProcessingService</code> class","text":"<p>               Bases: <code>ProcessingService</code></p> <p>A processing service that utilizes the <code>AsyncIO</code> framework to handle the execution of calls.</p> <p>Notes:</p> <ul> <li> <p>When the provided callback is a synchronous call, it will be executed in a blocking manner, regardless     of whether an event loop is active. However, if the synchronous callback involves I/O or non-CPU-bound     operations, it can be offloaded to a thread pool using <code>asyncio.to_thread()</code> from the <code>AsyncIO</code> framework.</p> </li> <li> <p>When the provided callback is an asynchronous call and is submitted in a context where an event loop is     already running, the callback is scheduled and processed on that existing loop. If the event loop exits     before all calls are completed, any remaining scheduled calls will be canceled.</p> </li> <li> <p>When the provided callback is an asynchronous call and is submitted in a context where no event loop is     active, a new event loop is started and subsequently closed by the <code>asyncio.run()</code> method. Within this     loop, the callback is executed, and the loop waits for all scheduled tasks to finish before closing.</p> </li> </ul> Source code in <code>pyventus/core/processing/asyncio/asyncio_processing_service.py</code> <pre><code>class AsyncIOProcessingService(ProcessingService):\n    \"\"\"\n    A processing service that utilizes the `AsyncIO` framework to handle the execution of calls.\n\n    **Notes:**\n\n    -   When the provided callback is a synchronous call, it will be executed in a blocking manner, regardless\n        of whether an event loop is active. However, if the synchronous callback involves I/O or non-CPU-bound\n        operations, it can be offloaded to a thread pool using `asyncio.to_thread()` from the `AsyncIO` framework.\n\n    -   When the provided callback is an asynchronous call and is submitted in a context where an event loop is\n        already running, the callback is scheduled and processed on that existing loop. If the event loop exits\n        before all calls are completed, any remaining scheduled calls will be canceled.\n\n    -   When the provided callback is an asynchronous call and is submitted in a context where no event loop is\n        active, a new event loop is started and subsequently closed by the `asyncio.run()` method. Within this\n        loop, the callback is executed, and the loop waits for all scheduled tasks to finish before closing.\n    \"\"\"\n\n    @staticmethod\n    def is_loop_running() -&gt; bool:\n        \"\"\"\n        Determine whether there is currently an active `AsyncIO` event loop.\n\n        :return: `True` if an event loop is running; `False` otherwise.\n        \"\"\"\n        try:\n            get_running_loop()\n            return True\n        except RuntimeError:\n            return False\n\n    # Attributes for the AsyncIOProcessingService\n    __slots__ = (\"__background_tasks\",)\n\n    def __init__(self) -&gt; None:\n        \"\"\"\n        Initialize an instance of `AsyncIOProcessingService`.\n\n        :return: None.\n        \"\"\"\n        # Initialize the set of background tasks\n        self.__background_tasks: set[Task[Any]] = set()\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                background_tasks=self.__background_tasks,\n            ),\n        )\n\n    @override\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        # Check if the callback is asynchronous and execute accordingly.\n        if is_callable_async(callback):\n            # Check if there is an active event loop.\n            loop_running: bool = AsyncIOProcessingService.is_loop_running()\n\n            if loop_running:\n                # Schedule the callback in the running loop as a background task.\n                task: Task[Any] = create_task(callback(*args, **kwargs))\n\n                # Add a callback to remove the Task from the set of background tasks upon completion.\n                task.add_done_callback(self.__background_tasks.discard)\n\n                # Add the Task to the set of background tasks.\n                self.__background_tasks.add(task)\n            else:\n                # Execute the callback in a blocking manner if no event loop is active.\n                run(callback(*args, **kwargs))\n        else:\n            # Execute the callback directly if it is not an asynchronous call.\n            callback(*args, **kwargs)\n\n    async def wait_for_tasks(self) -&gt; None:\n        \"\"\"\n        Wait for all background tasks associated with the current service to complete.\n\n        This method ensures that any ongoing tasks are finished before proceeding.\n\n        :return: None.\n        \"\"\"\n        # Retrieve the current set of background tasks and clear the registry.\n        tasks: set[Task[Any]] = self.__background_tasks.copy()\n        self.__background_tasks.clear()\n\n        # Await the completion of all background tasks.\n        await gather(*tasks)\n</code></pre>"},{"location":"api/core/processing/asyncio_processing_service/#pyventus.core.processing.asyncio.AsyncIOProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/asyncio_processing_service/#pyventus.core.processing.asyncio.AsyncIOProcessingService.is_loop_running","title":"is_loop_running  <code>staticmethod</code>","text":"<pre><code>is_loop_running() -&gt; bool\n</code></pre> <p>Determine whether there is currently an active <code>AsyncIO</code> event loop.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if an event loop is running; <code>False</code> otherwise.</p> Source code in <code>pyventus/core/processing/asyncio/asyncio_processing_service.py</code> <pre><code>@staticmethod\ndef is_loop_running() -&gt; bool:\n    \"\"\"\n    Determine whether there is currently an active `AsyncIO` event loop.\n\n    :return: `True` if an event loop is running; `False` otherwise.\n    \"\"\"\n    try:\n        get_running_loop()\n        return True\n    except RuntimeError:\n        return False\n</code></pre>"},{"location":"api/core/processing/asyncio_processing_service/#pyventus.core.processing.asyncio.AsyncIOProcessingService.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an instance of <code>AsyncIOProcessingService</code>.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/asyncio/asyncio_processing_service.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize an instance of `AsyncIOProcessingService`.\n\n    :return: None.\n    \"\"\"\n    # Initialize the set of background tasks\n    self.__background_tasks: set[Task[Any]] = set()\n</code></pre>"},{"location":"api/core/processing/asyncio_processing_service/#pyventus.core.processing.asyncio.AsyncIOProcessingService.submit","title":"submit","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>pyventus/core/processing/asyncio/asyncio_processing_service.py</code> <pre><code>@override\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    # Check if the callback is asynchronous and execute accordingly.\n    if is_callable_async(callback):\n        # Check if there is an active event loop.\n        loop_running: bool = AsyncIOProcessingService.is_loop_running()\n\n        if loop_running:\n            # Schedule the callback in the running loop as a background task.\n            task: Task[Any] = create_task(callback(*args, **kwargs))\n\n            # Add a callback to remove the Task from the set of background tasks upon completion.\n            task.add_done_callback(self.__background_tasks.discard)\n\n            # Add the Task to the set of background tasks.\n            self.__background_tasks.add(task)\n        else:\n            # Execute the callback in a blocking manner if no event loop is active.\n            run(callback(*args, **kwargs))\n    else:\n        # Execute the callback directly if it is not an asynchronous call.\n        callback(*args, **kwargs)\n</code></pre>"},{"location":"api/core/processing/asyncio_processing_service/#pyventus.core.processing.asyncio.AsyncIOProcessingService.wait_for_tasks","title":"wait_for_tasks  <code>async</code>","text":"<pre><code>wait_for_tasks() -&gt; None\n</code></pre> <p>Wait for all background tasks associated with the current service to complete.</p> <p>This method ensures that any ongoing tasks are finished before proceeding.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/asyncio/asyncio_processing_service.py</code> <pre><code>async def wait_for_tasks(self) -&gt; None:\n    \"\"\"\n    Wait for all background tasks associated with the current service to complete.\n\n    This method ensures that any ongoing tasks are finished before proceeding.\n\n    :return: None.\n    \"\"\"\n    # Retrieve the current set of background tasks and clear the registry.\n    tasks: set[Task[Any]] = self.__background_tasks.copy()\n    self.__background_tasks.clear()\n\n    # Await the completion of all background tasks.\n    await gather(*tasks)\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/","title":"<code>CeleryProcessingService</code> class","text":"<p>               Bases: <code>ProcessingService</code></p> <p>A processing service that utilizes the <code>Celery</code> framework to handle the execution of calls.</p> <p>Notes:</p> <ul> <li> <p>This service leverages the <code>Celery</code> framework to enqueue the provided callbacks into a distributed     task system, which is monitored by multiple workers. Once enqueued, these callbacks are eligible     for retrieval and processing by available workers, enabling a scalable and distributed approach     to handling calls asynchronously.</p> </li> <li> <p>Synchronous callbacks are executed in a blocking manner inside the worker, while asynchronous     callbacks are processed within a new asyncio event loop using the <code>asyncio.run()</code> function.</p> </li> </ul> Source code in <code>pyventus/core/processing/celery/celery_processing_service.py</code> <pre><code>class CeleryProcessingService(ProcessingService):\n    \"\"\"\n    A processing service that utilizes the `Celery` framework to handle the execution of calls.\n\n    **Notes:**\n\n    -   This service leverages the `Celery` framework to enqueue the provided callbacks into a distributed\n        task system, which is monitored by multiple workers. Once enqueued, these callbacks are eligible\n        for retrieval and processing by available workers, enabling a scalable and distributed approach\n        to handling calls asynchronously.\n\n    -   Synchronous callbacks are executed in a blocking manner inside the worker, while asynchronous\n        callbacks are processed within a new asyncio event loop using the `asyncio.run()` function.\n    \"\"\"\n\n    CELERY_TASK_NAME: Final[str] = \"pyventus_task\"\n    \"\"\"The name of the task in Celery.\"\"\"\n\n    @dataclass(slots=True, frozen=True)\n    class CeleryPayload:\n        \"\"\"A data class representing the payload of the `CeleryProcessingService`.\"\"\"\n\n        callback: ProcessingServiceCallbackType\n        args: tuple[Any, ...]\n        kwargs: dict[str, Any]\n\n    @classmethod\n    def register(cls) -&gt; None:\n        \"\"\"\n        Register the service's task globally in `Celery`.\n\n        **Notes:**\n\n        -   This method should be invoked in the `Celery` worker script to ensure that the task is\n            accessible to both the client and the worker. If this method is not called, a `KeyError`\n            will be raised when attempting to submit a new callback.\n\n        -   This method uses the `shared_task` functionality from the `Celery` framework to register\n            the service's task, making it available independently of the `Celery` instance used.\n\n        -   The registered task is a `Celery` task that will be used to process the execution\n            of callbacks.\n\n        :return: None.\n        \"\"\"\n\n        def task(serialized_payload: bytes) -&gt; None:\n            \"\"\"\n            Celery task that processes the callbacks' execution with the given arguments.\n\n            :param serialized_payload: The serialized data representing the callback and its arguments.\n            :return: None.\n            :raises PyventusException: If the serialized payload is invalid or cannot be deserialized.\n            \"\"\"\n            # Validate that the serialized payload is provided.\n            if not serialized_payload:  # pragma: no cover\n                raise PyventusException(\"The 'serialized_payload' argument is required but was not received.\")\n\n            # Deserialize the payload to retrieve the original callback and its arguments.\n            payload = cast(CeleryProcessingService.CeleryPayload, loads(serialized_payload))\n\n            # Validate the deserialized payload to ensure it is of the expected type.\n            if payload is None or not isinstance(payload, CeleryProcessingService.CeleryPayload):  # pragma: no cover\n                raise PyventusException(\"Failed to deserialize the given payload.\")\n\n            # Check if the callback is asynchronous and execute accordingly.\n            if is_callable_async(payload.callback):\n                # Run the async callback in a new asyncio event loop.\n                run(payload.callback(*payload.args, **payload.kwargs))\n            else:\n                # Run the sync callback directly with the provided arguments.\n                payload.callback(*payload.args, **payload.kwargs)\n\n        # Register the service's task as a shared task in Celery.\n        shared_task(name=cls.CELERY_TASK_NAME)(task)\n\n    # Attributes for the CeleryProcessingService\n    __slots__ = (\"__celery\", \"__queue\")\n\n    def __init__(self, celery: Celery, queue: str | None = None) -&gt; None:\n        \"\"\"\n        Initialize an instance of `CeleryProcessingService`.\n\n        :param celery: The Celery object used to enqueue and process callbacks.\n        :param queue: The name of the queue where callbacks will be enqueued. Defaults to\n            None, which uses the `task_default_queue` from the Celery configuration.\n        :raises PyventusException: If the Celery instance is invalid or if the\n            queue name is set but empty.\n        \"\"\"\n        # Validate the Celery instance.\n        if celery is None or not isinstance(celery, Celery):\n            raise PyventusException(\"The 'celery' argument must be an instance of the Celery class.\")\n\n        # Check if the Celery app configuration uses the 'auth' serializer.\n        if celery.conf.task_serializer != \"auth\":\n            StdOutLogger.warning(\n                source=summarized_repr(self),\n                action=\"Security Message:\",\n                msg=(\n                    \"To enhance security in message communication, it is recommended to employ the Celery 'auth' \"\n                    \"serializer. While this service is serializer-agnostic, it relies on the pickling process to \"\n                    \"convert callbacks and their arguments into transmittable data, making security a critical \"\n                    \"consideration. Please refer to: https://docs.celeryq.dev/en/stable/userguide/security.html\"\n                ),\n            )\n\n        # Validate the queue name, if provided.\n        if queue is not None and len(queue) == 0:\n            raise PyventusException(\"The 'queue' argument cannot be empty.\")\n\n        # Assign the Celery instance and queue name.\n        self.__celery: Celery = celery\n        self.__queue: str = queue if queue else self.__celery.conf.task_default_queue\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                celery=self.__celery,\n                queue=self.__queue,\n            ),\n        )\n\n    @override\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        # Create the Celery payload to encapsulate the callback and its arguments.\n        payload = CeleryProcessingService.CeleryPayload(callback=callback, args=args, kwargs=kwargs)\n\n        # Serialize the payload object.\n        serialized_payload: bytes = dumps(payload)\n\n        # Send the serialized payload to Celery for asynchronous execution.\n        self.__celery.send_task(\n            name=self.__class__.CELERY_TASK_NAME,\n            args=(serialized_payload,),\n            queue=self.__queue,\n        )\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService-attributes","title":"Attributes","text":""},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CELERY_TASK_NAME","title":"CELERY_TASK_NAME  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CELERY_TASK_NAME: Final[str] = 'pyventus_task'\n</code></pre> <p>The name of the task in Celery.</p>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService-classes","title":"Classes","text":""},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload","title":"CeleryPayload  <code>dataclass</code>","text":"<p>A data class representing the payload of the <code>CeleryProcessingService</code>.</p> Source code in <code>pyventus/core/processing/celery/celery_processing_service.py</code> <pre><code>@dataclass(slots=True, frozen=True)\nclass CeleryPayload:\n    \"\"\"A data class representing the payload of the `CeleryProcessingService`.\"\"\"\n\n    callback: ProcessingServiceCallbackType\n    args: tuple[Any, ...]\n    kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload-attributes","title":"Attributes","text":""},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload.callback","title":"callback  <code>instance-attribute</code>","text":"<pre><code>callback: ProcessingServiceCallbackType\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload.args","title":"args  <code>instance-attribute</code>","text":"<pre><code>args: tuple[Any, ...]\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload.kwargs","title":"kwargs  <code>instance-attribute</code>","text":"<pre><code>kwargs: dict[str, Any]\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload-functions","title":"Functions","text":""},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.CeleryPayload.__init__","title":"__init__","text":"<pre><code>__init__(callback: ProcessingServiceCallbackType, args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; None\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.register","title":"register  <code>classmethod</code>","text":"<pre><code>register() -&gt; None\n</code></pre> <p>Register the service's task globally in <code>Celery</code>.</p> <p>Notes:</p> <ul> <li> <p>This method should be invoked in the <code>Celery</code> worker script to ensure that the task is     accessible to both the client and the worker. If this method is not called, a <code>KeyError</code>     will be raised when attempting to submit a new callback.</p> </li> <li> <p>This method uses the <code>shared_task</code> functionality from the <code>Celery</code> framework to register     the service's task, making it available independently of the <code>Celery</code> instance used.</p> </li> <li> <p>The registered task is a <code>Celery</code> task that will be used to process the execution     of callbacks.</p> </li> </ul> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/celery/celery_processing_service.py</code> <pre><code>@classmethod\ndef register(cls) -&gt; None:\n    \"\"\"\n    Register the service's task globally in `Celery`.\n\n    **Notes:**\n\n    -   This method should be invoked in the `Celery` worker script to ensure that the task is\n        accessible to both the client and the worker. If this method is not called, a `KeyError`\n        will be raised when attempting to submit a new callback.\n\n    -   This method uses the `shared_task` functionality from the `Celery` framework to register\n        the service's task, making it available independently of the `Celery` instance used.\n\n    -   The registered task is a `Celery` task that will be used to process the execution\n        of callbacks.\n\n    :return: None.\n    \"\"\"\n\n    def task(serialized_payload: bytes) -&gt; None:\n        \"\"\"\n        Celery task that processes the callbacks' execution with the given arguments.\n\n        :param serialized_payload: The serialized data representing the callback and its arguments.\n        :return: None.\n        :raises PyventusException: If the serialized payload is invalid or cannot be deserialized.\n        \"\"\"\n        # Validate that the serialized payload is provided.\n        if not serialized_payload:  # pragma: no cover\n            raise PyventusException(\"The 'serialized_payload' argument is required but was not received.\")\n\n        # Deserialize the payload to retrieve the original callback and its arguments.\n        payload = cast(CeleryProcessingService.CeleryPayload, loads(serialized_payload))\n\n        # Validate the deserialized payload to ensure it is of the expected type.\n        if payload is None or not isinstance(payload, CeleryProcessingService.CeleryPayload):  # pragma: no cover\n            raise PyventusException(\"Failed to deserialize the given payload.\")\n\n        # Check if the callback is asynchronous and execute accordingly.\n        if is_callable_async(payload.callback):\n            # Run the async callback in a new asyncio event loop.\n            run(payload.callback(*payload.args, **payload.kwargs))\n        else:\n            # Run the sync callback directly with the provided arguments.\n            payload.callback(*payload.args, **payload.kwargs)\n\n    # Register the service's task as a shared task in Celery.\n    shared_task(name=cls.CELERY_TASK_NAME)(task)\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.__init__","title":"__init__","text":"<pre><code>__init__(celery: Celery, queue: str | None = None) -&gt; None\n</code></pre> <p>Initialize an instance of <code>CeleryProcessingService</code>.</p> PARAMETER DESCRIPTION <code>celery</code> <p>The Celery object used to enqueue and process callbacks.</p> <p> TYPE: <code>Celery</code> </p> <code>queue</code> <p>The name of the queue where callbacks will be enqueued. Defaults to None, which uses the <code>task_default_queue</code> from the Celery configuration.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the Celery instance is invalid or if the queue name is set but empty.</p> Source code in <code>pyventus/core/processing/celery/celery_processing_service.py</code> <pre><code>def __init__(self, celery: Celery, queue: str | None = None) -&gt; None:\n    \"\"\"\n    Initialize an instance of `CeleryProcessingService`.\n\n    :param celery: The Celery object used to enqueue and process callbacks.\n    :param queue: The name of the queue where callbacks will be enqueued. Defaults to\n        None, which uses the `task_default_queue` from the Celery configuration.\n    :raises PyventusException: If the Celery instance is invalid or if the\n        queue name is set but empty.\n    \"\"\"\n    # Validate the Celery instance.\n    if celery is None or not isinstance(celery, Celery):\n        raise PyventusException(\"The 'celery' argument must be an instance of the Celery class.\")\n\n    # Check if the Celery app configuration uses the 'auth' serializer.\n    if celery.conf.task_serializer != \"auth\":\n        StdOutLogger.warning(\n            source=summarized_repr(self),\n            action=\"Security Message:\",\n            msg=(\n                \"To enhance security in message communication, it is recommended to employ the Celery 'auth' \"\n                \"serializer. While this service is serializer-agnostic, it relies on the pickling process to \"\n                \"convert callbacks and their arguments into transmittable data, making security a critical \"\n                \"consideration. Please refer to: https://docs.celeryq.dev/en/stable/userguide/security.html\"\n            ),\n        )\n\n    # Validate the queue name, if provided.\n    if queue is not None and len(queue) == 0:\n        raise PyventusException(\"The 'queue' argument cannot be empty.\")\n\n    # Assign the Celery instance and queue name.\n    self.__celery: Celery = celery\n    self.__queue: str = queue if queue else self.__celery.conf.task_default_queue\n</code></pre>"},{"location":"api/core/processing/celery_processing_service/#pyventus.core.processing.celery.CeleryProcessingService.submit","title":"submit","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>pyventus/core/processing/celery/celery_processing_service.py</code> <pre><code>@override\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    # Create the Celery payload to encapsulate the callback and its arguments.\n    payload = CeleryProcessingService.CeleryPayload(callback=callback, args=args, kwargs=kwargs)\n\n    # Serialize the payload object.\n    serialized_payload: bytes = dumps(payload)\n\n    # Send the serialized payload to Celery for asynchronous execution.\n    self.__celery.send_task(\n        name=self.__class__.CELERY_TASK_NAME,\n        args=(serialized_payload,),\n        queue=self.__queue,\n    )\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/","title":"<code>ExecutorProcessingService</code> class","text":"<p>               Bases: <code>ProcessingService</code></p> <p>A processing service that utilizes the <code>concurrent.futures.Executor</code> to handle the execution of calls.</p> <p>Notes:</p> <ul> <li> <p>This service uses the <code>concurrent.futures.Executor</code> for processing the callbacks' execution. It     can work with either a <code>ThreadPoolExecutor</code> for thread-based execution or a <code>ProcessPoolExecutor</code>     for process-based execution.</p> </li> <li> <p>Synchronous callbacks are executed in a blocking manner inside the executor, while asynchronous     callbacks are processed within a new asyncio event loop using the <code>asyncio.run()</code> function.</p> </li> <li> <p>When using this service, it is important to properly manage the underlying <code>Executor</code>. Once     there are no more calls to be processed through the given executor, it's important to invoke     the <code>shutdown()</code> method to signal the executor to free any resources for pending futures. You     can avoid the need to call this method explicitly by using the <code>with</code> statement, which     automatically shuts down the <code>Executor</code>.</p> </li> </ul> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>class ExecutorProcessingService(ProcessingService):\n    \"\"\"\n    A processing service that utilizes the `concurrent.futures.Executor` to handle the execution of calls.\n\n    **Notes:**\n\n    -   This service uses the `concurrent.futures.Executor` for processing the callbacks' execution. It\n        can work with either a `ThreadPoolExecutor` for thread-based execution or a `ProcessPoolExecutor`\n        for process-based execution.\n\n    -   Synchronous callbacks are executed in a blocking manner inside the executor, while asynchronous\n        callbacks are processed within a new asyncio event loop using the `asyncio.run()` function.\n\n    -   When using this service, it is important to properly manage the underlying `Executor`. Once\n        there are no more calls to be processed through the given executor, it's important to invoke\n        the `shutdown()` method to signal the executor to free any resources for pending futures. You\n        can avoid the need to call this method explicitly by using the `with` statement, which\n        automatically shuts down the `Executor`.\n    \"\"\"\n\n    @staticmethod\n    def _execute(callback: ProcessingServiceCallbackType, args: tuple[Any, ...], kwargs: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Execute the provided callback with the given arguments.\n\n        This method is intended to be used within the executor to execute the callback.\n\n        :param callback: The callback to be executed.\n        :param args: Positional arguments to be passed to the callback.\n        :param kwargs: Keyword arguments to be passed to the callback.\n        :return: None.\n        \"\"\"\n        # Check if the callback is asynchronous and execute accordingly.\n        if is_callable_async(callback):\n            # Run the async callback in a new asyncio event loop.\n            run(callback(*args, **kwargs))\n        else:\n            # Run the sync callback directly with the provided arguments.\n            callback(*args, **kwargs)\n\n    # Attributes for the ExecutorProcessingService.\n    __slots__ = (\"__executor\",)\n\n    def __init__(self, executor: Executor) -&gt; None:\n        \"\"\"\n        Initialize an instance of `ExecutorProcessingService`.\n\n        :param executor: The executor object used to handle the callbacks' execution.\n        :return: None.\n        :raises PyventusException: If the executor is not provided or is not an instance of `Executor`.\n        \"\"\"\n        # Validate the executor instance.\n        if executor is None or not isinstance(executor, Executor):\n            raise PyventusException(\"The 'executor' argument must be an instance of Executor.\")\n\n        # Store the executor instance.\n        self.__executor: Executor = executor\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                executor=self.__executor,\n            ),\n        )\n\n    @override\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        # Submit the callback to the executor along with its arguments.\n        self.__executor.submit(self.__class__._execute, callback, args, kwargs)\n\n    def shutdown(self, wait: bool = True, cancel_futures: bool = False) -&gt; None:\n        \"\"\"\n        Shut down the executor and release any resources it is using.\n\n        :param wait: A boolean indicating whether to wait for the currently pending futures\n            to complete before shutting down.\n        :param cancel_futures: A boolean indicating whether to cancel any pending futures.\n        :return: None.\n        \"\"\"\n        self.__executor.shutdown(wait=wait, cancel_futures=cancel_futures)\n\n    def __enter__(self) -&gt; Self:\n        \"\"\"\n        Return the current instance of `ExecutorProcessingService` for context management.\n\n        :return: The current instance of `ExecutorProcessingService`.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -&gt; None:\n        \"\"\"\n        Clean up the executor resources when exiting the context.\n\n        :param exc_type: The exception type, if any.\n        :param exc_val: The exception value, if any.\n        :param exc_tb: The traceback information, if any.\n        :return: None.\n        \"\"\"\n        self.shutdown(wait=True, cancel_futures=False)\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService.__init__","title":"__init__","text":"<pre><code>__init__(executor: Executor) -&gt; None\n</code></pre> <p>Initialize an instance of <code>ExecutorProcessingService</code>.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor object used to handle the callbacks' execution.</p> <p> TYPE: <code>Executor</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the executor is not provided or is not an instance of <code>Executor</code>.</p> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>def __init__(self, executor: Executor) -&gt; None:\n    \"\"\"\n    Initialize an instance of `ExecutorProcessingService`.\n\n    :param executor: The executor object used to handle the callbacks' execution.\n    :return: None.\n    :raises PyventusException: If the executor is not provided or is not an instance of `Executor`.\n    \"\"\"\n    # Validate the executor instance.\n    if executor is None or not isinstance(executor, Executor):\n        raise PyventusException(\"The 'executor' argument must be an instance of Executor.\")\n\n    # Store the executor instance.\n    self.__executor: Executor = executor\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService.submit","title":"submit","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>@override\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    # Submit the callback to the executor along with its arguments.\n    self.__executor.submit(self.__class__._execute, callback, args, kwargs)\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService.shutdown","title":"shutdown","text":"<pre><code>shutdown(wait: bool = True, cancel_futures: bool = False) -&gt; None\n</code></pre> <p>Shut down the executor and release any resources it is using.</p> PARAMETER DESCRIPTION <code>wait</code> <p>A boolean indicating whether to wait for the currently pending futures to complete before shutting down.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>cancel_futures</code> <p>A boolean indicating whether to cancel any pending futures.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>def shutdown(self, wait: bool = True, cancel_futures: bool = False) -&gt; None:\n    \"\"\"\n    Shut down the executor and release any resources it is using.\n\n    :param wait: A boolean indicating whether to wait for the currently pending futures\n        to complete before shutting down.\n    :param cancel_futures: A boolean indicating whether to cancel any pending futures.\n    :return: None.\n    \"\"\"\n    self.__executor.shutdown(wait=wait, cancel_futures=cancel_futures)\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Return the current instance of <code>ExecutorProcessingService</code> for context management.</p> RETURNS DESCRIPTION <code>Self</code> <p>The current instance of <code>ExecutorProcessingService</code>.</p> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"\n    Return the current instance of `ExecutorProcessingService` for context management.\n\n    :return: The current instance of `ExecutorProcessingService`.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/core/processing/executor_processing_service/#pyventus.core.processing.executor.ExecutorProcessingService.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None\n</code></pre> <p>Clean up the executor resources when exiting the context.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The exception type, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The exception value, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback information, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/executor/executor_processing_service.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Clean up the executor resources when exiting the context.\n\n    :param exc_type: The exception type, if any.\n    :param exc_val: The exception value, if any.\n    :param exc_tb: The traceback information, if any.\n    :return: None.\n    \"\"\"\n    self.shutdown(wait=True, cancel_futures=False)\n</code></pre>"},{"location":"api/core/processing/fastapi_processing_service/","title":"<code>FastAPIProcessingService</code> class","text":"<p>               Bases: <code>ProcessingService</code></p> <p>A processing service that utilizes the FastAPI's <code>BackgroundTasks</code> to handle the execution of calls.</p> <p>Notes:</p> <ul> <li>This service is specifically designed for FastAPI applications and leverages FastAPI's <code>BackgroundTasks</code>     to handle the callbacks' execution. This is useful for operations that need to happen after a request, but     that the client doesn't really have to be waiting for the operation to complete before receiving the response.</li> </ul> Source code in <code>pyventus/core/processing/fastapi/fastapi_processing_service.py</code> <pre><code>class FastAPIProcessingService(ProcessingService):\n    \"\"\"\n    A processing service that utilizes the FastAPI's `BackgroundTasks` to handle the execution of calls.\n\n    **Notes:**\n\n    -   This service is specifically designed for FastAPI applications and leverages FastAPI's `BackgroundTasks`\n        to handle the callbacks' execution. This is useful for operations that need to happen after a request, but\n        that the client doesn't really have to be waiting for the operation to complete before receiving the response.\n    \"\"\"\n\n    # Attributes for the FastAPIProcessingService\n    __slots__ = (\"__background_tasks\",)\n\n    def __init__(self, background_tasks: BackgroundTasks) -&gt; None:\n        \"\"\"\n        Initialize an instance of `FastAPIProcessingService`.\n\n        :param background_tasks: The FastAPI `BackgroundTasks` object used to handle callbacks' execution.\n        :return: None.\n        \"\"\"\n        # Validate the background_tasks instance.\n        if background_tasks is None or not isinstance(background_tasks, BackgroundTasks):\n            raise PyventusException(\"The 'background_tasks' argument must be an instance of the BackgroundTasks.\")\n\n        # Store the BackgroundTasks instance.\n        self.__background_tasks: BackgroundTasks = background_tasks\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                background_tasks=self.__background_tasks,\n            ),\n        )\n\n    @override\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        # Add the callback to the background_tasks instance as a new task to be executed.\n        self.__background_tasks.add_task(callback, *args, **kwargs)\n</code></pre>"},{"location":"api/core/processing/fastapi_processing_service/#pyventus.core.processing.fastapi.FastAPIProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/fastapi_processing_service/#pyventus.core.processing.fastapi.FastAPIProcessingService.__init__","title":"__init__","text":"<pre><code>__init__(background_tasks: BackgroundTasks) -&gt; None\n</code></pre> <p>Initialize an instance of <code>FastAPIProcessingService</code>.</p> PARAMETER DESCRIPTION <code>background_tasks</code> <p>The FastAPI <code>BackgroundTasks</code> object used to handle callbacks' execution.</p> <p> TYPE: <code>BackgroundTasks</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/processing/fastapi/fastapi_processing_service.py</code> <pre><code>def __init__(self, background_tasks: BackgroundTasks) -&gt; None:\n    \"\"\"\n    Initialize an instance of `FastAPIProcessingService`.\n\n    :param background_tasks: The FastAPI `BackgroundTasks` object used to handle callbacks' execution.\n    :return: None.\n    \"\"\"\n    # Validate the background_tasks instance.\n    if background_tasks is None or not isinstance(background_tasks, BackgroundTasks):\n        raise PyventusException(\"The 'background_tasks' argument must be an instance of the BackgroundTasks.\")\n\n    # Store the BackgroundTasks instance.\n    self.__background_tasks: BackgroundTasks = background_tasks\n</code></pre>"},{"location":"api/core/processing/fastapi_processing_service/#pyventus.core.processing.fastapi.FastAPIProcessingService.submit","title":"submit","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>pyventus/core/processing/fastapi/fastapi_processing_service.py</code> <pre><code>@override\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    # Add the callback to the background_tasks instance as a new task to be executed.\n    self.__background_tasks.add_task(callback, *args, **kwargs)\n</code></pre>"},{"location":"api/core/processing/redis_processing_service/","title":"<code>RedisProcessingService</code> class","text":"<p>               Bases: <code>ProcessingService</code></p> <p>A processing service that utilizes the <code>Redis Queue</code> framework to handle the execution of calls.</p> <p>Notes:</p> <ul> <li> <p>This service leverages the <code>RQ</code> Python package to enqueue the provided callbacks into a Redis     distributed task system, which is monitored by multiple workers. Once enqueued, these callbacks     are eligible for retrieval and processing by available workers, enabling a scalable and     distributed approach to handling calls asynchronously.</p> </li> <li> <p>Synchronous callbacks are executed in a blocking manner inside the worker, while asynchronous     callbacks are processed within a new asyncio event loop using the <code>asyncio.run()</code> function.</p> </li> </ul> Source code in <code>pyventus/core/processing/redis/redis_processing_service.py</code> <pre><code>class RedisProcessingService(ProcessingService):\n    \"\"\"\n    A processing service that utilizes the `Redis Queue` framework to handle the execution of calls.\n\n    **Notes:**\n\n    -   This service leverages the `RQ` Python package to enqueue the provided callbacks into a Redis\n        distributed task system, which is monitored by multiple workers. Once enqueued, these callbacks\n        are eligible for retrieval and processing by available workers, enabling a scalable and\n        distributed approach to handling calls asynchronously.\n\n    -   Synchronous callbacks are executed in a blocking manner inside the worker, while asynchronous\n        callbacks are processed within a new asyncio event loop using the `asyncio.run()` function.\n    \"\"\"\n\n    # Attributes for the RedisProcessingService\n    __slots__ = (\"__queue\", \"__options\")\n\n    def __init__(self, queue: Queue, options: dict[str, Any] | None = None) -&gt; None:\n        \"\"\"\n        Initialize an instance of `RedisProcessingService`.\n\n        :param queue: The Redis queue used to enqueue and process callbacks.\n        :param options: Additional options for the RQ package enqueueing method.\n            Defaults to None (an empty dictionary).\n        :return: None.\n        :raises PyventusException: If the 'queue' argument is None or not an instance\n            of the `Queue` class.\n        \"\"\"\n        # Validate the queue instance.\n        if queue is None or not isinstance(queue, Queue):\n            raise PyventusException(\"The 'queue' argument must be an instance of the Queue class.\")\n\n        # Store the Redis queue and RQ options\n        self.__queue: Queue = queue\n        self.__options: dict[str, Any] = options if options else {}\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                queue=self.__queue,\n                options=self.__options,\n            ),\n        )\n\n    @override\n    def submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n        # Send the callback and its arguments to Redis for asynchronous execution.\n        self.__queue.enqueue(callback, *args, **kwargs, **self.__options)\n</code></pre>"},{"location":"api/core/processing/redis_processing_service/#pyventus.core.processing.redis.RedisProcessingService-functions","title":"Functions","text":""},{"location":"api/core/processing/redis_processing_service/#pyventus.core.processing.redis.RedisProcessingService.__init__","title":"__init__","text":"<pre><code>__init__(queue: Queue, options: dict[str, Any] | None = None) -&gt; None\n</code></pre> <p>Initialize an instance of <code>RedisProcessingService</code>.</p> PARAMETER DESCRIPTION <code>queue</code> <p>The Redis queue used to enqueue and process callbacks.</p> <p> TYPE: <code>Queue</code> </p> <code>options</code> <p>Additional options for the RQ package enqueueing method. Defaults to None (an empty dictionary).</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the 'queue' argument is None or not an instance of the <code>Queue</code> class.</p> Source code in <code>pyventus/core/processing/redis/redis_processing_service.py</code> <pre><code>def __init__(self, queue: Queue, options: dict[str, Any] | None = None) -&gt; None:\n    \"\"\"\n    Initialize an instance of `RedisProcessingService`.\n\n    :param queue: The Redis queue used to enqueue and process callbacks.\n    :param options: Additional options for the RQ package enqueueing method.\n        Defaults to None (an empty dictionary).\n    :return: None.\n    :raises PyventusException: If the 'queue' argument is None or not an instance\n        of the `Queue` class.\n    \"\"\"\n    # Validate the queue instance.\n    if queue is None or not isinstance(queue, Queue):\n        raise PyventusException(\"The 'queue' argument must be an instance of the Queue class.\")\n\n    # Store the Redis queue and RQ options\n    self.__queue: Queue = queue\n    self.__options: dict[str, Any] = options if options else {}\n</code></pre>"},{"location":"api/core/processing/redis_processing_service/#pyventus.core.processing.redis.RedisProcessingService.submit","title":"submit","text":"<pre><code>submit(callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> Source code in <code>pyventus/core/processing/redis/redis_processing_service.py</code> <pre><code>@override\ndef submit(self, callback: ProcessingServiceCallbackType, *args: Any, **kwargs: Any) -&gt; None:\n    # Send the callback and its arguments to Redis for asynchronous execution.\n    self.__queue.enqueue(callback, *args, **kwargs, **self.__options)\n</code></pre>"},{"location":"api/core/subscriptions/subscription/","title":"<code>Subscription</code> class","text":"<p>               Bases: <code>Unsubscribable</code></p> <p>A base class that represents a subscription to a source.</p> <p>Notes:</p> <ul> <li>This class encapsulates the subscription lifecycle and provides a     mechanism for releasing or cleaning up any associated resources.</li> </ul> Source code in <code>pyventus/core/subscriptions/subscription.py</code> <pre><code>class Subscription(Unsubscribable):\n    \"\"\"\n    A base class that represents a subscription to a source.\n\n    **Notes:**\n\n    -   This class encapsulates the subscription lifecycle and provides a\n        mechanism for releasing or cleaning up any associated resources.\n    \"\"\"\n\n    # Attributes for the Subscription\n    __slots__ = (\"__timestamp\", \"__teardown_callback\")\n\n    def __init__(self, teardown_callback: Callable[[Self], bool]) -&gt; None:\n        \"\"\"\n        Initialize an instance of `Subscription`.\n\n        :param teardown_callback: A callback function invoked during the\n            unsubscription process to perform cleanup or teardown operations\n            associated with the subscription. It should return `True` if the\n            cleanup was successful, or `False` if the teardown has already been\n            executed and the subscription is no longer active.\n        \"\"\"\n        # Validate the teardown callback\n        validate_callable(teardown_callback)\n\n        # Initialize attributes\n        self.__timestamp: datetime = datetime.now()\n        self.__teardown_callback: Callable[[Self], bool] = teardown_callback\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return attributes_repr(\n            timestamp=self.__timestamp.strftime(\"%Y-%m-%d %I:%M:%S %p\"),\n            teardown_callback=get_callable_name(self.__teardown_callback),\n        )\n\n    @property\n    def timestamp(self) -&gt; datetime:\n        \"\"\"\n        Retrieve the timestamp when the subscription was created.\n\n        :return: The timestamp when the subscription was created.\n        \"\"\"\n        return self.__timestamp\n\n    @override\n    def unsubscribe(self: Self) -&gt; bool:\n        return self.__teardown_callback(self)\n\n    def __getstate__(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Prepare the object state for serialization.\n\n        This method is called when the object is pickled. It returns a dictionary\n        containing the attributes that should be serialized. Only the attributes\n        that are necessary for reconstructing the object in another process or\n        context are included to improve efficiency and avoid issues with\n        contextually irrelevant attributes.\n\n        :return: A dictionary containing the serialized state of the object.\n        \"\"\"\n        # Include only the attributes that are necessary for serialization\n        # Attributes like __teardown_callback are not included as they are\n        # context-specific and do not make sense in another scope/process.\n        return {\"__timestamp\": self.__timestamp}\n\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        \"\"\"\n        Restore the object from the serialized state.\n\n        This method is called when the object is unpickled. It takes a dictionary\n        containing the serialized state and restores the object's attributes.\n        Additionally, it sets default values for attributes that were not serialized,\n        ensuring the object remains in a valid state after deserialization.\n\n        :param state: A dictionary containing the serialized state of the object.\n        :return: None\n        \"\"\"\n        # Restore the attributes from the serialized state\n        self.__timestamp = state[\"__timestamp\"]\n\n        # Set default values for attributes that were not serialized\n        self.__teardown_callback = lambda sub: False\n</code></pre>"},{"location":"api/core/subscriptions/subscription/#pyventus.core.subscriptions.Subscription-attributes","title":"Attributes","text":""},{"location":"api/core/subscriptions/subscription/#pyventus.core.subscriptions.Subscription.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>Retrieve the timestamp when the subscription was created.</p> RETURNS DESCRIPTION <code>datetime</code> <p>The timestamp when the subscription was created.</p>"},{"location":"api/core/subscriptions/subscription/#pyventus.core.subscriptions.Subscription-functions","title":"Functions","text":""},{"location":"api/core/subscriptions/subscription/#pyventus.core.subscriptions.Subscription.__init__","title":"__init__","text":"<pre><code>__init__(teardown_callback: Callable[[Self], bool]) -&gt; None\n</code></pre> <p>Initialize an instance of <code>Subscription</code>.</p> PARAMETER DESCRIPTION <code>teardown_callback</code> <p>A callback function invoked during the unsubscription process to perform cleanup or teardown operations associated with the subscription. It should return <code>True</code> if the cleanup was successful, or <code>False</code> if the teardown has already been executed and the subscription is no longer active.</p> <p> TYPE: <code>Callable[[Self], bool]</code> </p> Source code in <code>pyventus/core/subscriptions/subscription.py</code> <pre><code>def __init__(self, teardown_callback: Callable[[Self], bool]) -&gt; None:\n    \"\"\"\n    Initialize an instance of `Subscription`.\n\n    :param teardown_callback: A callback function invoked during the\n        unsubscription process to perform cleanup or teardown operations\n        associated with the subscription. It should return `True` if the\n        cleanup was successful, or `False` if the teardown has already been\n        executed and the subscription is no longer active.\n    \"\"\"\n    # Validate the teardown callback\n    validate_callable(teardown_callback)\n\n    # Initialize attributes\n    self.__timestamp: datetime = datetime.now()\n    self.__teardown_callback: Callable[[Self], bool] = teardown_callback\n</code></pre>"},{"location":"api/core/subscriptions/subscription/#pyventus.core.subscriptions.Subscription.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe() -&gt; bool\n</code></pre> Source code in <code>pyventus/core/subscriptions/subscription.py</code> <pre><code>@override\ndef unsubscribe(self: Self) -&gt; bool:\n    return self.__teardown_callback(self)\n</code></pre>"},{"location":"api/core/subscriptions/subscription_context/","title":"<code>SubscriptionContext</code> class","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_SourceType, _SubscriberType]</code></p> <p>An abstract base class for subscription context managers.</p> <p>Notes:</p> <ul> <li> <p>This class is designed to establish a context block for a step-by-step     definition of an object that will later be subscribed to a specified source.</p> </li> <li> <p>Upon exiting the context, the defined object will be automatically subscribed.</p> </li> <li> <p>Through the <code>unpack()</code> method, this class not only returns the source object and     its subscriber but also handles the release and cleanup of associated resources.</p> </li> <li> <p>This subscription context can be <code>stateful</code>, retaining references to the <code>source</code> object     and <code>subscriber</code>, or <code>stateless</code>, which clears the context upon exiting the subscription     block.</p> </li> </ul> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>class SubscriptionContext(ABC, Generic[_SourceType, _SubscriberType]):\n    \"\"\"\n    An abstract base class for subscription context managers.\n\n    **Notes:**\n\n    -   This class is designed to establish a context block for a step-by-step\n        definition of an object that will later be subscribed to a specified source.\n\n    -   Upon exiting the context, the defined object will be automatically subscribed.\n\n    -   Through the `unpack()` method, this class not only returns the source object and\n        its subscriber but also handles the release and cleanup of associated resources.\n\n    -   This subscription context can be `stateful`, retaining references to the `source` object\n        and `subscriber`, or `stateless`, which clears the context upon exiting the subscription\n        block.\n    \"\"\"\n\n    # Attributes for the SubscriptionContext\n    __slots__ = (\"__source\", \"__subscriber\", \"__is_stateful\")\n\n    def __init__(self, source: _SourceType, is_stateful: bool) -&gt; None:\n        \"\"\"\n        Initialize an instance of `SubscriptionContext`.\n\n        :param source: The source to which the subscription is performed.\n        :param is_stateful: A flag indicating whether the context preserves its state (stateful) or\n            not (stateless) after exiting the subscription context. If `True`, the context retains its\n            state, allowing access to stored objects, including the `source` object and the `subscriber`\n            object. If `False`, the context is stateless, and the stored state is cleared upon exiting\n            the subscription context to prevent memory leaks.\n        \"\"\"\n        # Validate the source and flags\n        if source is None:  # pragma: no cover\n            raise PyventusException(\"The 'source' argument cannot be None.\")\n        if not isinstance(is_stateful, bool):  # pragma: no cover\n            raise PyventusException(\"The 'stateful_context' argument must be a boolean.\")\n\n        # Initialize instance variables\n        self.__source: _SourceType = source\n        self.__subscriber: _SubscriberType | None = None\n        self.__is_stateful: bool = is_stateful\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                source=self._source.__name__ if isinstance(self._source, type) else self._source,\n                subscriber=self._subscriber,\n            ),\n        )\n\n    @property\n    def _source(self) -&gt; _SourceType | None:\n        \"\"\"\n        Retrieve the source to which the subscription is performed.\n\n        :return: The source object, or `None` if it was not retained\n            for later access after exiting the context.\n        \"\"\"\n        return self.__source if hasattr(self, \"_SubscriptionContext__source\") else None\n\n    @property\n    def _subscriber(self) -&gt; _SubscriberType | None:\n        \"\"\"\n        Retrieve the subscriber that is returned after performing the subscription to the specified source.\n\n        :return: The subscriber object, or `None` if it was not retained for later access after exiting the context.\n        :raises PyventusException: If accessed before or during the subscription context.\n        \"\"\"\n        if not hasattr(self, \"_SubscriptionContext__subscriber\"):\n            return None\n\n        if self.__subscriber is None:\n            raise PyventusException(\"The 'subscriber' property is not accessible before or during the context block.\")\n\n        return self.__subscriber\n\n    @property\n    def _is_stateful(self) -&gt; bool:\n        \"\"\"\n        Determine whether the context preserves its state or not after exiting the subscription context.\n\n        :return: `True` if the context retains its state, allowing access to stored objects,\n            including the `source` object and the `subscriber` object; `False` if the context\n            is stateless, meaning the stored state is cleared upon exiting the subscription\n            context to prevent memory leaks.\n        \"\"\"\n        return self.__is_stateful\n\n    @abstractmethod\n    def _exit(self) -&gt; _SubscriberType:\n        \"\"\"\n        Finalize the subscription process and returns the subscriber.\n\n        This method is invoked upon exiting the context. It is responsible\n        for completing the subscription of the defined object and returning\n        the corresponding subscriber object. Additionally, it must handle\n        the release and cleanup of any associated resources specific to\n        the subclass.\n\n        :return: The subscriber object.\n        \"\"\"\n        pass\n\n    def unpack(self) -&gt; tuple[_SourceType | None, _SubscriberType | None]:\n        \"\"\"\n        Unpack and retrieve the source object and its associated subscriber.\n\n        This method returns a tuple containing the source object and its subscriber,\n        while also handling the cleanup of associated resources to prevent memory leaks.\n        After retrieving the objects, it deletes internal references to the source and\n        subscriber to ensure they are no longer retained.\n\n        :return: A tuple of the form (source, subscriber). Both may be `None` if the\n            subscription context has either unpacked the state previously or is stateless.\n        :raises PyventusException: If this method is called before or during the subscription\n            context, indicating that the resources are not yet available for unpacking.\n        \"\"\"\n        # Create a tuple with the source object and its subscriber\n        results: tuple[_SourceType | None, _SubscriberType | None] = (self._source, self._subscriber)\n\n        # Perform cleanup by deleting unnecessary references\n        if results[0]:\n            del self.__source\n        if results[1]:\n            del self.__subscriber\n\n        return results\n\n    def __enter__(self: Self) -&gt; Self:\n        \"\"\"\n        Enter the subscription context block.\n\n        This method facilitates the progressive definition of an\n        object that will later be subscribed to the specified source.\n\n        :return: The subscription context manager.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -&gt; None:\n        \"\"\"\n        Exit the subscription context block.\n\n        This method subscribes the defined object to the\n        specified source, and performs any necessary cleanup.\n\n        :param exc_type: The type of the raised exception, if any.\n        :param exc_val: The raised exception object, if any.\n        :param exc_tb: The traceback information, if any.\n        :return: None.\n        \"\"\"\n        # Finalize the subscription and retrieve the subscriber\n        subscriber: _SubscriberType = self._exit()\n\n        # Ensure the subscriber is valid\n        if subscriber is None:  # pragma: no cover\n            raise PyventusException(\"The 'subscriber' argument cannot be None.\")\n\n        # Check if a subscriber has already been set to avoid an override\n        if self.__subscriber:  # pragma: no cover\n            raise PyventusException(\"A 'subscriber' has already been set.\")\n\n        if self.__is_stateful:\n            # Retain the subscriber if the context is stateful\n            self.__subscriber = subscriber\n        else:\n            # Remove context-specific references if stateless\n            del self.__source, self.__subscriber\n\n        # Remove the stateful context flag\n        del self.__is_stateful\n</code></pre>"},{"location":"api/core/subscriptions/subscription_context/#pyventus.core.subscriptions.SubscriptionContext-functions","title":"Functions","text":""},{"location":"api/core/subscriptions/subscription_context/#pyventus.core.subscriptions.SubscriptionContext.__init__","title":"__init__","text":"<pre><code>__init__(source: _SourceType, is_stateful: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>SubscriptionContext</code>.</p> PARAMETER DESCRIPTION <code>source</code> <p>The source to which the subscription is performed.</p> <p> TYPE: <code>_SourceType</code> </p> <code>is_stateful</code> <p>A flag indicating whether the context preserves its state (stateful) or not (stateless) after exiting the subscription context. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>source</code> object and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription context to prevent memory leaks.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __init__(self, source: _SourceType, is_stateful: bool) -&gt; None:\n    \"\"\"\n    Initialize an instance of `SubscriptionContext`.\n\n    :param source: The source to which the subscription is performed.\n    :param is_stateful: A flag indicating whether the context preserves its state (stateful) or\n        not (stateless) after exiting the subscription context. If `True`, the context retains its\n        state, allowing access to stored objects, including the `source` object and the `subscriber`\n        object. If `False`, the context is stateless, and the stored state is cleared upon exiting\n        the subscription context to prevent memory leaks.\n    \"\"\"\n    # Validate the source and flags\n    if source is None:  # pragma: no cover\n        raise PyventusException(\"The 'source' argument cannot be None.\")\n    if not isinstance(is_stateful, bool):  # pragma: no cover\n        raise PyventusException(\"The 'stateful_context' argument must be a boolean.\")\n\n    # Initialize instance variables\n    self.__source: _SourceType = source\n    self.__subscriber: _SubscriberType | None = None\n    self.__is_stateful: bool = is_stateful\n</code></pre>"},{"location":"api/core/subscriptions/subscription_context/#pyventus.core.subscriptions.SubscriptionContext.unpack","title":"unpack","text":"<pre><code>unpack() -&gt; tuple[_SourceType | None, _SubscriberType | None]\n</code></pre> <p>Unpack and retrieve the source object and its associated subscriber.</p> <p>This method returns a tuple containing the source object and its subscriber, while also handling the cleanup of associated resources to prevent memory leaks. After retrieving the objects, it deletes internal references to the source and subscriber to ensure they are no longer retained.</p> RETURNS DESCRIPTION <code>tuple[_SourceType | None, _SubscriberType | None]</code> <p>A tuple of the form (source, subscriber). Both may be <code>None</code> if the subscription context has either unpacked the state previously or is stateless.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If this method is called before or during the subscription context, indicating that the resources are not yet available for unpacking.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def unpack(self) -&gt; tuple[_SourceType | None, _SubscriberType | None]:\n    \"\"\"\n    Unpack and retrieve the source object and its associated subscriber.\n\n    This method returns a tuple containing the source object and its subscriber,\n    while also handling the cleanup of associated resources to prevent memory leaks.\n    After retrieving the objects, it deletes internal references to the source and\n    subscriber to ensure they are no longer retained.\n\n    :return: A tuple of the form (source, subscriber). Both may be `None` if the\n        subscription context has either unpacked the state previously or is stateless.\n    :raises PyventusException: If this method is called before or during the subscription\n        context, indicating that the resources are not yet available for unpacking.\n    \"\"\"\n    # Create a tuple with the source object and its subscriber\n    results: tuple[_SourceType | None, _SubscriberType | None] = (self._source, self._subscriber)\n\n    # Perform cleanup by deleting unnecessary references\n    if results[0]:\n        del self.__source\n    if results[1]:\n        del self.__subscriber\n\n    return results\n</code></pre>"},{"location":"api/core/subscriptions/subscription_context/#pyventus.core.subscriptions.SubscriptionContext.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the subscription context block.</p> <p>This method facilitates the progressive definition of an object that will later be subscribed to the specified source.</p> RETURNS DESCRIPTION <code>Self</code> <p>The subscription context manager.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __enter__(self: Self) -&gt; Self:\n    \"\"\"\n    Enter the subscription context block.\n\n    This method facilitates the progressive definition of an\n    object that will later be subscribed to the specified source.\n\n    :return: The subscription context manager.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/core/subscriptions/subscription_context/#pyventus.core.subscriptions.SubscriptionContext.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None\n</code></pre> <p>Exit the subscription context block.</p> <p>This method subscribes the defined object to the specified source, and performs any necessary cleanup.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the raised exception, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The raised exception object, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback information, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Exit the subscription context block.\n\n    This method subscribes the defined object to the\n    specified source, and performs any necessary cleanup.\n\n    :param exc_type: The type of the raised exception, if any.\n    :param exc_val: The raised exception object, if any.\n    :param exc_tb: The traceback information, if any.\n    :return: None.\n    \"\"\"\n    # Finalize the subscription and retrieve the subscriber\n    subscriber: _SubscriberType = self._exit()\n\n    # Ensure the subscriber is valid\n    if subscriber is None:  # pragma: no cover\n        raise PyventusException(\"The 'subscriber' argument cannot be None.\")\n\n    # Check if a subscriber has already been set to avoid an override\n    if self.__subscriber:  # pragma: no cover\n        raise PyventusException(\"A 'subscriber' has already been set.\")\n\n    if self.__is_stateful:\n        # Retain the subscriber if the context is stateful\n        self.__subscriber = subscriber\n    else:\n        # Remove context-specific references if stateless\n        del self.__source, self.__subscriber\n\n    # Remove the stateful context flag\n    del self.__is_stateful\n</code></pre>"},{"location":"api/core/subscriptions/unsubscribable/","title":"<code>Unsubscribable</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class representing an object that can be unsubscribed from a subscribed source.</p> Source code in <code>pyventus/core/subscriptions/unsubscribable.py</code> <pre><code>class Unsubscribable(ABC):\n    \"\"\"An abstract base class representing an object that can be unsubscribed from a subscribed source.\"\"\"\n\n    # Allow subclasses to define __slots__\n    __slots__ = ()\n\n    @abstractmethod\n    def unsubscribe(self) -&gt; bool:\n        \"\"\"\n        Release or clean up any resources associated with the subscribed source.\n\n        :return: `True` if the unsubscribe operation was successful; `False` if it was already unsubscribed.\n        :raises Exception: Any exception raised during the unsubscription process.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/core/subscriptions/unsubscribable/#pyventus.core.subscriptions.Unsubscribable-functions","title":"Functions","text":""},{"location":"api/core/subscriptions/unsubscribable/#pyventus.core.subscriptions.Unsubscribable.unsubscribe","title":"unsubscribe  <code>abstractmethod</code>","text":"<pre><code>unsubscribe() -&gt; bool\n</code></pre> <p>Release or clean up any resources associated with the subscribed source.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the unsubscribe operation was successful; <code>False</code> if it was already unsubscribed.</p> RAISES DESCRIPTION <code>Exception</code> <p>Any exception raised during the unsubscription process.</p> Source code in <code>pyventus/core/subscriptions/unsubscribable.py</code> <pre><code>@abstractmethod\ndef unsubscribe(self) -&gt; bool:\n    \"\"\"\n    Release or clean up any resources associated with the subscribed source.\n\n    :return: `True` if the unsubscribe operation was successful; `False` if it was already unsubscribed.\n    :raises Exception: Any exception raised during the unsubscription process.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/events/","title":"<code>Events</code> module","text":"<p>The event-driven programming module of Pyventus.</p>"},{"location":"api/events/emitters/","title":"<code>EventEmitter</code> class","text":"<p>A class that orchestrates the emission of events.</p> <p>Notes:</p> <ul> <li> <p>This class provides a mechanism for emitting and propagating events to subscribers.     It is designed to handle <code>string-named</code> events with positional and keyword arguments,     as well as instances of <code>dataclass</code> objects and <code>Exception</code> objects.</p> </li> <li> <p>This class focuses only on the event emission logic, while the event linker class     manages the linkage of events and their responses, and the event processor (a.k.a.     processing service) executes the event propagation.</p> </li> </ul> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>class EventEmitter:\n    \"\"\"\n    A class that orchestrates the emission of events.\n\n    **Notes:**\n\n    -   This class provides a mechanism for emitting and propagating events to subscribers.\n        It is designed to handle `string-named` events with positional and keyword arguments,\n        as well as instances of `dataclass` objects and `Exception` objects.\n\n    -   This class focuses only on the event emission logic, while the event linker class\n        manages the linkage of events and their responses, and the event processor (a.k.a.\n        processing service) executes the event propagation.\n    \"\"\"\n\n    @final\n    class EventEmission:\n        \"\"\"\n        Represents an event emission that has been triggered but whose propagation is not yet complete.\n\n        This class provides a self-contained context for executing the event emission, encapsulating both the\n        event data and the associated subscribers. It acts as an isolated unit of work to asynchronously propagate\n        the emission of an event. When an event occurs, the `EventEmitter` class creates an `EventEmission`\n        instance, which is then processed by the event processor to handle the event propagation.\n        \"\"\"\n\n        # Attributes for the EventEmission\n        __slots__ = (\"__id\", \"__event\", \"__subscribers\", \"__args\", \"__kwargs\", \"__timestamp\", \"__debug\")\n\n        def __init__(\n            self,\n            event: str,\n            subscribers: set[EventSubscriber],\n            args: tuple[Any, ...],\n            kwargs: dict[str, Any],\n            debug: bool,\n        ) -&gt; None:\n            \"\"\"\n            Initialize an instance of `EventEmission`.\n\n            :param event: The name of the event being emitted.\n            :param subscribers: A set of subscribers associated with the event.\n            :param args: Positional arguments containing event-specific data.\n            :param kwargs: Keyword arguments containing event-specific data.\n            :param debug: Indicates whether debug mode is enabled.\n            \"\"\"\n            if not event:  # pragma: no cover\n                raise PyventusException(\"The 'event' argument cannot be None or empty.\")\n\n            if not subscribers:  # pragma: no cover\n                raise PyventusException(\"The 'subscribers' argument cannot be None or empty.\")\n\n            # Define and set the event emission attributes\n            self.__id: str = str(uuid4())\n            self.__event: str = event\n            self.__subscribers: set[EventSubscriber] = subscribers\n            self.__args: tuple[Any, ...] = args\n            self.__kwargs: dict[str, Any] = kwargs\n            self.__timestamp: datetime = datetime.now()\n            self.__debug: bool = debug\n\n        def __repr__(self) -&gt; str:\n            \"\"\"\n            Retrieve a string representation of the instance.\n\n            :return: A string representation of the instance.\n            \"\"\"\n            return formatted_repr(\n                instance=self,\n                info=attributes_repr(\n                    id=self.__id,\n                    event=self.__event,\n                    subscribers=self.__subscribers,\n                    args=self.__args,\n                    kwargs=self.__kwargs,\n                    timestamp=self.__timestamp.strftime(\"%Y-%m-%d %I:%M:%S %p\"),\n                    debug=self.__debug,\n                ),\n            )\n\n        @property\n        def id(self) -&gt; str:  # pragma: no cover\n            \"\"\"\n            Retrieve the unique identifier of the event emission.\n\n            :return: The unique identifier of the event emission.\n            \"\"\"\n            return self.__id\n\n        @property\n        def event(self) -&gt; str:  # pragma: no cover\n            \"\"\"\n            Retrieve the name of the emitted event.\n\n            :return: The name of the event.\n            \"\"\"\n            return self.__event\n\n        @property\n        def timestamp(self) -&gt; datetime:  # pragma: no cover\n            \"\"\"\n            Retrieve the timestamp when the event emission was created.\n\n            :return: The timestamp when the event emission was created.\n            \"\"\"\n            return self.__timestamp\n\n        async def __call__(self) -&gt; None:\n            \"\"\"\n            Execute the subscribers concurrently.\n\n            :return: None.\n            \"\"\"\n            # Log the event execution if debug mode is enabled\n            if self.__debug:\n                StdOutLogger.debug(source=summarized_repr(self), action=\"Executing:\", msg=f\"{self}\")\n\n            # Execute the subscribers concurrently\n            await gather(\n                *[subscriber.execute(*self.__args, **self.__kwargs) for subscriber in self.__subscribers],\n                return_exceptions=True,\n            )\n\n            # Perform cleanup by deleting unnecessary references\n            del self.__id, self.__event, self.__subscribers, self.__args, self.__kwargs, self.__timestamp, self.__debug\n\n    # Attributes for the EventEmitter.\n    __slots__ = (\"__event_processor\", \"__event_linker\", \"__logger\")\n\n    def __init__(\n        self,\n        event_processor: ProcessingService,\n        event_linker: type[EventLinker] = EventLinker,\n        debug: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `EventEmitter`.\n\n        :param event_processor: The processing service object used to handle the event propagation.\n        :param event_linker: Specifies the type of event linker used to manage and access\n            events along with their corresponding subscribers. Defaults to `EventLinker`.\n        :param debug: Specifies the debug mode for the logger. If `None`, it is determined\n            based on the execution environment.\n        :raises PyventusException: If the `event_processor` argument is invalid or if\n            the `event_linker` argument is invalid.\n        \"\"\"\n        # Validate the event_processor instance.\n        if event_processor is None or not isinstance(event_processor, ProcessingService):\n            raise PyventusException(\"The 'event_processor' argument must be an instance of ProcessingService.\")\n\n        # Validate the event_linker class.\n        if event_linker is None or not issubclass(event_linker, EventLinker):\n            raise PyventusException(\"The 'event_linker' argument must be a subtype of the EventLinker class.\")\n\n        # Validate the debug argument.\n        if debug is not None and not isinstance(debug, bool):\n            raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n        # Store the event_processor instance.\n        self.__event_processor: ProcessingService = event_processor\n\n        # Set the event_linker class.\n        self.__event_linker: type[EventLinker] = event_linker\n\n        # Create and store logger.\n        self.__logger: Logger = Logger(source=self, debug=debug if debug is not None else bool(gettrace() is not None))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                event_processor=self.__event_processor,\n                event_linker=self.__event_linker.__name__,\n                debug=self.__logger.debug_enabled,\n            ),\n        )\n\n    def emit(self, /, event: EmittableEventType, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Emit an event and notifies all registered subscribers.\n\n        **Notes:**\n\n        -   When emitting `dataclass` objects or `Exception` objects, they are automatically\n            passed to the subscribers as the first positional argument, even if you pass\n            additional `*args` or `**kwargs`.\n\n        -   If there are subscribers registered to the global event `...` (also known\n            as `Ellipsis`), they will be notified each time an event is emitted.\n\n        :param event: The event to be emitted. It can be `str`, a `dataclass`\n            object, or an `Exception` object.\n        :param args: Positional arguments containing event-specific data.\n        :param kwargs: Keyword arguments containing event-specific data.\n        :return: None\n        \"\"\"\n        # Raise an exception if the event is None.\n        if event is None:\n            raise PyventusException(\"The 'event' argument cannot be None.\")\n\n        # Raise an exception if the event is a type.\n        if isinstance(event, type):\n            raise PyventusException(\"The 'event' argument cannot be a type.\")\n\n        # Get the valid event name\n        event_name: str = self.__event_linker.get_valid_event_name(\n            event=(event if isinstance(event, str | EllipsisType) else type(event))\n        )\n\n        # Get the set of subscribers associated with the event, removing one-time subscribers.\n        subscribers: set[EventSubscriber] = self.__event_linker.get_subscribers_from_events(\n            event_name, Ellipsis, pop_onetime_subscribers=True\n        )\n\n        # If there are no subscribers for the event, log a\n        # debug message if debug mode is enabled and exit.\n        if not subscribers:\n            if self.__logger.debug_enabled:\n                self.__logger.debug(action=\"Emitting:\", msg=f\"No subscribers registered for the event '{event_name}'.\")\n            return\n\n        # Create a new EventEmission instance to handle the event propagation.\n        event_emission = EventEmitter.EventEmission(\n            event=event_name,\n            subscribers=subscribers,\n            args=(args if isinstance(event, str | EllipsisType) else (event, *args)),\n            kwargs=kwargs,\n            debug=self.__logger.debug_enabled,\n        )\n\n        # Log the event emission if debug mode is enabled.\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Emitting:\", msg=f\"{event_emission}\")\n\n        # Delegate the event emission execution to the event processor.\n        self.__event_processor.submit(event_emission)\n</code></pre>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter-classes","title":"Classes","text":""},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission","title":"EventEmission","text":"<p>Represents an event emission that has been triggered but whose propagation is not yet complete.</p> <p>This class provides a self-contained context for executing the event emission, encapsulating both the event data and the associated subscribers. It acts as an isolated unit of work to asynchronously propagate the emission of an event. When an event occurs, the <code>EventEmitter</code> class creates an <code>EventEmission</code> instance, which is then processed by the event processor to handle the event propagation.</p> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>@final\nclass EventEmission:\n    \"\"\"\n    Represents an event emission that has been triggered but whose propagation is not yet complete.\n\n    This class provides a self-contained context for executing the event emission, encapsulating both the\n    event data and the associated subscribers. It acts as an isolated unit of work to asynchronously propagate\n    the emission of an event. When an event occurs, the `EventEmitter` class creates an `EventEmission`\n    instance, which is then processed by the event processor to handle the event propagation.\n    \"\"\"\n\n    # Attributes for the EventEmission\n    __slots__ = (\"__id\", \"__event\", \"__subscribers\", \"__args\", \"__kwargs\", \"__timestamp\", \"__debug\")\n\n    def __init__(\n        self,\n        event: str,\n        subscribers: set[EventSubscriber],\n        args: tuple[Any, ...],\n        kwargs: dict[str, Any],\n        debug: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `EventEmission`.\n\n        :param event: The name of the event being emitted.\n        :param subscribers: A set of subscribers associated with the event.\n        :param args: Positional arguments containing event-specific data.\n        :param kwargs: Keyword arguments containing event-specific data.\n        :param debug: Indicates whether debug mode is enabled.\n        \"\"\"\n        if not event:  # pragma: no cover\n            raise PyventusException(\"The 'event' argument cannot be None or empty.\")\n\n        if not subscribers:  # pragma: no cover\n            raise PyventusException(\"The 'subscribers' argument cannot be None or empty.\")\n\n        # Define and set the event emission attributes\n        self.__id: str = str(uuid4())\n        self.__event: str = event\n        self.__subscribers: set[EventSubscriber] = subscribers\n        self.__args: tuple[Any, ...] = args\n        self.__kwargs: dict[str, Any] = kwargs\n        self.__timestamp: datetime = datetime.now()\n        self.__debug: bool = debug\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return formatted_repr(\n            instance=self,\n            info=attributes_repr(\n                id=self.__id,\n                event=self.__event,\n                subscribers=self.__subscribers,\n                args=self.__args,\n                kwargs=self.__kwargs,\n                timestamp=self.__timestamp.strftime(\"%Y-%m-%d %I:%M:%S %p\"),\n                debug=self.__debug,\n            ),\n        )\n\n    @property\n    def id(self) -&gt; str:  # pragma: no cover\n        \"\"\"\n        Retrieve the unique identifier of the event emission.\n\n        :return: The unique identifier of the event emission.\n        \"\"\"\n        return self.__id\n\n    @property\n    def event(self) -&gt; str:  # pragma: no cover\n        \"\"\"\n        Retrieve the name of the emitted event.\n\n        :return: The name of the event.\n        \"\"\"\n        return self.__event\n\n    @property\n    def timestamp(self) -&gt; datetime:  # pragma: no cover\n        \"\"\"\n        Retrieve the timestamp when the event emission was created.\n\n        :return: The timestamp when the event emission was created.\n        \"\"\"\n        return self.__timestamp\n\n    async def __call__(self) -&gt; None:\n        \"\"\"\n        Execute the subscribers concurrently.\n\n        :return: None.\n        \"\"\"\n        # Log the event execution if debug mode is enabled\n        if self.__debug:\n            StdOutLogger.debug(source=summarized_repr(self), action=\"Executing:\", msg=f\"{self}\")\n\n        # Execute the subscribers concurrently\n        await gather(\n            *[subscriber.execute(*self.__args, **self.__kwargs) for subscriber in self.__subscribers],\n            return_exceptions=True,\n        )\n\n        # Perform cleanup by deleting unnecessary references\n        del self.__id, self.__event, self.__subscribers, self.__args, self.__kwargs, self.__timestamp, self.__debug\n</code></pre>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission-attributes","title":"Attributes","text":""},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission.id","title":"id  <code>property</code>","text":"<pre><code>id: str\n</code></pre> <p>Retrieve the unique identifier of the event emission.</p> RETURNS DESCRIPTION <code>str</code> <p>The unique identifier of the event emission.</p>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission.event","title":"event  <code>property</code>","text":"<pre><code>event: str\n</code></pre> <p>Retrieve the name of the emitted event.</p> RETURNS DESCRIPTION <code>str</code> <p>The name of the event.</p>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>Retrieve the timestamp when the event emission was created.</p> RETURNS DESCRIPTION <code>datetime</code> <p>The timestamp when the event emission was created.</p>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission-functions","title":"Functions","text":""},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission.__init__","title":"__init__","text":"<pre><code>__init__(event: str, subscribers: set[EventSubscriber], args: tuple[Any, ...], kwargs: dict[str, Any], debug: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>EventEmission</code>.</p> PARAMETER DESCRIPTION <code>event</code> <p>The name of the event being emitted.</p> <p> TYPE: <code>str</code> </p> <code>subscribers</code> <p>A set of subscribers associated with the event.</p> <p> TYPE: <code>set[EventSubscriber]</code> </p> <code>args</code> <p>Positional arguments containing event-specific data.</p> <p> TYPE: <code>tuple[Any, ...]</code> </p> <code>kwargs</code> <p>Keyword arguments containing event-specific data.</p> <p> TYPE: <code>dict[str, Any]</code> </p> <code>debug</code> <p>Indicates whether debug mode is enabled.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>def __init__(\n    self,\n    event: str,\n    subscribers: set[EventSubscriber],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    debug: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `EventEmission`.\n\n    :param event: The name of the event being emitted.\n    :param subscribers: A set of subscribers associated with the event.\n    :param args: Positional arguments containing event-specific data.\n    :param kwargs: Keyword arguments containing event-specific data.\n    :param debug: Indicates whether debug mode is enabled.\n    \"\"\"\n    if not event:  # pragma: no cover\n        raise PyventusException(\"The 'event' argument cannot be None or empty.\")\n\n    if not subscribers:  # pragma: no cover\n        raise PyventusException(\"The 'subscribers' argument cannot be None or empty.\")\n\n    # Define and set the event emission attributes\n    self.__id: str = str(uuid4())\n    self.__event: str = event\n    self.__subscribers: set[EventSubscriber] = subscribers\n    self.__args: tuple[Any, ...] = args\n    self.__kwargs: dict[str, Any] = kwargs\n    self.__timestamp: datetime = datetime.now()\n    self.__debug: bool = debug\n</code></pre>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.EventEmission.__call__","title":"__call__  <code>async</code>","text":"<pre><code>__call__() -&gt; None\n</code></pre> <p>Execute the subscribers concurrently.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>async def __call__(self) -&gt; None:\n    \"\"\"\n    Execute the subscribers concurrently.\n\n    :return: None.\n    \"\"\"\n    # Log the event execution if debug mode is enabled\n    if self.__debug:\n        StdOutLogger.debug(source=summarized_repr(self), action=\"Executing:\", msg=f\"{self}\")\n\n    # Execute the subscribers concurrently\n    await gather(\n        *[subscriber.execute(*self.__args, **self.__kwargs) for subscriber in self.__subscribers],\n        return_exceptions=True,\n    )\n\n    # Perform cleanup by deleting unnecessary references\n    del self.__id, self.__event, self.__subscribers, self.__args, self.__kwargs, self.__timestamp, self.__debug\n</code></pre>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter-functions","title":"Functions","text":""},{"location":"api/events/emitters/#pyventus.events.EventEmitter.__init__","title":"__init__","text":"<pre><code>__init__(event_processor: ProcessingService, event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; None\n</code></pre> <p>Initialize an instance of <code>EventEmitter</code>.</p> PARAMETER DESCRIPTION <code>event_processor</code> <p>The processing service object used to handle the event propagation.</p> <p> TYPE: <code>ProcessingService</code> </p> <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the <code>event_processor</code> argument is invalid or if the <code>event_linker</code> argument is invalid.</p> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>def __init__(\n    self,\n    event_processor: ProcessingService,\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `EventEmitter`.\n\n    :param event_processor: The processing service object used to handle the event propagation.\n    :param event_linker: Specifies the type of event linker used to manage and access\n        events along with their corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined\n        based on the execution environment.\n    :raises PyventusException: If the `event_processor` argument is invalid or if\n        the `event_linker` argument is invalid.\n    \"\"\"\n    # Validate the event_processor instance.\n    if event_processor is None or not isinstance(event_processor, ProcessingService):\n        raise PyventusException(\"The 'event_processor' argument must be an instance of ProcessingService.\")\n\n    # Validate the event_linker class.\n    if event_linker is None or not issubclass(event_linker, EventLinker):\n        raise PyventusException(\"The 'event_linker' argument must be a subtype of the EventLinker class.\")\n\n    # Validate the debug argument.\n    if debug is not None and not isinstance(debug, bool):\n        raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n    # Store the event_processor instance.\n    self.__event_processor: ProcessingService = event_processor\n\n    # Set the event_linker class.\n    self.__event_linker: type[EventLinker] = event_linker\n\n    # Create and store logger.\n    self.__logger: Logger = Logger(source=self, debug=debug if debug is not None else bool(gettrace() is not None))\n</code></pre>"},{"location":"api/events/emitters/#pyventus.events.EventEmitter.emit","title":"emit","text":"<pre><code>emit(event: EmittableEventType, *args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Emit an event and notifies all registered subscribers.</p> <p>Notes:</p> <ul> <li> <p>When emitting <code>dataclass</code> objects or <code>Exception</code> objects, they are automatically     passed to the subscribers as the first positional argument, even if you pass     additional <code>*args</code> or <code>**kwargs</code>.</p> </li> <li> <p>If there are subscribers registered to the global event <code>...</code> (also known     as <code>Ellipsis</code>), they will be notified each time an event is emitted.</p> </li> </ul> PARAMETER DESCRIPTION <code>event</code> <p>The event to be emitted. It can be <code>str</code>, a <code>dataclass</code> object, or an <code>Exception</code> object.</p> <p> TYPE: <code>EmittableEventType</code> </p> <code>args</code> <p>Positional arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Keyword arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>pyventus/events/emitters/event_emitter.py</code> <pre><code>def emit(self, /, event: EmittableEventType, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Emit an event and notifies all registered subscribers.\n\n    **Notes:**\n\n    -   When emitting `dataclass` objects or `Exception` objects, they are automatically\n        passed to the subscribers as the first positional argument, even if you pass\n        additional `*args` or `**kwargs`.\n\n    -   If there are subscribers registered to the global event `...` (also known\n        as `Ellipsis`), they will be notified each time an event is emitted.\n\n    :param event: The event to be emitted. It can be `str`, a `dataclass`\n        object, or an `Exception` object.\n    :param args: Positional arguments containing event-specific data.\n    :param kwargs: Keyword arguments containing event-specific data.\n    :return: None\n    \"\"\"\n    # Raise an exception if the event is None.\n    if event is None:\n        raise PyventusException(\"The 'event' argument cannot be None.\")\n\n    # Raise an exception if the event is a type.\n    if isinstance(event, type):\n        raise PyventusException(\"The 'event' argument cannot be a type.\")\n\n    # Get the valid event name\n    event_name: str = self.__event_linker.get_valid_event_name(\n        event=(event if isinstance(event, str | EllipsisType) else type(event))\n    )\n\n    # Get the set of subscribers associated with the event, removing one-time subscribers.\n    subscribers: set[EventSubscriber] = self.__event_linker.get_subscribers_from_events(\n        event_name, Ellipsis, pop_onetime_subscribers=True\n    )\n\n    # If there are no subscribers for the event, log a\n    # debug message if debug mode is enabled and exit.\n    if not subscribers:\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Emitting:\", msg=f\"No subscribers registered for the event '{event_name}'.\")\n        return\n\n    # Create a new EventEmission instance to handle the event propagation.\n    event_emission = EventEmitter.EventEmission(\n        event=event_name,\n        subscribers=subscribers,\n        args=(args if isinstance(event, str | EllipsisType) else (event, *args)),\n        kwargs=kwargs,\n        debug=self.__logger.debug_enabled,\n    )\n\n    # Log the event emission if debug mode is enabled.\n    if self.__logger.debug_enabled:\n        self.__logger.debug(action=\"Emitting:\", msg=f\"{event_emission}\")\n\n    # Delegate the event emission execution to the event processor.\n    self.__event_processor.submit(event_emission)\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/","title":"EventEmitter Utils","text":""},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils-functions","title":"Functions","text":""},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.AsyncIOEventEmitter","title":"AsyncIOEventEmitter","text":"<pre><code>AsyncIOEventEmitter(event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; EventEmitter\n</code></pre> <p>Create an <code>EventEmitter</code> instance configured with the <code>AsyncIOProcessingService</code>.</p> PARAMETER DESCRIPTION <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EventEmitter</code> <p>An instance of <code>EventEmitter</code> configured with the <code>AsyncIOProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>def AsyncIOEventEmitter(  # noqa: N802\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; EventEmitter:\n    \"\"\"\n    Create an `EventEmitter` instance configured with the `AsyncIOProcessingService`.\n\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `AsyncIOProcessingService`.\n    \"\"\"\n    from ...core.processing.asyncio import AsyncIOProcessingService\n\n    processing_service = AsyncIOProcessingService()\n\n    return EventEmitter(\n        event_processor=processing_service,\n        event_linker=event_linker,\n        debug=debug,\n    )\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.CeleryEventEmitter","title":"CeleryEventEmitter","text":"<pre><code>CeleryEventEmitter(celery: Any, queue: str | None = None, event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; EventEmitter\n</code></pre> <p>Create an <code>EventEmitter</code> instance configured with the <code>CeleryProcessingService</code>.</p> PARAMETER DESCRIPTION <code>celery</code> <p>The Celery object used to enqueue and process event emissions.</p> <p> TYPE: <code>Any</code> </p> <code>queue</code> <p>The name of the queue where the event emission will be enqueued. Defaults to None, which uses the task_default_queue from the Celery configuration.</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EventEmitter</code> <p>An instance of <code>EventEmitter</code> configured with the <code>CeleryProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>def CeleryEventEmitter(  # noqa: N802\n    celery: Any,\n    queue: str | None = None,\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; EventEmitter:\n    \"\"\"\n    Create an `EventEmitter` instance configured with the `CeleryProcessingService`.\n\n    :param celery: The Celery object used to enqueue and process event emissions.\n    :param queue: The name of the queue where the event emission will be enqueued.\n        Defaults to None, which uses the task_default_queue from the Celery configuration.\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `CeleryProcessingService`.\n    \"\"\"\n    from ...core.processing.celery import CeleryProcessingService\n\n    processing_service = CeleryProcessingService(celery=celery, queue=queue)\n\n    return EventEmitter(\n        event_processor=processing_service,\n        event_linker=event_linker,\n        debug=debug,\n    )\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.ExecutorEventEmitter","title":"ExecutorEventEmitter","text":"<pre><code>ExecutorEventEmitter(executor: Executor, event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; EventEmitter\n</code></pre> <p>Create an <code>EventEmitter</code> instance configured with the <code>ExecutorProcessingService</code>.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor object used to handle the execution of event emissions.</p> <p> TYPE: <code>Executor</code> </p> <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EventEmitter</code> <p>An instance of <code>EventEmitter</code> configured with the <code>ExecutorProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>def ExecutorEventEmitter(  # noqa: N802\n    executor: Executor,\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; EventEmitter:\n    \"\"\"\n    Create an `EventEmitter` instance configured with the `ExecutorProcessingService`.\n\n    :param executor: The executor object used to handle the execution of event emissions.\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `ExecutorProcessingService`.\n    \"\"\"\n    from ...core.processing.executor import ExecutorProcessingService\n\n    processing_service = ExecutorProcessingService(executor=executor)\n\n    return EventEmitter(\n        event_processor=processing_service,\n        event_linker=event_linker,\n        debug=debug,\n    )\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.ExecutorEventEmitterCtx","title":"ExecutorEventEmitterCtx","text":"<pre><code>ExecutorEventEmitterCtx(executor: Executor | None = None, event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; Generator[EventEmitter, None, None]\n</code></pre> <p>Context manager that creates an <code>EventEmitter</code> instance configured with the <code>ExecutorProcessingService</code>.</p> <p>This context manager yields an <code>EventEmitter</code> instance, which can be used within a <code>with</code> statement. Upon exiting the context, the processing service is properly shut down.</p> PARAMETER DESCRIPTION <code>executor</code> <p>The executor object used to handle the execution of event emissions. If <code>None</code>, a <code>ThreadPoolExecutor</code> with default settings will be created.</p> <p> TYPE: <code>Executor | None</code> DEFAULT: <code>None</code> </p> <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Generator[EventEmitter, None, None]</code> <p>An instance of <code>EventEmitter</code> configured with the <code>ExecutorProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>@contextmanager\ndef ExecutorEventEmitterCtx(  # noqa: N802\n    executor: Executor | None = None,\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; Generator[EventEmitter, None, None]:\n    \"\"\"\n    Context manager that creates an `EventEmitter` instance configured with the `ExecutorProcessingService`.\n\n    This context manager yields an `EventEmitter` instance, which can be used within a `with` statement.\n    Upon exiting the context, the processing service is properly shut down.\n\n    :param executor: The executor object used to handle the execution of event emissions. If `None`,\n        a `ThreadPoolExecutor` with default settings will be created.\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `ExecutorProcessingService`.\n    \"\"\"\n    from ...core.processing.executor import ExecutorProcessingService\n\n    processing_service = ExecutorProcessingService(executor=(executor if executor else ThreadPoolExecutor()))\n\n    yield EventEmitter(\n        event_processor=processing_service,\n        event_linker=event_linker,\n        debug=debug,\n    )\n\n    processing_service.shutdown()\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.FastAPIEventEmitter","title":"FastAPIEventEmitter","text":"<pre><code>FastAPIEventEmitter(event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; Callable[[Any], EventEmitter]\n</code></pre> <p>Create an <code>EventEmitter</code> instance configured with the <code>FastAPIProcessingService</code>.</p> <p>This function is compatible with FastAPI's dependency injection system and should be used with the <code>Depends</code> method to automatically provide the <code>BackgroundTasks</code> instance.</p> PARAMETER DESCRIPTION <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[[Any], EventEmitter]</code> <p>An instance of <code>EventEmitter</code> configured with the <code>FastAPIProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>def FastAPIEventEmitter(  # noqa: N802\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; Callable[[Any], EventEmitter]:\n    \"\"\"\n    Create an `EventEmitter` instance configured with the `FastAPIProcessingService`.\n\n    This function is compatible with FastAPI's dependency injection system and should be\n    used with the `Depends` method to automatically provide the `BackgroundTasks` instance.\n\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `FastAPIProcessingService`.\n    \"\"\"\n    from fastapi import BackgroundTasks\n\n    from ...core.processing.fastapi import FastAPIProcessingService\n\n    def create_event_emitter(background_tasks: BackgroundTasks) -&gt; EventEmitter:\n        \"\"\"\n        Create and return an `EventEmitter` instance using the provided `BackgroundTasks`.\n\n        :param background_tasks: The FastAPI `BackgroundTasks` object used to handle the execution of event emissions.\n        :return: An instance of `EventEmitter` configured with the `FastAPIProcessingService`.\n        \"\"\"\n        processing_service = FastAPIProcessingService(background_tasks=background_tasks)\n\n        return EventEmitter(\n            event_processor=processing_service,\n            event_linker=event_linker,\n            debug=debug,\n        )\n\n    return create_event_emitter\n</code></pre>"},{"location":"api/events/emitters/event_emitter_utils/#pyventus.events.emitters.event_emitter_utils.RedisEventEmitter","title":"RedisEventEmitter","text":"<pre><code>RedisEventEmitter(queue: Any, options: dict[str, Any] | None = None, event_linker: type[EventLinker] = EventLinker, debug: bool | None = None) -&gt; EventEmitter\n</code></pre> <p>Create an <code>EventEmitter</code> instance configured with the <code>RedisProcessingService</code>.</p> PARAMETER DESCRIPTION <code>queue</code> <p>The Redis queue object used to enqueue and process event emissions.</p> <p> TYPE: <code>Any</code> </p> <code>options</code> <p>Additional options for the RQ package enqueueing method. Defaults to None (an empty dictionary).</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>event_linker</code> <p>Specifies the type of event linker used to manage and access events along with their corresponding subscribers. Defaults to <code>EventLinker</code>.</p> <p> TYPE: <code>type[EventLinker]</code> DEFAULT: <code>EventLinker</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EventEmitter</code> <p>An instance of <code>EventEmitter</code> configured with the <code>RedisProcessingService</code>.</p> Source code in <code>pyventus/events/emitters/event_emitter_utils.py</code> <pre><code>def RedisEventEmitter(  # noqa: N802\n    queue: Any,\n    options: dict[str, Any] | None = None,\n    event_linker: type[EventLinker] = EventLinker,\n    debug: bool | None = None,\n) -&gt; EventEmitter:\n    \"\"\"\n    Create an `EventEmitter` instance configured with the `RedisProcessingService`.\n\n    :param queue: The Redis queue object used to enqueue and process event emissions.\n    :param options: Additional options for the RQ package enqueueing method. Defaults to None (an empty dictionary).\n    :param event_linker: Specifies the type of event linker used to manage and access events along with their\n        corresponding subscribers. Defaults to `EventLinker`.\n    :param debug: Specifies the debug mode for the logger. If `None`, it is determined based on the\n        execution environment.\n    :return: An instance of `EventEmitter` configured with the `RedisProcessingService`.\n    \"\"\"\n    from ...core.processing.redis import RedisProcessingService\n\n    processing_service = RedisProcessingService(queue=queue, options=options)\n\n    return EventEmitter(\n        event_processor=processing_service,\n        event_linker=event_linker,\n        debug=debug,\n    )\n</code></pre>"},{"location":"api/events/handlers/event_handler/","title":"<code>EventHandler</code> class","text":"<p>               Bases: <code>ABC</code></p> <p>An abstract base class that defines the workflow and essential protocols for event handling.</p> Source code in <code>pyventus/events/handlers/event_handler.py</code> <pre><code>class EventHandler(ABC):\n    \"\"\"An abstract base class that defines the workflow and essential protocols for event handling.\"\"\"\n\n    # Allow subclasses to define __slots__\n    __slots__ = ()\n\n    @abstractmethod\n    async def _handle_event(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Handle the event response.\n\n        :param args: Positional arguments containing event-specific data.\n        :param kwargs: Keyword arguments containing event-specific data.\n        :return: The result of handling the event.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def _handle_success(self, results: Any) -&gt; None:\n        \"\"\"\n        Handle the successful completion of the event response.\n\n        :param results: The results of handling the event.\n        :return: None.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def _handle_failure(self, exception: Exception) -&gt; None:\n        \"\"\"\n        Handle the failed completion of the event response.\n\n        :param exception: The exception that occurred during the event handling.\n        :return: None.\n        \"\"\"\n        pass\n\n    async def execute(self, *args: Any, **kwargs: Any) -&gt; None:\n        \"\"\"\n        Execute the event workflow.\n\n        :param args: Positional arguments containing event-specific data.\n        :param kwargs: Keyword arguments containing event-specific data.\n        :return: None.\n        \"\"\"\n        try:\n            # Start the event handling process and store the results\n            results: Any = await self._handle_event(*args, **kwargs)\n        except Exception as exception:\n            # Log the exception that occurred during the event handling.\n            StdOutLogger.error(source=summarized_repr(self), action=\"Exception:\", msg=f\"{repr(exception)}\")\n\n            # Handle the failed completion of the event response.\n            await self._handle_failure(exception=exception)\n        else:\n            # Handle the successful completion of the event response.\n            await self._handle_success(results=results)\n</code></pre>"},{"location":"api/events/handlers/event_handler/#pyventus.events.EventHandler-functions","title":"Functions","text":""},{"location":"api/events/handlers/event_handler/#pyventus.events.EventHandler.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Execute the event workflow.</p> PARAMETER DESCRIPTION <code>args</code> <p>Positional arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Keyword arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/events/handlers/event_handler.py</code> <pre><code>async def execute(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Execute the event workflow.\n\n    :param args: Positional arguments containing event-specific data.\n    :param kwargs: Keyword arguments containing event-specific data.\n    :return: None.\n    \"\"\"\n    try:\n        # Start the event handling process and store the results\n        results: Any = await self._handle_event(*args, **kwargs)\n    except Exception as exception:\n        # Log the exception that occurred during the event handling.\n        StdOutLogger.error(source=summarized_repr(self), action=\"Exception:\", msg=f\"{repr(exception)}\")\n\n        # Handle the failed completion of the event response.\n        await self._handle_failure(exception=exception)\n    else:\n        # Handle the successful completion of the event response.\n        await self._handle_success(results=results)\n</code></pre>"},{"location":"api/events/linkers/event_linker/","title":"<code>EventLinker</code> class","text":"<p>A base class that orchestrates the linkage of events and their inherent logic.</p> <p>Notes:</p> <ul> <li> <p>This class provides a centralized mechanism for managing the connections     between events and their corresponding logic.</p> </li> <li> <p>The <code>EventLinker</code> can be subclassed to create specific namespaces or contexts     for managing events within different scopes. Subclassing also allows users to     configure the settings of the <code>EventLinker</code> to suit their specific use cases.</p> </li> <li> <p>The <code>EventLinker</code> is designed with thread safety in mind. All methods     synchronize access to prevent race conditions when managing mutable     properties across multiple threads.</p> </li> </ul> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>class EventLinker:\n    \"\"\"\n    A base class that orchestrates the linkage of events and their inherent logic.\n\n    **Notes:**\n\n    -   This class provides a centralized mechanism for managing the connections\n        between events and their corresponding logic.\n\n    -   The `EventLinker` can be subclassed to create specific namespaces or contexts\n        for managing events within different scopes. Subclassing also allows users to\n        configure the settings of the `EventLinker` to suit their specific use cases.\n\n    -   The `EventLinker` is designed with *thread safety* in mind. All methods\n        synchronize access to prevent race conditions when managing mutable\n        properties across multiple threads.\n    \"\"\"\n\n    @final\n    class EventLinkerSubCtx(Generic[_SubCtxE], SubscriptionContext[_SubCtxE, EventSubscriber]):\n        \"\"\"\n        A context manager for event linker subscriptions.\n\n        **Notes:**\n\n        -   This class establishes a context block for a step-by-step definition of event responses\n            prior to the actual subscription, which occurs immediately upon exiting the context block.\n\n        -   This class can be used as either a decorator or a context manager. When used as a\n            decorator, it automatically subscribes the decorated callback to the specified events.\n            When used as a context manager with the `with` statement, it allows multiple callbacks\n            to be associated with the specified events within the context block.\n\n        -   This subscription context can be `stateful`, retaining references to the `event linker`\n            and `subscriber`, or `stateless`, which clears the context upon exiting the subscription\n            block.\n\n        -   This class is not intended to be subclassed or manually instantiated.\n        \"\"\"\n\n        # Attributes for the EventLinkerSubCtx\n        __slots__ = (\n            \"__events\",\n            \"__event_callback\",\n            \"__success_callback\",\n            \"__failure_callback\",\n            \"__force_async\",\n            \"__once\",\n        )\n\n        def __init__(\n            self,\n            events: tuple[SubscribableEventType, ...],\n            event_linker: _SubCtxE,\n            force_async: bool,\n            once: bool,\n            is_stateful: bool,\n        ) -&gt; None:\n            \"\"\"\n            Initialize an instance of `EventLinkerSubCtx`.\n\n            :param events: The events to subscribe/link to.\n            :param event_linker: The type of event linker used for the actual subscription.\n            :param force_async: Determines whether to force all callbacks to run asynchronously.\n            :param once: Specifies if the event subscriber will be a one-time subscription.\n            :param is_stateful: A flag indicating whether the context preserves its state (stateful) or\n                not (stateless) after exiting the subscription context. If `True`, the context retains its\n                state, allowing access to stored objects, including the `event linker` and the `subscriber`\n                object. If `False`, the context is stateless, and the stored state is cleared upon exiting\n                the subscription context to prevent memory leaks.\n            \"\"\"\n            # Initialize the base SubscriptionContext class\n            super().__init__(source=event_linker, is_stateful=is_stateful)\n\n            # Initialize variables\n            self.__events: tuple[SubscribableEventType, ...] = events\n            self.__event_callback: EventCallbackType | None = None\n            self.__success_callback: SuccessCallbackType | None = None\n            self.__failure_callback: FailureCallbackType | None = None\n            self.__force_async: bool = force_async\n            self.__once: bool = once\n\n        @override\n        def _exit(self) -&gt; EventSubscriber:\n            # Ensure that the source is not None\n            if self._source is None:  # pragma: no cover\n                raise PyventusException(\"The subscription context is closed.\")\n\n            # Check if the event callback has been set\n            if self.__event_callback is None:\n                raise PyventusException(\"The event callback has not been set.\")\n\n            # Subscribe the defined callbacks to the\n            # specified events and store the returned subscriber.\n            subscriber: EventSubscriber = self._source.subscribe(\n                *self.__events,\n                event_callback=self.__event_callback,\n                success_callback=self.__success_callback,\n                failure_callback=self.__failure_callback,\n                force_async=self.__force_async,\n                once=self.__once,\n            )\n\n            # Remove context-specific attributes to clean up\n            # and prevent memory leaks.\n            del self.__events\n            del self.__event_callback, self.__success_callback, self.__failure_callback\n            del self.__force_async, self.__once\n\n            # Return the subscriber\n            return subscriber\n\n        def on_event(self, callback: EventCallbackType) -&gt; EventCallbackType:\n            \"\"\"\n            Set the main callback for the event.\n\n            :param callback: The callback to be executed when the event occurs.\n            :return: The decorated callback.\n            \"\"\"\n            self.__event_callback = callback\n            return callback\n\n        def on_success(self, callback: SuccessCallbackType) -&gt; SuccessCallbackType:\n            \"\"\"\n            Set the success callback for the event.\n\n            :param callback: The callback to be executed when the event response completes successfully.\n            :return: The decorated callback.\n            \"\"\"\n            self.__success_callback = callback\n            return callback\n\n        def on_failure(self, callback: FailureCallbackType) -&gt; FailureCallbackType:\n            \"\"\"\n            Set the failure callback for the event.\n\n            :param callback: The callback to be executed when the event response fails.\n            :return: The decorated callback.\n            \"\"\"\n            self.__failure_callback = callback\n            return callback\n\n        def __call__(\n            self, callback: EventCallbackType\n        ) -&gt; tuple[EventCallbackType, \"EventLinker.EventLinkerSubCtx[_SubCtxE]\"] | EventCallbackType:\n            \"\"\"\n            Subscribe the decorated callback to the specified events.\n\n            :param callback: The callback to be executed when the event occurs.\n            :return: A tuple containing the decorated callback and its subscription context\n                if the context is stateful; otherwise, returns the decorated callback alone.\n            \"\"\"\n            # Store the provided callback as the event callback\n            self.__event_callback = callback\n\n            # Set success and failure callbacks to None\n            self.__success_callback = None\n            self.__failure_callback = None\n\n            # Determine if the subscription context is stateful\n            is_stateful: bool = self._is_stateful\n\n            # Call the exit method to finalize the\n            # subscription process and clean up any necessary context.\n            self.__exit__(None, None, None)\n\n            # Return a tuple containing the decorated callback\n            # and the current subscription context if the context\n            # is stateful; otherwise, return just the callback.\n            return (callback, self) if is_stateful else callback\n\n    __registry: MultiBidict[str, EventSubscriber] = MultiBidict[str, EventSubscriber]()\n    \"\"\"\n    A registry that serves as a container for storing events and their associated subscribers. It \n    utilizes an optimized data structure that enables quick lookups, updates, and even deletions \n    of events and their subscribers.\n    \"\"\"\n\n    __max_subscribers: int | None = None\n    \"\"\"The maximum number of subscribers allowed per event, or `None` if there is no limit.\"\"\"\n\n    __default_success_callback: SuccessCallbackType | None = None\n    \"\"\" \n    Represents the default success callback that will be assigned to subscribers in the \n    absence of a specific success callback. This callback will be executed upon successful \n    completion of the event response in each subscriber.\n    \"\"\"\n\n    __default_failure_callback: FailureCallbackType | None = None\n    \"\"\"\n    Represents the default failure callback that will be assigned to subscribers in the\n    absence of a specific failure callback. This callback will be executed when the event \n    response fails in each subscriber.\n    \"\"\"\n\n    __thread_lock: Lock = Lock()\n    \"\"\"\n    A `threading.Lock` object used for thread synchronization when accessing and modifying \n    mutable attributes to ensure thread safety. It prevents multiple threads from accessing \n    and modifying mutable properties simultaneously.\n    \"\"\"\n\n    __logger: Logger = Logger(source=\"EventLinker(ClassReference)\", debug=bool(gettrace() is not None))\n    \"\"\"\n    The logger used to debug and log information within the `EventLinker` class. The debug mode\n    of the logger depends on the execution environment and the value returned by the `gettrace()`\n    function. The debug mode can also be influenced by subclassing and overridden in subclasses.\n    \"\"\"\n\n    def __init_subclass__(\n        cls,\n        max_subscribers: int | None = None,\n        default_success_callback: SuccessCallbackType | None = None,\n        default_failure_callback: FailureCallbackType | None = None,\n        debug: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize a subclass of `EventLinker`.\n\n        By default, this method sets up the main registry and the thread lock object, but\n        it can also be used to configure specific settings of the `EventLinker` subclass.\n\n        :param max_subscribers: The maximum number of subscribers allowed per event, or `None` if there is no limit.\n        :param default_success_callback: The default callback to assign as the success callback in the subscribers\n            when no specific success callback is provided.\n        :param default_failure_callback: The default callback to assign as the failure callback in the subscribers\n            when no specific failure callback is provided.\n        :param debug: Specifies the debug mode for the subclass logger. If `None`, it is determined based\n            on the execution environment.\n        :raises PyventusException: If `max_subscribers` is less than 1 or if the provided\n            callbacks are invalid.\n        :return: None.\n        \"\"\"\n        # Initialize the main registry\n        cls.__registry = MultiBidict[str, EventSubscriber]()\n\n        # Create a lock object for thread synchronization\n        cls.__thread_lock = Lock()\n\n        # Validate the max_subscribers argument\n        if max_subscribers is not None and max_subscribers &lt; 1:\n            raise PyventusException(\"The 'max_subscribers' argument must be greater than or equal to 1.\")\n\n        # Set the maximum number of subscribers per event\n        cls.__max_subscribers = max_subscribers\n\n        # Validate the default success callback, if any\n        if default_success_callback is not None:\n            validate_callable(default_success_callback)\n\n        # Set the default success callback\n        cls.__default_success_callback = default_success_callback\n\n        # Validate the default failure callback, if any\n        if default_failure_callback is not None:\n            validate_callable(default_failure_callback)\n\n        # Set the default failure callback\n        cls.__default_failure_callback = default_failure_callback\n\n        # Validate the debug argument\n        if debug is not None and not isinstance(debug, bool):\n            raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n        # Set up the logger\n        cls.__logger = Logger(source=cls, debug=debug if debug is not None else bool(gettrace() is not None))\n\n    @classmethod\n    def _get_logger(cls) -&gt; Logger:\n        \"\"\"\n        Retrieve the class-level logger instance.\n\n        :return: The class-level logger instance used to debug and log\n            information within the `EventLinker` class.\n        \"\"\"\n        return cls.__logger\n\n    @classmethod\n    def _get_valid_and_unique_event_names(cls, events: tuple[SubscribableEventType, ...]) -&gt; set[str]:\n        \"\"\"\n        Validate and extract unique event names from the specified tuple of event objects.\n\n        :param events: A tuple of event objects to validate and extract unique names from.\n        :return: A set of unique and valid event names derived from the provided tuple of event objects.\n        :raises PyventusException: If the 'events' argument is None, empty, or contains invalid events.\n        \"\"\"\n        if not events:\n            raise PyventusException(\"The 'events' argument cannot be None or empty.\")\n        return {cls.get_valid_event_name(event) for event in events}\n\n    @classmethod\n    def _get_valid_and_unique_subscribers(cls, subscribers: tuple[EventSubscriber, ...]) -&gt; set[EventSubscriber]:\n        \"\"\"\n        Validate and extract unique subscribers from the specified tuple of subscribers.\n\n        :param subscribers: A tuple of event subscribers to validate and extract unique entries from.\n        :return: A set of unique and valid subscribers derived from the provided tuple of subscribers.\n        :raises PyventusException: If the 'subscribers' argument is None, empty, or contains invalid subscribers.\n        \"\"\"\n        if not subscribers:\n            raise PyventusException(\"The 'subscribers' argument cannot be None or empty.\")\n        return {cls.get_valid_subscriber(subscriber) for subscriber in subscribers}\n\n    @classmethod\n    def get_valid_event_name(cls, event: SubscribableEventType) -&gt; str:\n        \"\"\"\n        Determine the name of the event and performs validation.\n\n        :param event: The event to obtain the name for.\n        :return: A string that represents the event name.\n        :raises PyventusException: If the `event` argument is invalid\n            or if the event is not supported.\n        \"\"\"\n        # Validate the event argument\n        if event is None:\n            raise PyventusException(\"The 'event' argument cannot be None.\")\n\n        if event is Ellipsis:\n            # If the event is Ellipsis, return its type name\n            return type(event).__name__\n        elif isinstance(event, str):\n            if not event:\n                raise PyventusException(\"String events cannot be empty.\")\n            # If the event is a non-empty string, return it as the event name\n            return event\n        elif isinstance(event, type):\n            if not is_dataclass(event) and not issubclass(event, Exception):\n                raise PyventusException(\"Type events must be either a dataclass or an exception.\")\n            # If the event is either a dataclass type or an exception type, return its type name\n            return event.__name__\n        else:\n            # If the event is not supported, raise an exception\n            raise PyventusException(\"Unsupported event\")\n\n    @classmethod\n    def get_valid_subscriber(cls, subscriber: EventSubscriber) -&gt; EventSubscriber:\n        \"\"\"\n        Validate and return the specified subscriber.\n\n        :param subscriber: The subscriber to validate.\n        :return: The validated subscriber.\n        :raises PyventusException: If the subscriber is not an instance of `EventSubscriber`.\n        \"\"\"\n        # Validate that the subscriber is an instance of EventSubscriber\n        if not isinstance(subscriber, EventSubscriber):\n            raise PyventusException(\"The 'subscriber' argument must be an instance of EventSubscriber.\")\n        return subscriber\n\n    @classmethod\n    def get_max_subscribers(cls) -&gt; int | None:\n        \"\"\"\n        Retrieve the maximum number of subscribers allowed per event.\n\n        :return: The maximum number of subscribers or `None` if there is no limit.\n        \"\"\"\n        return cls.__max_subscribers\n\n    @classmethod\n    def get_default_success_callback(cls) -&gt; SuccessCallbackType | None:\n        \"\"\"\n        Retrieve the default success callback to assign to subscribers when no specific callback is provided.\n\n        :return: The default success callback or `None` if not set.\n        \"\"\"\n        return cls.__default_success_callback\n\n    @classmethod\n    def get_default_failure_callback(cls) -&gt; FailureCallbackType | None:\n        \"\"\"\n        Retrieve the default failure callback to assign to subscribers when no specific callback is provided.\n\n        :return: The default failure callback or `None` if not set.\n        \"\"\"\n        return cls.__default_failure_callback\n\n    @classmethod\n    def is_empty(cls) -&gt; bool:\n        \"\"\"\n        Determine whether the main registry is empty.\n\n        :return: `True` if the main registry is empty, `False` otherwise.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.is_empty\n\n    @classmethod\n    def get_registry(cls) -&gt; dict[str, set[EventSubscriber]]:\n        \"\"\"\n        Retrieve a shallow copy of the main registry.\n\n        :return: A shallow copy of the main registry, where each\n            event is mapped to a set of its linked subscribers.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.to_dict()\n\n    @classmethod\n    def get_events(cls) -&gt; set[str]:\n        \"\"\"\n        Retrieve all registered events.\n\n        :return: A set of all registered event names.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.keys\n\n    @classmethod\n    def get_subscribers(cls) -&gt; set[EventSubscriber]:\n        \"\"\"\n        Retrieve all registered subscribers.\n\n        :return: A set of all registered subscribers.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.values\n\n    @classmethod\n    def get_event_count(cls) -&gt; int:\n        \"\"\"\n        Retrieve the number of registered events.\n\n        :return: The total count of events in the registry.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.key_count\n\n    @classmethod\n    def get_subscriber_count(cls) -&gt; int:\n        \"\"\"\n        Retrieve the number of registered subscribers.\n\n        :return: The total count of subscribers in the registry.\n        \"\"\"\n        with cls.__thread_lock:\n            return cls.__registry.value_count\n\n    @classmethod\n    def get_events_from_subscribers(cls, *subscribers: EventSubscriber) -&gt; set[str]:\n        \"\"\"\n        Retrieve a set of events associated with the specified subscribers.\n\n        :param subscribers: One or more subscribers for which to retrieve associated events.\n        :return: A set of events linked to the specified subscribers. Unregistered subscribers are ignored.\n        \"\"\"\n        # Validate and retrieve all unique subscribers to avoid duplicate processing\n        unique_subscribers: set[EventSubscriber] = cls._get_valid_and_unique_subscribers(subscribers)\n\n        # Return the set of event names associated with the unique subscribers\n        with cls.__thread_lock:\n            return cls.__registry.get_keys_from_values(unique_subscribers)\n\n    @classmethod\n    def get_subscribers_from_events(\n        cls, *events: SubscribableEventType, pop_onetime_subscribers: bool = False\n    ) -&gt; set[EventSubscriber]:\n        \"\"\"\n        Retrieve a set of subscribers associated with the specified events.\n\n        :param events: One or more events for which to retrieve associated subscribers.\n        :param pop_onetime_subscribers: If `True`, removes one-time subscribers (those\n            with the property `once` set to True) from the registry.\n        :return: A set of subscribers linked to the specified events. Unregistered events are ignored.\n        \"\"\"\n        # Validate and retrieve all unique event names to avoid duplicate processing\n        unique_events: set[str] = cls._get_valid_and_unique_event_names(events)\n\n        # Acquire lock to ensure thread safety\n        with cls.__thread_lock:\n            # Retrieve subscribers associated with the unique events\n            subscribers: set[EventSubscriber] = cls.__registry.get_values_from_keys(unique_events)\n\n            # Just return subscribers if pop_one_time_subscribers is False\n            if not pop_onetime_subscribers:\n                return subscribers\n\n            # Remove one-time subscribers from the registry\n            for subscriber in subscribers:\n                if subscriber.once:\n                    cls.__registry.remove_value(subscriber)\n\n        # Return the set of subscribers\n        return subscribers\n\n    @classmethod\n    def get_event_count_from_subscriber(cls, subscriber: EventSubscriber) -&gt; int:\n        \"\"\"\n        Retrieve the number of events associated with the given subscriber.\n\n        :param subscriber: The subscriber for which to count the associated events.\n        :return: The count of events associated with the specified subscriber,\n            or 0 if the subscriber is not found.\n        \"\"\"\n        valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n        with cls.__thread_lock:\n            return cls.__registry.get_key_count_from_value(valid_subscriber)\n\n    @classmethod\n    def get_subscriber_count_from_event(cls, event: SubscribableEventType) -&gt; int:\n        \"\"\"\n        Retrieve the number of subscribers associated with a given event.\n\n        :param event: The event for which to count the associated subscribers.\n        :return: The count of subscribers associated with the specified event,\n            or 0 if the event is not found.\n        \"\"\"\n        valid_event: str = cls.get_valid_event_name(event)\n        with cls.__thread_lock:\n            return cls.__registry.get_value_count_from_key(valid_event)\n\n    @classmethod\n    def contains_event(cls, event: SubscribableEventType) -&gt; bool:\n        \"\"\"\n        Determine if the specified event is present in the registry.\n\n        :param event: The event to be checked.\n        :return: `True` if the event is found; `False` otherwise.\n        \"\"\"\n        valid_event: str = cls.get_valid_event_name(event)\n        with cls.__thread_lock:\n            return cls.__registry.contains_key(valid_event)\n\n    @classmethod\n    def contains_subscriber(cls, subscriber: EventSubscriber) -&gt; bool:\n        \"\"\"\n        Determine if the specified subscriber is present in the registry.\n\n        :param subscriber: The subscriber to be checked.\n        :return: `True` if the subscriber is found; `False` otherwise.\n        \"\"\"\n        valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n        with cls.__thread_lock:\n            return cls.__registry.contains_value(valid_subscriber)\n\n    @classmethod\n    def are_linked(cls, event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool:\n        \"\"\"\n        Determine whether the given event is linked with the specified subscriber.\n\n        :param event: The event for which the association is being checked.\n        :param subscriber: The subscriber for which the association is being checked.\n        :return: `True` if the subscriber is linked to the event; `False` otherwise.\n        \"\"\"\n        valid_event: str = cls.get_valid_event_name(event)\n        valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n        with cls.__thread_lock:\n            return cls.__registry.are_associated(valid_event, valid_subscriber)\n\n    @classmethod\n    def once(\n        cls, *events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False\n    ) -&gt; EventLinkerSubCtx[type[Self]]:\n        \"\"\"\n        Subscribe callbacks to the specified events for a single invocation.\n\n        This method can be used as either a decorator or a context manager. When used as a\n        decorator, it automatically subscribes the decorated callback to the provided events.\n        When used as a context manager with the `with` statement, it allows multiple callbacks\n        to be associated with the provided events within the context block.\n\n        :param events: The events to subscribe to.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n            If `True`, synchronous callbacks will be converted to run asynchronously in a\n            thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n            will run synchronously or asynchronously as defined.\n        :param stateful_subctx: A flag indicating whether the subscription context preserves its state\n            (`stateful`) or not (`stateless`) after exiting the subscription block. If `True`, the context retains\n            its state, allowing access to stored objects, including the `event linker` and the `subscriber` object.\n            If `False`, the context is stateless, and the stored state is cleared upon exiting the subscription\n            block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n        :return: A `EventLinkerSubCtx` instance.\n        \"\"\"\n        return EventLinker.EventLinkerSubCtx[type[Self]](\n            events=events, event_linker=cls, force_async=force_async, once=True, is_stateful=stateful_subctx\n        )\n\n    @classmethod\n    def on(\n        cls, *events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False\n    ) -&gt; EventLinkerSubCtx[type[Self]]:\n        \"\"\"\n        Subscribe callbacks to the specified events.\n\n        This method can be used as either a decorator or a context manager. When used as a\n        decorator, it automatically subscribes the decorated callback to the provided events.\n        When used as a context manager with the `with` statement, it allows multiple callbacks\n        to be associated with the provided events within the context block.\n\n        :param events: The events to subscribe to.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n            If `True`, synchronous callbacks will be converted to run asynchronously in a\n            thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n            will run synchronously or asynchronously as defined.\n        :param stateful_subctx: A flag indicating whether the subscription context preserves its state\n            (`stateful`) or not (`stateless`) after exiting the subscription block. If `True`, the context retains\n            its state, allowing access to stored objects, including the `event linker` and the `subscriber` object.\n            If `False`, the context is stateless, and the stored state is cleared upon exiting the subscription\n            block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n        :return: A `EventLinkerSubCtx` instance.\n        \"\"\"\n        return EventLinker.EventLinkerSubCtx[type[Self]](\n            events=events, event_linker=cls, force_async=force_async, once=False, is_stateful=stateful_subctx\n        )\n\n    @classmethod\n    def subscribe(\n        cls,\n        *events: SubscribableEventType,\n        event_callback: EventCallbackType,\n        success_callback: SuccessCallbackType | None = None,\n        failure_callback: FailureCallbackType | None = None,\n        force_async: bool = False,\n        once: bool = False,\n    ) -&gt; EventSubscriber:\n        \"\"\"\n        Subscribe the specified callbacks to the given events.\n\n        :param events: The events to subscribe to.\n        :param event_callback: The callback to be executed when the event occurs.\n        :param success_callback: The callback to be executed when the event response completes successfully.\n        :param failure_callback: The callback to be executed when the event response fails.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n            If `True`, synchronous callbacks will be converted to run asynchronously in a\n            thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n            will run synchronously or asynchronously as defined.\n        :param once: Specifies if the subscriber will be a one-time subscriber.\n        :return: The subscriber associated with the given events.\n        \"\"\"\n        # Validate and retrieve all unique event names\n        unique_events: set[str] = cls._get_valid_and_unique_event_names(events)\n\n        # Acquire the lock to ensure exclusive access to the main registry\n        with cls.__thread_lock:\n            # Check if the maximum number of subscribers is set\n            if cls.__max_subscribers is not None:\n                # For each event name, check if the maximum number\n                # of subscribers for the event has been exceeded\n                for event in unique_events:\n                    if cls.__registry.get_value_count_from_key(event) &gt;= cls.__max_subscribers:\n                        raise PyventusException(\n                            f\"The event '{event}' has exceeded the maximum number of subscribers allowed.\"\n                        )\n\n            # Create a new event subscriber\n            subscriber: EventSubscriber = EventSubscriber(\n                teardown_callback=cls.remove_subscriber,\n                event_callback=event_callback,\n                success_callback=success_callback if success_callback else cls.__default_success_callback,\n                failure_callback=failure_callback if failure_callback else cls.__default_failure_callback,\n                force_async=force_async,\n                once=once,\n            )\n\n            # Register the subscriber for each unique event\n            for event in unique_events:\n                cls.__registry.insert(event, subscriber)\n\n        # Log the subscription if debug is enabled\n        if cls.__logger.debug_enabled:\n            cls.__logger.debug(\n                action=\"Subscribed:\", msg=f\"{subscriber} {StdOutColors.PURPLE_TEXT('Events:')} {unique_events}\"\n            )\n\n        # Return the new event subscriber\n        return subscriber\n\n    @classmethod\n    def remove(cls, event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool:\n        \"\"\"\n        Remove the specified subscriber from the given event.\n\n        :param event: The event from which the subscriber will be removed.\n        :param subscriber: The subscriber to be removed from the event.\n        :return: `True` if the subscriber was successfully removed; `False` if\n            no removal occurred due to the event or subscriber not being registered,\n            or if they are not linked.\n        \"\"\"\n        # Validate the given event and subscriber\n        valid_event: str = cls.get_valid_event_name(event)\n        valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n\n        # Acquire lock to ensure thread safety\n        with cls.__thread_lock:\n            # Check if the event and subscriber are registered and linked\n            if not cls.__registry.are_associated(valid_event, valid_subscriber):\n                return False\n\n            # Remove the subscriber from the event\n            cls.__registry.remove(valid_event, valid_subscriber)\n\n        # Log the removal if the debug mode is enabled\n        if cls.__logger.debug_enabled:\n            cls.__logger.debug(\n                action=\"Removed:\", msg=f\"{valid_subscriber} {StdOutColors.PURPLE_TEXT('Event:')} '{valid_event}'\"\n            )\n\n        return True\n\n    @classmethod\n    def remove_event(cls, event: SubscribableEventType) -&gt; bool:\n        \"\"\"\n        Remove the specified event from the registry.\n\n        :param event: The event to be removed from the registry.\n        :return: `True` if the event was successfully removed; `False`\n            if the event was not found in the registry.\n        \"\"\"\n        # Get the valid event name\n        valid_event: str = cls.get_valid_event_name(event)\n\n        # Acquire lock to ensure thread safety\n        with cls.__thread_lock:\n            # Check if the event is registered; return False if not\n            if not cls.__registry.contains_key(valid_event):\n                return False\n\n            # Remove the event from the registry\n            cls.__registry.remove_key(valid_event)\n\n        # Log the removal if the debug mode is enabled\n        if cls.__logger.debug_enabled:\n            cls.__logger.debug(action=\"Removed:\", msg=f\"Event: '{valid_event}'\")\n\n        return True\n\n    @classmethod\n    def remove_subscriber(cls, subscriber: EventSubscriber) -&gt; bool:\n        \"\"\"\n        Remove the specified subscriber from the registry.\n\n        :param subscriber: The subscriber to be removed from the registry.\n        :return: `True` if the subscriber was successfully removed; `False` if\n            the subscriber was not found in the registry.\n        \"\"\"\n        # Get the valid subscriber instance\n        valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n\n        # Acquire lock to ensure thread safety\n        with cls.__thread_lock:\n            # Check if the subscriber is registered; return False if not\n            if not cls.__registry.contains_value(valid_subscriber):\n                return False\n\n            # Remove the subscriber from the registry\n            cls.__registry.remove_value(valid_subscriber)\n\n        # Log the removal if the debug mode is enabled\n        if cls.__logger.debug_enabled:\n            cls.__logger.debug(action=\"Removed:\", msg=f\"{valid_subscriber}\")\n\n        return True\n\n    @classmethod\n    def remove_all(cls) -&gt; bool:\n        \"\"\"\n        Remove all events and subscribers from the registry.\n\n        :return: `True` if the registry was successfully cleared; `False`\n            if the registry was already empty.\n        \"\"\"\n        # Acquire lock to ensure thread safety\n        with cls.__thread_lock:\n            # Check if the registry is already empty\n            if cls.__registry.is_empty:\n                return False\n\n            # Clear the registry\n            cls.__registry.clear()\n\n        if cls.__logger.debug_enabled:\n            cls.__logger.debug(action=\"Removed:\", msg=\"All events and subscribers.\")\n\n        return True\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker-classes","title":"Classes","text":""},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx","title":"EventLinkerSubCtx","text":"<p>               Bases: <code>Generic[_SubCtxE]</code>, <code>SubscriptionContext[_SubCtxE, EventSubscriber]</code></p> <p>A context manager for event linker subscriptions.</p> <p>Notes:</p> <ul> <li> <p>This class establishes a context block for a step-by-step definition of event responses     prior to the actual subscription, which occurs immediately upon exiting the context block.</p> </li> <li> <p>This class can be used as either a decorator or a context manager. When used as a     decorator, it automatically subscribes the decorated callback to the specified events.     When used as a context manager with the <code>with</code> statement, it allows multiple callbacks     to be associated with the specified events within the context block.</p> </li> <li> <p>This subscription context can be <code>stateful</code>, retaining references to the <code>event linker</code>     and <code>subscriber</code>, or <code>stateless</code>, which clears the context upon exiting the subscription     block.</p> </li> <li> <p>This class is not intended to be subclassed or manually instantiated.</p> </li> </ul> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@final\nclass EventLinkerSubCtx(Generic[_SubCtxE], SubscriptionContext[_SubCtxE, EventSubscriber]):\n    \"\"\"\n    A context manager for event linker subscriptions.\n\n    **Notes:**\n\n    -   This class establishes a context block for a step-by-step definition of event responses\n        prior to the actual subscription, which occurs immediately upon exiting the context block.\n\n    -   This class can be used as either a decorator or a context manager. When used as a\n        decorator, it automatically subscribes the decorated callback to the specified events.\n        When used as a context manager with the `with` statement, it allows multiple callbacks\n        to be associated with the specified events within the context block.\n\n    -   This subscription context can be `stateful`, retaining references to the `event linker`\n        and `subscriber`, or `stateless`, which clears the context upon exiting the subscription\n        block.\n\n    -   This class is not intended to be subclassed or manually instantiated.\n    \"\"\"\n\n    # Attributes for the EventLinkerSubCtx\n    __slots__ = (\n        \"__events\",\n        \"__event_callback\",\n        \"__success_callback\",\n        \"__failure_callback\",\n        \"__force_async\",\n        \"__once\",\n    )\n\n    def __init__(\n        self,\n        events: tuple[SubscribableEventType, ...],\n        event_linker: _SubCtxE,\n        force_async: bool,\n        once: bool,\n        is_stateful: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `EventLinkerSubCtx`.\n\n        :param events: The events to subscribe/link to.\n        :param event_linker: The type of event linker used for the actual subscription.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n        :param once: Specifies if the event subscriber will be a one-time subscription.\n        :param is_stateful: A flag indicating whether the context preserves its state (stateful) or\n            not (stateless) after exiting the subscription context. If `True`, the context retains its\n            state, allowing access to stored objects, including the `event linker` and the `subscriber`\n            object. If `False`, the context is stateless, and the stored state is cleared upon exiting\n            the subscription context to prevent memory leaks.\n        \"\"\"\n        # Initialize the base SubscriptionContext class\n        super().__init__(source=event_linker, is_stateful=is_stateful)\n\n        # Initialize variables\n        self.__events: tuple[SubscribableEventType, ...] = events\n        self.__event_callback: EventCallbackType | None = None\n        self.__success_callback: SuccessCallbackType | None = None\n        self.__failure_callback: FailureCallbackType | None = None\n        self.__force_async: bool = force_async\n        self.__once: bool = once\n\n    @override\n    def _exit(self) -&gt; EventSubscriber:\n        # Ensure that the source is not None\n        if self._source is None:  # pragma: no cover\n            raise PyventusException(\"The subscription context is closed.\")\n\n        # Check if the event callback has been set\n        if self.__event_callback is None:\n            raise PyventusException(\"The event callback has not been set.\")\n\n        # Subscribe the defined callbacks to the\n        # specified events and store the returned subscriber.\n        subscriber: EventSubscriber = self._source.subscribe(\n            *self.__events,\n            event_callback=self.__event_callback,\n            success_callback=self.__success_callback,\n            failure_callback=self.__failure_callback,\n            force_async=self.__force_async,\n            once=self.__once,\n        )\n\n        # Remove context-specific attributes to clean up\n        # and prevent memory leaks.\n        del self.__events\n        del self.__event_callback, self.__success_callback, self.__failure_callback\n        del self.__force_async, self.__once\n\n        # Return the subscriber\n        return subscriber\n\n    def on_event(self, callback: EventCallbackType) -&gt; EventCallbackType:\n        \"\"\"\n        Set the main callback for the event.\n\n        :param callback: The callback to be executed when the event occurs.\n        :return: The decorated callback.\n        \"\"\"\n        self.__event_callback = callback\n        return callback\n\n    def on_success(self, callback: SuccessCallbackType) -&gt; SuccessCallbackType:\n        \"\"\"\n        Set the success callback for the event.\n\n        :param callback: The callback to be executed when the event response completes successfully.\n        :return: The decorated callback.\n        \"\"\"\n        self.__success_callback = callback\n        return callback\n\n    def on_failure(self, callback: FailureCallbackType) -&gt; FailureCallbackType:\n        \"\"\"\n        Set the failure callback for the event.\n\n        :param callback: The callback to be executed when the event response fails.\n        :return: The decorated callback.\n        \"\"\"\n        self.__failure_callback = callback\n        return callback\n\n    def __call__(\n        self, callback: EventCallbackType\n    ) -&gt; tuple[EventCallbackType, \"EventLinker.EventLinkerSubCtx[_SubCtxE]\"] | EventCallbackType:\n        \"\"\"\n        Subscribe the decorated callback to the specified events.\n\n        :param callback: The callback to be executed when the event occurs.\n        :return: A tuple containing the decorated callback and its subscription context\n            if the context is stateful; otherwise, returns the decorated callback alone.\n        \"\"\"\n        # Store the provided callback as the event callback\n        self.__event_callback = callback\n\n        # Set success and failure callbacks to None\n        self.__success_callback = None\n        self.__failure_callback = None\n\n        # Determine if the subscription context is stateful\n        is_stateful: bool = self._is_stateful\n\n        # Call the exit method to finalize the\n        # subscription process and clean up any necessary context.\n        self.__exit__(None, None, None)\n\n        # Return a tuple containing the decorated callback\n        # and the current subscription context if the context\n        # is stateful; otherwise, return just the callback.\n        return (callback, self) if is_stateful else callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx-functions","title":"Functions","text":""},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.unpack","title":"unpack","text":"<pre><code>unpack() -&gt; tuple[_SourceType | None, _SubscriberType | None]\n</code></pre> <p>Unpack and retrieve the source object and its associated subscriber.</p> <p>This method returns a tuple containing the source object and its subscriber, while also handling the cleanup of associated resources to prevent memory leaks. After retrieving the objects, it deletes internal references to the source and subscriber to ensure they are no longer retained.</p> RETURNS DESCRIPTION <code>tuple[_SourceType | None, _SubscriberType | None]</code> <p>A tuple of the form (source, subscriber). Both may be <code>None</code> if the subscription context has either unpacked the state previously or is stateless.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If this method is called before or during the subscription context, indicating that the resources are not yet available for unpacking.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def unpack(self) -&gt; tuple[_SourceType | None, _SubscriberType | None]:\n    \"\"\"\n    Unpack and retrieve the source object and its associated subscriber.\n\n    This method returns a tuple containing the source object and its subscriber,\n    while also handling the cleanup of associated resources to prevent memory leaks.\n    After retrieving the objects, it deletes internal references to the source and\n    subscriber to ensure they are no longer retained.\n\n    :return: A tuple of the form (source, subscriber). Both may be `None` if the\n        subscription context has either unpacked the state previously or is stateless.\n    :raises PyventusException: If this method is called before or during the subscription\n        context, indicating that the resources are not yet available for unpacking.\n    \"\"\"\n    # Create a tuple with the source object and its subscriber\n    results: tuple[_SourceType | None, _SubscriberType | None] = (self._source, self._subscriber)\n\n    # Perform cleanup by deleting unnecessary references\n    if results[0]:\n        del self.__source\n    if results[1]:\n        del self.__subscriber\n\n    return results\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the subscription context block.</p> <p>This method facilitates the progressive definition of an object that will later be subscribed to the specified source.</p> RETURNS DESCRIPTION <code>Self</code> <p>The subscription context manager.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __enter__(self: Self) -&gt; Self:\n    \"\"\"\n    Enter the subscription context block.\n\n    This method facilitates the progressive definition of an\n    object that will later be subscribed to the specified source.\n\n    :return: The subscription context manager.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None\n</code></pre> <p>Exit the subscription context block.</p> <p>This method subscribes the defined object to the specified source, and performs any necessary cleanup.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the raised exception, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The raised exception object, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback information, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Exit the subscription context block.\n\n    This method subscribes the defined object to the\n    specified source, and performs any necessary cleanup.\n\n    :param exc_type: The type of the raised exception, if any.\n    :param exc_val: The raised exception object, if any.\n    :param exc_tb: The traceback information, if any.\n    :return: None.\n    \"\"\"\n    # Finalize the subscription and retrieve the subscriber\n    subscriber: _SubscriberType = self._exit()\n\n    # Ensure the subscriber is valid\n    if subscriber is None:  # pragma: no cover\n        raise PyventusException(\"The 'subscriber' argument cannot be None.\")\n\n    # Check if a subscriber has already been set to avoid an override\n    if self.__subscriber:  # pragma: no cover\n        raise PyventusException(\"A 'subscriber' has already been set.\")\n\n    if self.__is_stateful:\n        # Retain the subscriber if the context is stateful\n        self.__subscriber = subscriber\n    else:\n        # Remove context-specific references if stateless\n        del self.__source, self.__subscriber\n\n    # Remove the stateful context flag\n    del self.__is_stateful\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.__init__","title":"__init__","text":"<pre><code>__init__(events: tuple[SubscribableEventType, ...], event_linker: _SubCtxE, force_async: bool, once: bool, is_stateful: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>EventLinkerSubCtx</code>.</p> PARAMETER DESCRIPTION <code>events</code> <p>The events to subscribe/link to.</p> <p> TYPE: <code>tuple[SubscribableEventType, ...]</code> </p> <code>event_linker</code> <p>The type of event linker used for the actual subscription.</p> <p> TYPE: <code>_SubCtxE</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously.</p> <p> TYPE: <code>bool</code> </p> <code>once</code> <p>Specifies if the event subscriber will be a one-time subscription.</p> <p> TYPE: <code>bool</code> </p> <code>is_stateful</code> <p>A flag indicating whether the context preserves its state (stateful) or not (stateless) after exiting the subscription context. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>event linker</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription context to prevent memory leaks.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def __init__(\n    self,\n    events: tuple[SubscribableEventType, ...],\n    event_linker: _SubCtxE,\n    force_async: bool,\n    once: bool,\n    is_stateful: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `EventLinkerSubCtx`.\n\n    :param events: The events to subscribe/link to.\n    :param event_linker: The type of event linker used for the actual subscription.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n    :param once: Specifies if the event subscriber will be a one-time subscription.\n    :param is_stateful: A flag indicating whether the context preserves its state (stateful) or\n        not (stateless) after exiting the subscription context. If `True`, the context retains its\n        state, allowing access to stored objects, including the `event linker` and the `subscriber`\n        object. If `False`, the context is stateless, and the stored state is cleared upon exiting\n        the subscription context to prevent memory leaks.\n    \"\"\"\n    # Initialize the base SubscriptionContext class\n    super().__init__(source=event_linker, is_stateful=is_stateful)\n\n    # Initialize variables\n    self.__events: tuple[SubscribableEventType, ...] = events\n    self.__event_callback: EventCallbackType | None = None\n    self.__success_callback: SuccessCallbackType | None = None\n    self.__failure_callback: FailureCallbackType | None = None\n    self.__force_async: bool = force_async\n    self.__once: bool = once\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.on_event","title":"on_event","text":"<pre><code>on_event(callback: EventCallbackType) -&gt; EventCallbackType\n</code></pre> <p>Set the main callback for the event.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the event occurs.</p> <p> TYPE: <code>EventCallbackType</code> </p> RETURNS DESCRIPTION <code>EventCallbackType</code> <p>The decorated callback.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def on_event(self, callback: EventCallbackType) -&gt; EventCallbackType:\n    \"\"\"\n    Set the main callback for the event.\n\n    :param callback: The callback to be executed when the event occurs.\n    :return: The decorated callback.\n    \"\"\"\n    self.__event_callback = callback\n    return callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.on_success","title":"on_success","text":"<pre><code>on_success(callback: SuccessCallbackType) -&gt; SuccessCallbackType\n</code></pre> <p>Set the success callback for the event.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the event response completes successfully.</p> <p> TYPE: <code>SuccessCallbackType</code> </p> RETURNS DESCRIPTION <code>SuccessCallbackType</code> <p>The decorated callback.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def on_success(self, callback: SuccessCallbackType) -&gt; SuccessCallbackType:\n    \"\"\"\n    Set the success callback for the event.\n\n    :param callback: The callback to be executed when the event response completes successfully.\n    :return: The decorated callback.\n    \"\"\"\n    self.__success_callback = callback\n    return callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.on_failure","title":"on_failure","text":"<pre><code>on_failure(callback: FailureCallbackType) -&gt; FailureCallbackType\n</code></pre> <p>Set the failure callback for the event.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the event response fails.</p> <p> TYPE: <code>FailureCallbackType</code> </p> RETURNS DESCRIPTION <code>FailureCallbackType</code> <p>The decorated callback.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def on_failure(self, callback: FailureCallbackType) -&gt; FailureCallbackType:\n    \"\"\"\n    Set the failure callback for the event.\n\n    :param callback: The callback to be executed when the event response fails.\n    :return: The decorated callback.\n    \"\"\"\n    self.__failure_callback = callback\n    return callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.EventLinkerSubCtx.__call__","title":"__call__","text":"<pre><code>__call__(callback: EventCallbackType) -&gt; tuple[EventCallbackType, EventLinkerSubCtx[_SubCtxE]] | EventCallbackType\n</code></pre> <p>Subscribe the decorated callback to the specified events.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the event occurs.</p> <p> TYPE: <code>EventCallbackType</code> </p> RETURNS DESCRIPTION <code>tuple[EventCallbackType, EventLinkerSubCtx[_SubCtxE]] | EventCallbackType</code> <p>A tuple containing the decorated callback and its subscription context if the context is stateful; otherwise, returns the decorated callback alone.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def __call__(\n    self, callback: EventCallbackType\n) -&gt; tuple[EventCallbackType, \"EventLinker.EventLinkerSubCtx[_SubCtxE]\"] | EventCallbackType:\n    \"\"\"\n    Subscribe the decorated callback to the specified events.\n\n    :param callback: The callback to be executed when the event occurs.\n    :return: A tuple containing the decorated callback and its subscription context\n        if the context is stateful; otherwise, returns the decorated callback alone.\n    \"\"\"\n    # Store the provided callback as the event callback\n    self.__event_callback = callback\n\n    # Set success and failure callbacks to None\n    self.__success_callback = None\n    self.__failure_callback = None\n\n    # Determine if the subscription context is stateful\n    is_stateful: bool = self._is_stateful\n\n    # Call the exit method to finalize the\n    # subscription process and clean up any necessary context.\n    self.__exit__(None, None, None)\n\n    # Return a tuple containing the decorated callback\n    # and the current subscription context if the context\n    # is stateful; otherwise, return just the callback.\n    return (callback, self) if is_stateful else callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker-functions","title":"Functions","text":""},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.__init_subclass__","title":"__init_subclass__","text":"<pre><code>__init_subclass__(max_subscribers: int | None = None, default_success_callback: SuccessCallbackType | None = None, default_failure_callback: FailureCallbackType | None = None, debug: bool | None = None) -&gt; None\n</code></pre> <p>Initialize a subclass of <code>EventLinker</code>.</p> <p>By default, this method sets up the main registry and the thread lock object, but it can also be used to configure specific settings of the <code>EventLinker</code> subclass.</p> PARAMETER DESCRIPTION <code>max_subscribers</code> <p>The maximum number of subscribers allowed per event, or <code>None</code> if there is no limit.</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>default_success_callback</code> <p>The default callback to assign as the success callback in the subscribers when no specific success callback is provided.</p> <p> TYPE: <code>SuccessCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>default_failure_callback</code> <p>The default callback to assign as the failure callback in the subscribers when no specific failure callback is provided.</p> <p> TYPE: <code>FailureCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>debug</code> <p>Specifies the debug mode for the subclass logger. If <code>None</code>, it is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If <code>max_subscribers</code> is less than 1 or if the provided callbacks are invalid.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>def __init_subclass__(\n    cls,\n    max_subscribers: int | None = None,\n    default_success_callback: SuccessCallbackType | None = None,\n    default_failure_callback: FailureCallbackType | None = None,\n    debug: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize a subclass of `EventLinker`.\n\n    By default, this method sets up the main registry and the thread lock object, but\n    it can also be used to configure specific settings of the `EventLinker` subclass.\n\n    :param max_subscribers: The maximum number of subscribers allowed per event, or `None` if there is no limit.\n    :param default_success_callback: The default callback to assign as the success callback in the subscribers\n        when no specific success callback is provided.\n    :param default_failure_callback: The default callback to assign as the failure callback in the subscribers\n        when no specific failure callback is provided.\n    :param debug: Specifies the debug mode for the subclass logger. If `None`, it is determined based\n        on the execution environment.\n    :raises PyventusException: If `max_subscribers` is less than 1 or if the provided\n        callbacks are invalid.\n    :return: None.\n    \"\"\"\n    # Initialize the main registry\n    cls.__registry = MultiBidict[str, EventSubscriber]()\n\n    # Create a lock object for thread synchronization\n    cls.__thread_lock = Lock()\n\n    # Validate the max_subscribers argument\n    if max_subscribers is not None and max_subscribers &lt; 1:\n        raise PyventusException(\"The 'max_subscribers' argument must be greater than or equal to 1.\")\n\n    # Set the maximum number of subscribers per event\n    cls.__max_subscribers = max_subscribers\n\n    # Validate the default success callback, if any\n    if default_success_callback is not None:\n        validate_callable(default_success_callback)\n\n    # Set the default success callback\n    cls.__default_success_callback = default_success_callback\n\n    # Validate the default failure callback, if any\n    if default_failure_callback is not None:\n        validate_callable(default_failure_callback)\n\n    # Set the default failure callback\n    cls.__default_failure_callback = default_failure_callback\n\n    # Validate the debug argument\n    if debug is not None and not isinstance(debug, bool):\n        raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n    # Set up the logger\n    cls.__logger = Logger(source=cls, debug=debug if debug is not None else bool(gettrace() is not None))\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_valid_event_name","title":"get_valid_event_name  <code>classmethod</code>","text":"<pre><code>get_valid_event_name(event: SubscribableEventType) -&gt; str\n</code></pre> <p>Determine the name of the event and performs validation.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to obtain the name for.</p> <p> TYPE: <code>SubscribableEventType</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string that represents the event name.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the <code>event</code> argument is invalid or if the event is not supported.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_valid_event_name(cls, event: SubscribableEventType) -&gt; str:\n    \"\"\"\n    Determine the name of the event and performs validation.\n\n    :param event: The event to obtain the name for.\n    :return: A string that represents the event name.\n    :raises PyventusException: If the `event` argument is invalid\n        or if the event is not supported.\n    \"\"\"\n    # Validate the event argument\n    if event is None:\n        raise PyventusException(\"The 'event' argument cannot be None.\")\n\n    if event is Ellipsis:\n        # If the event is Ellipsis, return its type name\n        return type(event).__name__\n    elif isinstance(event, str):\n        if not event:\n            raise PyventusException(\"String events cannot be empty.\")\n        # If the event is a non-empty string, return it as the event name\n        return event\n    elif isinstance(event, type):\n        if not is_dataclass(event) and not issubclass(event, Exception):\n            raise PyventusException(\"Type events must be either a dataclass or an exception.\")\n        # If the event is either a dataclass type or an exception type, return its type name\n        return event.__name__\n    else:\n        # If the event is not supported, raise an exception\n        raise PyventusException(\"Unsupported event\")\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_valid_subscriber","title":"get_valid_subscriber  <code>classmethod</code>","text":"<pre><code>get_valid_subscriber(subscriber: EventSubscriber) -&gt; EventSubscriber\n</code></pre> <p>Validate and return the specified subscriber.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to validate.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>EventSubscriber</code> <p>The validated subscriber.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the subscriber is not an instance of <code>EventSubscriber</code>.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_valid_subscriber(cls, subscriber: EventSubscriber) -&gt; EventSubscriber:\n    \"\"\"\n    Validate and return the specified subscriber.\n\n    :param subscriber: The subscriber to validate.\n    :return: The validated subscriber.\n    :raises PyventusException: If the subscriber is not an instance of `EventSubscriber`.\n    \"\"\"\n    # Validate that the subscriber is an instance of EventSubscriber\n    if not isinstance(subscriber, EventSubscriber):\n        raise PyventusException(\"The 'subscriber' argument must be an instance of EventSubscriber.\")\n    return subscriber\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_max_subscribers","title":"get_max_subscribers  <code>classmethod</code>","text":"<pre><code>get_max_subscribers() -&gt; int | None\n</code></pre> <p>Retrieve the maximum number of subscribers allowed per event.</p> RETURNS DESCRIPTION <code>int | None</code> <p>The maximum number of subscribers or <code>None</code> if there is no limit.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_max_subscribers(cls) -&gt; int | None:\n    \"\"\"\n    Retrieve the maximum number of subscribers allowed per event.\n\n    :return: The maximum number of subscribers or `None` if there is no limit.\n    \"\"\"\n    return cls.__max_subscribers\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_default_success_callback","title":"get_default_success_callback  <code>classmethod</code>","text":"<pre><code>get_default_success_callback() -&gt; SuccessCallbackType | None\n</code></pre> <p>Retrieve the default success callback to assign to subscribers when no specific callback is provided.</p> RETURNS DESCRIPTION <code>SuccessCallbackType | None</code> <p>The default success callback or <code>None</code> if not set.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_default_success_callback(cls) -&gt; SuccessCallbackType | None:\n    \"\"\"\n    Retrieve the default success callback to assign to subscribers when no specific callback is provided.\n\n    :return: The default success callback or `None` if not set.\n    \"\"\"\n    return cls.__default_success_callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_default_failure_callback","title":"get_default_failure_callback  <code>classmethod</code>","text":"<pre><code>get_default_failure_callback() -&gt; FailureCallbackType | None\n</code></pre> <p>Retrieve the default failure callback to assign to subscribers when no specific callback is provided.</p> RETURNS DESCRIPTION <code>FailureCallbackType | None</code> <p>The default failure callback or <code>None</code> if not set.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_default_failure_callback(cls) -&gt; FailureCallbackType | None:\n    \"\"\"\n    Retrieve the default failure callback to assign to subscribers when no specific callback is provided.\n\n    :return: The default failure callback or `None` if not set.\n    \"\"\"\n    return cls.__default_failure_callback\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.is_empty","title":"is_empty  <code>classmethod</code>","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Determine whether the main registry is empty.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the main registry is empty, <code>False</code> otherwise.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef is_empty(cls) -&gt; bool:\n    \"\"\"\n    Determine whether the main registry is empty.\n\n    :return: `True` if the main registry is empty, `False` otherwise.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.is_empty\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_registry","title":"get_registry  <code>classmethod</code>","text":"<pre><code>get_registry() -&gt; dict[str, set[EventSubscriber]]\n</code></pre> <p>Retrieve a shallow copy of the main registry.</p> RETURNS DESCRIPTION <code>dict[str, set[EventSubscriber]]</code> <p>A shallow copy of the main registry, where each event is mapped to a set of its linked subscribers.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_registry(cls) -&gt; dict[str, set[EventSubscriber]]:\n    \"\"\"\n    Retrieve a shallow copy of the main registry.\n\n    :return: A shallow copy of the main registry, where each\n        event is mapped to a set of its linked subscribers.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.to_dict()\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_events","title":"get_events  <code>classmethod</code>","text":"<pre><code>get_events() -&gt; set[str]\n</code></pre> <p>Retrieve all registered events.</p> RETURNS DESCRIPTION <code>set[str]</code> <p>A set of all registered event names.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_events(cls) -&gt; set[str]:\n    \"\"\"\n    Retrieve all registered events.\n\n    :return: A set of all registered event names.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.keys\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_subscribers","title":"get_subscribers  <code>classmethod</code>","text":"<pre><code>get_subscribers() -&gt; set[EventSubscriber]\n</code></pre> <p>Retrieve all registered subscribers.</p> RETURNS DESCRIPTION <code>set[EventSubscriber]</code> <p>A set of all registered subscribers.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_subscribers(cls) -&gt; set[EventSubscriber]:\n    \"\"\"\n    Retrieve all registered subscribers.\n\n    :return: A set of all registered subscribers.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.values\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_event_count","title":"get_event_count  <code>classmethod</code>","text":"<pre><code>get_event_count() -&gt; int\n</code></pre> <p>Retrieve the number of registered events.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of events in the registry.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_event_count(cls) -&gt; int:\n    \"\"\"\n    Retrieve the number of registered events.\n\n    :return: The total count of events in the registry.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.key_count\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_subscriber_count","title":"get_subscriber_count  <code>classmethod</code>","text":"<pre><code>get_subscriber_count() -&gt; int\n</code></pre> <p>Retrieve the number of registered subscribers.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of subscribers in the registry.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_subscriber_count(cls) -&gt; int:\n    \"\"\"\n    Retrieve the number of registered subscribers.\n\n    :return: The total count of subscribers in the registry.\n    \"\"\"\n    with cls.__thread_lock:\n        return cls.__registry.value_count\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_events_from_subscribers","title":"get_events_from_subscribers  <code>classmethod</code>","text":"<pre><code>get_events_from_subscribers(*subscribers: EventSubscriber) -&gt; set[str]\n</code></pre> <p>Retrieve a set of events associated with the specified subscribers.</p> PARAMETER DESCRIPTION <code>subscribers</code> <p>One or more subscribers for which to retrieve associated events.</p> <p> TYPE: <code>EventSubscriber</code> DEFAULT: <code>()</code> </p> RETURNS DESCRIPTION <code>set[str]</code> <p>A set of events linked to the specified subscribers. Unregistered subscribers are ignored.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_events_from_subscribers(cls, *subscribers: EventSubscriber) -&gt; set[str]:\n    \"\"\"\n    Retrieve a set of events associated with the specified subscribers.\n\n    :param subscribers: One or more subscribers for which to retrieve associated events.\n    :return: A set of events linked to the specified subscribers. Unregistered subscribers are ignored.\n    \"\"\"\n    # Validate and retrieve all unique subscribers to avoid duplicate processing\n    unique_subscribers: set[EventSubscriber] = cls._get_valid_and_unique_subscribers(subscribers)\n\n    # Return the set of event names associated with the unique subscribers\n    with cls.__thread_lock:\n        return cls.__registry.get_keys_from_values(unique_subscribers)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_subscribers_from_events","title":"get_subscribers_from_events  <code>classmethod</code>","text":"<pre><code>get_subscribers_from_events(*events: SubscribableEventType, pop_onetime_subscribers: bool = False) -&gt; set[EventSubscriber]\n</code></pre> <p>Retrieve a set of subscribers associated with the specified events.</p> PARAMETER DESCRIPTION <code>events</code> <p>One or more events for which to retrieve associated subscribers.</p> <p> TYPE: <code>SubscribableEventType</code> DEFAULT: <code>()</code> </p> <code>pop_onetime_subscribers</code> <p>If <code>True</code>, removes one-time subscribers (those with the property <code>once</code> set to True) from the registry.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>set[EventSubscriber]</code> <p>A set of subscribers linked to the specified events. Unregistered events are ignored.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_subscribers_from_events(\n    cls, *events: SubscribableEventType, pop_onetime_subscribers: bool = False\n) -&gt; set[EventSubscriber]:\n    \"\"\"\n    Retrieve a set of subscribers associated with the specified events.\n\n    :param events: One or more events for which to retrieve associated subscribers.\n    :param pop_onetime_subscribers: If `True`, removes one-time subscribers (those\n        with the property `once` set to True) from the registry.\n    :return: A set of subscribers linked to the specified events. Unregistered events are ignored.\n    \"\"\"\n    # Validate and retrieve all unique event names to avoid duplicate processing\n    unique_events: set[str] = cls._get_valid_and_unique_event_names(events)\n\n    # Acquire lock to ensure thread safety\n    with cls.__thread_lock:\n        # Retrieve subscribers associated with the unique events\n        subscribers: set[EventSubscriber] = cls.__registry.get_values_from_keys(unique_events)\n\n        # Just return subscribers if pop_one_time_subscribers is False\n        if not pop_onetime_subscribers:\n            return subscribers\n\n        # Remove one-time subscribers from the registry\n        for subscriber in subscribers:\n            if subscriber.once:\n                cls.__registry.remove_value(subscriber)\n\n    # Return the set of subscribers\n    return subscribers\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_event_count_from_subscriber","title":"get_event_count_from_subscriber  <code>classmethod</code>","text":"<pre><code>get_event_count_from_subscriber(subscriber: EventSubscriber) -&gt; int\n</code></pre> <p>Retrieve the number of events associated with the given subscriber.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber for which to count the associated events.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The count of events associated with the specified subscriber, or 0 if the subscriber is not found.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_event_count_from_subscriber(cls, subscriber: EventSubscriber) -&gt; int:\n    \"\"\"\n    Retrieve the number of events associated with the given subscriber.\n\n    :param subscriber: The subscriber for which to count the associated events.\n    :return: The count of events associated with the specified subscriber,\n        or 0 if the subscriber is not found.\n    \"\"\"\n    valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n    with cls.__thread_lock:\n        return cls.__registry.get_key_count_from_value(valid_subscriber)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.get_subscriber_count_from_event","title":"get_subscriber_count_from_event  <code>classmethod</code>","text":"<pre><code>get_subscriber_count_from_event(event: SubscribableEventType) -&gt; int\n</code></pre> <p>Retrieve the number of subscribers associated with a given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event for which to count the associated subscribers.</p> <p> TYPE: <code>SubscribableEventType</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The count of subscribers associated with the specified event, or 0 if the event is not found.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef get_subscriber_count_from_event(cls, event: SubscribableEventType) -&gt; int:\n    \"\"\"\n    Retrieve the number of subscribers associated with a given event.\n\n    :param event: The event for which to count the associated subscribers.\n    :return: The count of subscribers associated with the specified event,\n        or 0 if the event is not found.\n    \"\"\"\n    valid_event: str = cls.get_valid_event_name(event)\n    with cls.__thread_lock:\n        return cls.__registry.get_value_count_from_key(valid_event)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.contains_event","title":"contains_event  <code>classmethod</code>","text":"<pre><code>contains_event(event: SubscribableEventType) -&gt; bool\n</code></pre> <p>Determine if the specified event is present in the registry.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to be checked.</p> <p> TYPE: <code>SubscribableEventType</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the event is found; <code>False</code> otherwise.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef contains_event(cls, event: SubscribableEventType) -&gt; bool:\n    \"\"\"\n    Determine if the specified event is present in the registry.\n\n    :param event: The event to be checked.\n    :return: `True` if the event is found; `False` otherwise.\n    \"\"\"\n    valid_event: str = cls.get_valid_event_name(event)\n    with cls.__thread_lock:\n        return cls.__registry.contains_key(valid_event)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.contains_subscriber","title":"contains_subscriber  <code>classmethod</code>","text":"<pre><code>contains_subscriber(subscriber: EventSubscriber) -&gt; bool\n</code></pre> <p>Determine if the specified subscriber is present in the registry.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be checked.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber is found; <code>False</code> otherwise.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef contains_subscriber(cls, subscriber: EventSubscriber) -&gt; bool:\n    \"\"\"\n    Determine if the specified subscriber is present in the registry.\n\n    :param subscriber: The subscriber to be checked.\n    :return: `True` if the subscriber is found; `False` otherwise.\n    \"\"\"\n    valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n    with cls.__thread_lock:\n        return cls.__registry.contains_value(valid_subscriber)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.are_linked","title":"are_linked  <code>classmethod</code>","text":"<pre><code>are_linked(event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool\n</code></pre> <p>Determine whether the given event is linked with the specified subscriber.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event for which the association is being checked.</p> <p> TYPE: <code>SubscribableEventType</code> </p> <code>subscriber</code> <p>The subscriber for which the association is being checked.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber is linked to the event; <code>False</code> otherwise.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef are_linked(cls, event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool:\n    \"\"\"\n    Determine whether the given event is linked with the specified subscriber.\n\n    :param event: The event for which the association is being checked.\n    :param subscriber: The subscriber for which the association is being checked.\n    :return: `True` if the subscriber is linked to the event; `False` otherwise.\n    \"\"\"\n    valid_event: str = cls.get_valid_event_name(event)\n    valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n    with cls.__thread_lock:\n        return cls.__registry.are_associated(valid_event, valid_subscriber)\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.once","title":"once  <code>classmethod</code>","text":"<pre><code>once(*events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False) -&gt; EventLinkerSubCtx[type[Self]]\n</code></pre> <p>Subscribe callbacks to the specified events for a single invocation.</p> <p>This method can be used as either a decorator or a context manager. When used as a decorator, it automatically subscribes the decorated callback to the provided events. When used as a context manager with the <code>with</code> statement, it allows multiple callbacks to be associated with the provided events within the context block.</p> PARAMETER DESCRIPTION <code>events</code> <p>The events to subscribe to.</p> <p> TYPE: <code>SubscribableEventType</code> DEFAULT: <code>()</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously. If <code>True</code>, synchronous callbacks will be converted to run asynchronously in a thread pool, using the <code>asyncio.to_thread</code> function. If <code>False</code>, callbacks will run synchronously or asynchronously as defined.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>stateful_subctx</code> <p>A flag indicating whether the subscription context preserves its state (<code>stateful</code>) or not (<code>stateless</code>) after exiting the subscription block. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>event linker</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>EventLinkerSubCtx[type[Self]]</code> <p>A <code>EventLinkerSubCtx</code> instance.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef once(\n    cls, *events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False\n) -&gt; EventLinkerSubCtx[type[Self]]:\n    \"\"\"\n    Subscribe callbacks to the specified events for a single invocation.\n\n    This method can be used as either a decorator or a context manager. When used as a\n    decorator, it automatically subscribes the decorated callback to the provided events.\n    When used as a context manager with the `with` statement, it allows multiple callbacks\n    to be associated with the provided events within the context block.\n\n    :param events: The events to subscribe to.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n        If `True`, synchronous callbacks will be converted to run asynchronously in a\n        thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n        will run synchronously or asynchronously as defined.\n    :param stateful_subctx: A flag indicating whether the subscription context preserves its state\n        (`stateful`) or not (`stateless`) after exiting the subscription block. If `True`, the context retains\n        its state, allowing access to stored objects, including the `event linker` and the `subscriber` object.\n        If `False`, the context is stateless, and the stored state is cleared upon exiting the subscription\n        block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n    :return: A `EventLinkerSubCtx` instance.\n    \"\"\"\n    return EventLinker.EventLinkerSubCtx[type[Self]](\n        events=events, event_linker=cls, force_async=force_async, once=True, is_stateful=stateful_subctx\n    )\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.on","title":"on  <code>classmethod</code>","text":"<pre><code>on(*events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False) -&gt; EventLinkerSubCtx[type[Self]]\n</code></pre> <p>Subscribe callbacks to the specified events.</p> <p>This method can be used as either a decorator or a context manager. When used as a decorator, it automatically subscribes the decorated callback to the provided events. When used as a context manager with the <code>with</code> statement, it allows multiple callbacks to be associated with the provided events within the context block.</p> PARAMETER DESCRIPTION <code>events</code> <p>The events to subscribe to.</p> <p> TYPE: <code>SubscribableEventType</code> DEFAULT: <code>()</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously. If <code>True</code>, synchronous callbacks will be converted to run asynchronously in a thread pool, using the <code>asyncio.to_thread</code> function. If <code>False</code>, callbacks will run synchronously or asynchronously as defined.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>stateful_subctx</code> <p>A flag indicating whether the subscription context preserves its state (<code>stateful</code>) or not (<code>stateless</code>) after exiting the subscription block. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>event linker</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>EventLinkerSubCtx[type[Self]]</code> <p>A <code>EventLinkerSubCtx</code> instance.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef on(\n    cls, *events: SubscribableEventType, force_async: bool = False, stateful_subctx: bool = False\n) -&gt; EventLinkerSubCtx[type[Self]]:\n    \"\"\"\n    Subscribe callbacks to the specified events.\n\n    This method can be used as either a decorator or a context manager. When used as a\n    decorator, it automatically subscribes the decorated callback to the provided events.\n    When used as a context manager with the `with` statement, it allows multiple callbacks\n    to be associated with the provided events within the context block.\n\n    :param events: The events to subscribe to.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n        If `True`, synchronous callbacks will be converted to run asynchronously in a\n        thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n        will run synchronously or asynchronously as defined.\n    :param stateful_subctx: A flag indicating whether the subscription context preserves its state\n        (`stateful`) or not (`stateless`) after exiting the subscription block. If `True`, the context retains\n        its state, allowing access to stored objects, including the `event linker` and the `subscriber` object.\n        If `False`, the context is stateless, and the stored state is cleared upon exiting the subscription\n        block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n    :return: A `EventLinkerSubCtx` instance.\n    \"\"\"\n    return EventLinker.EventLinkerSubCtx[type[Self]](\n        events=events, event_linker=cls, force_async=force_async, once=False, is_stateful=stateful_subctx\n    )\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.subscribe","title":"subscribe  <code>classmethod</code>","text":"<pre><code>subscribe(*events: SubscribableEventType, event_callback: EventCallbackType, success_callback: SuccessCallbackType | None = None, failure_callback: FailureCallbackType | None = None, force_async: bool = False, once: bool = False) -&gt; EventSubscriber\n</code></pre> <p>Subscribe the specified callbacks to the given events.</p> PARAMETER DESCRIPTION <code>events</code> <p>The events to subscribe to.</p> <p> TYPE: <code>SubscribableEventType</code> DEFAULT: <code>()</code> </p> <code>event_callback</code> <p>The callback to be executed when the event occurs.</p> <p> TYPE: <code>EventCallbackType</code> </p> <code>success_callback</code> <p>The callback to be executed when the event response completes successfully.</p> <p> TYPE: <code>SuccessCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>failure_callback</code> <p>The callback to be executed when the event response fails.</p> <p> TYPE: <code>FailureCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously. If <code>True</code>, synchronous callbacks will be converted to run asynchronously in a thread pool, using the <code>asyncio.to_thread</code> function. If <code>False</code>, callbacks will run synchronously or asynchronously as defined.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>once</code> <p>Specifies if the subscriber will be a one-time subscriber.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>EventSubscriber</code> <p>The subscriber associated with the given events.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef subscribe(\n    cls,\n    *events: SubscribableEventType,\n    event_callback: EventCallbackType,\n    success_callback: SuccessCallbackType | None = None,\n    failure_callback: FailureCallbackType | None = None,\n    force_async: bool = False,\n    once: bool = False,\n) -&gt; EventSubscriber:\n    \"\"\"\n    Subscribe the specified callbacks to the given events.\n\n    :param events: The events to subscribe to.\n    :param event_callback: The callback to be executed when the event occurs.\n    :param success_callback: The callback to be executed when the event response completes successfully.\n    :param failure_callback: The callback to be executed when the event response fails.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n        If `True`, synchronous callbacks will be converted to run asynchronously in a\n        thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n        will run synchronously or asynchronously as defined.\n    :param once: Specifies if the subscriber will be a one-time subscriber.\n    :return: The subscriber associated with the given events.\n    \"\"\"\n    # Validate and retrieve all unique event names\n    unique_events: set[str] = cls._get_valid_and_unique_event_names(events)\n\n    # Acquire the lock to ensure exclusive access to the main registry\n    with cls.__thread_lock:\n        # Check if the maximum number of subscribers is set\n        if cls.__max_subscribers is not None:\n            # For each event name, check if the maximum number\n            # of subscribers for the event has been exceeded\n            for event in unique_events:\n                if cls.__registry.get_value_count_from_key(event) &gt;= cls.__max_subscribers:\n                    raise PyventusException(\n                        f\"The event '{event}' has exceeded the maximum number of subscribers allowed.\"\n                    )\n\n        # Create a new event subscriber\n        subscriber: EventSubscriber = EventSubscriber(\n            teardown_callback=cls.remove_subscriber,\n            event_callback=event_callback,\n            success_callback=success_callback if success_callback else cls.__default_success_callback,\n            failure_callback=failure_callback if failure_callback else cls.__default_failure_callback,\n            force_async=force_async,\n            once=once,\n        )\n\n        # Register the subscriber for each unique event\n        for event in unique_events:\n            cls.__registry.insert(event, subscriber)\n\n    # Log the subscription if debug is enabled\n    if cls.__logger.debug_enabled:\n        cls.__logger.debug(\n            action=\"Subscribed:\", msg=f\"{subscriber} {StdOutColors.PURPLE_TEXT('Events:')} {unique_events}\"\n        )\n\n    # Return the new event subscriber\n    return subscriber\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.remove","title":"remove  <code>classmethod</code>","text":"<pre><code>remove(event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool\n</code></pre> <p>Remove the specified subscriber from the given event.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event from which the subscriber will be removed.</p> <p> TYPE: <code>SubscribableEventType</code> </p> <code>subscriber</code> <p>The subscriber to be removed from the event.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber was successfully removed; <code>False</code> if no removal occurred due to the event or subscriber not being registered, or if they are not linked.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef remove(cls, event: SubscribableEventType, subscriber: EventSubscriber) -&gt; bool:\n    \"\"\"\n    Remove the specified subscriber from the given event.\n\n    :param event: The event from which the subscriber will be removed.\n    :param subscriber: The subscriber to be removed from the event.\n    :return: `True` if the subscriber was successfully removed; `False` if\n        no removal occurred due to the event or subscriber not being registered,\n        or if they are not linked.\n    \"\"\"\n    # Validate the given event and subscriber\n    valid_event: str = cls.get_valid_event_name(event)\n    valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n\n    # Acquire lock to ensure thread safety\n    with cls.__thread_lock:\n        # Check if the event and subscriber are registered and linked\n        if not cls.__registry.are_associated(valid_event, valid_subscriber):\n            return False\n\n        # Remove the subscriber from the event\n        cls.__registry.remove(valid_event, valid_subscriber)\n\n    # Log the removal if the debug mode is enabled\n    if cls.__logger.debug_enabled:\n        cls.__logger.debug(\n            action=\"Removed:\", msg=f\"{valid_subscriber} {StdOutColors.PURPLE_TEXT('Event:')} '{valid_event}'\"\n        )\n\n    return True\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.remove_event","title":"remove_event  <code>classmethod</code>","text":"<pre><code>remove_event(event: SubscribableEventType) -&gt; bool\n</code></pre> <p>Remove the specified event from the registry.</p> PARAMETER DESCRIPTION <code>event</code> <p>The event to be removed from the registry.</p> <p> TYPE: <code>SubscribableEventType</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the event was successfully removed; <code>False</code> if the event was not found in the registry.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef remove_event(cls, event: SubscribableEventType) -&gt; bool:\n    \"\"\"\n    Remove the specified event from the registry.\n\n    :param event: The event to be removed from the registry.\n    :return: `True` if the event was successfully removed; `False`\n        if the event was not found in the registry.\n    \"\"\"\n    # Get the valid event name\n    valid_event: str = cls.get_valid_event_name(event)\n\n    # Acquire lock to ensure thread safety\n    with cls.__thread_lock:\n        # Check if the event is registered; return False if not\n        if not cls.__registry.contains_key(valid_event):\n            return False\n\n        # Remove the event from the registry\n        cls.__registry.remove_key(valid_event)\n\n    # Log the removal if the debug mode is enabled\n    if cls.__logger.debug_enabled:\n        cls.__logger.debug(action=\"Removed:\", msg=f\"Event: '{valid_event}'\")\n\n    return True\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.remove_subscriber","title":"remove_subscriber  <code>classmethod</code>","text":"<pre><code>remove_subscriber(subscriber: EventSubscriber) -&gt; bool\n</code></pre> <p>Remove the specified subscriber from the registry.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be removed from the registry.</p> <p> TYPE: <code>EventSubscriber</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber was successfully removed; <code>False</code> if the subscriber was not found in the registry.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef remove_subscriber(cls, subscriber: EventSubscriber) -&gt; bool:\n    \"\"\"\n    Remove the specified subscriber from the registry.\n\n    :param subscriber: The subscriber to be removed from the registry.\n    :return: `True` if the subscriber was successfully removed; `False` if\n        the subscriber was not found in the registry.\n    \"\"\"\n    # Get the valid subscriber instance\n    valid_subscriber: EventSubscriber = cls.get_valid_subscriber(subscriber)\n\n    # Acquire lock to ensure thread safety\n    with cls.__thread_lock:\n        # Check if the subscriber is registered; return False if not\n        if not cls.__registry.contains_value(valid_subscriber):\n            return False\n\n        # Remove the subscriber from the registry\n        cls.__registry.remove_value(valid_subscriber)\n\n    # Log the removal if the debug mode is enabled\n    if cls.__logger.debug_enabled:\n        cls.__logger.debug(action=\"Removed:\", msg=f\"{valid_subscriber}\")\n\n    return True\n</code></pre>"},{"location":"api/events/linkers/event_linker/#pyventus.events.EventLinker.remove_all","title":"remove_all  <code>classmethod</code>","text":"<pre><code>remove_all() -&gt; bool\n</code></pre> <p>Remove all events and subscribers from the registry.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the registry was successfully cleared; <code>False</code> if the registry was already empty.</p> Source code in <code>pyventus/events/linkers/event_linker.py</code> <pre><code>@classmethod\ndef remove_all(cls) -&gt; bool:\n    \"\"\"\n    Remove all events and subscribers from the registry.\n\n    :return: `True` if the registry was successfully cleared; `False`\n        if the registry was already empty.\n    \"\"\"\n    # Acquire lock to ensure thread safety\n    with cls.__thread_lock:\n        # Check if the registry is already empty\n        if cls.__registry.is_empty:\n            return False\n\n        # Clear the registry\n        cls.__registry.clear()\n\n    if cls.__logger.debug_enabled:\n        cls.__logger.debug(action=\"Removed:\", msg=\"All events and subscribers.\")\n\n    return True\n</code></pre>"},{"location":"api/events/subscribers/event_subscriber/","title":"<code>EventSubscriber</code> class","text":"<p>               Bases: <code>EventHandler</code>, <code>Subscription</code></p> <p>A class that represents an <code>EventHandler</code> subscribed to an <code>EventLinker</code>.</p> <p>Notes:</p> <ul> <li> <p>This class combines the <code>EventHandler</code> interface with the <code>Subscription</code>     base class, providing a convenient way to handle events and manage the     subscription lifecycle.</p> </li> <li> <p>This class is not intended to be subclassed or instantiated directly.</p> </li> </ul> Source code in <code>pyventus/events/subscribers/event_subscriber.py</code> <pre><code>@final\nclass EventSubscriber(EventHandler, Subscription):\n    \"\"\"\n    A class that represents an `EventHandler` subscribed to an `EventLinker`.\n\n    **Notes:**\n\n    -   This class combines the `EventHandler` interface with the `Subscription`\n        base class, providing a convenient way to handle events and manage the\n        subscription lifecycle.\n\n    -   This class is not intended to be subclassed or instantiated directly.\n    \"\"\"\n\n    # Attributes for the EventSubscriber\n    __slots__ = (\"__event_callback\", \"__success_callback\", \"__failure_callback\", \"__once\")\n\n    def __init__(\n        self,\n        teardown_callback: Callable[[Self], bool],\n        event_callback: EventCallbackType,\n        success_callback: SuccessCallbackType | None,\n        failure_callback: FailureCallbackType | None,\n        force_async: bool,\n        once: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `EventSubscriber`.\n\n        :param teardown_callback: A callback function invoked during the unsubscription process to perform\n            cleanup or teardown operations associated with the subscription. It should return `True` if the\n            cleanup was successful, or `False` if the teardown has already been executed and the subscription\n            is no longer active.\n        :param event_callback: The callback to be executed when the event occurs.\n        :param success_callback: The callback to be executed when the event response completes successfully.\n        :param failure_callback: The callback to be executed when the event response fails.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n            If `True`, synchronous callbacks will be converted to run asynchronously in a\n            thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n            will run synchronously or asynchronously as defined.\n        :param once: Specifies if the event subscriber is a one-time subscription.\n        \"\"\"\n        # Initialize the base Subscription class with the teardown callback\n        super().__init__(teardown_callback=teardown_callback)\n\n        # Ensure the 'once' parameter is a boolean\n        if not isinstance(once, bool):\n            raise PyventusException(\"The 'once' argument must be a boolean value.\")\n\n        # Wrap and set the event callback\n        self.__event_callback = CallableWrapper[..., Any](event_callback, force_async=force_async)\n\n        # Ensure that the event callback is not a generator.\n        if self.__event_callback.is_generator:\n            raise PyventusException(\"The 'event_callback' cannot be a generator.\")\n\n        # Wrap and set the success callback, if provided.\n        self.__success_callback = (\n            CallableWrapper[..., None](\n                success_callback,\n                force_async=force_async,\n            )\n            if success_callback\n            else None\n        )\n\n        # Ensure that the success callback is not a generator.\n        if self.__success_callback and self.__success_callback.is_generator:\n            raise PyventusException(\"The 'success_callback' cannot be a generator.\")\n\n        # Wrap and set the failure callback, if provided.\n        self.__failure_callback = (\n            CallableWrapper[[Exception], None](\n                failure_callback,\n                force_async=force_async,\n            )\n            if failure_callback\n            else None\n        )\n\n        # Ensure that the failure callback is not a generator.\n        if self.__failure_callback and self.__failure_callback.is_generator:\n            raise PyventusException(\"The 'failure_callback' cannot be a generator.\")\n\n        # Store the one-time subscription flag.\n        self.__once: bool = once\n\n    @override\n    def __repr__(self) -&gt; str:\n        return formatted_repr(\n            instance=self,\n            info=(\n                attributes_repr(\n                    event_callback=self.__event_callback,\n                    success_callback=self.__success_callback,\n                    failure_callback=self.__failure_callback,\n                    once=self.__once,\n                )\n                + f\", {super().__repr__()}\"\n            ),\n        )\n\n    @property\n    def once(self) -&gt; bool:\n        \"\"\"\n        Determine if the event subscriber is a one-time subscription.\n\n        :return: A boolean value indicating if the event subscriber\n            is a one-time subscription.\n        \"\"\"\n        return self.__once\n\n    @override\n    async def _handle_event(self, *args: Any, **kwargs: Any) -&gt; Any:\n        # Execute the event callback with the provided arguments and return the result\n        return await self.__event_callback.execute(*args, **kwargs)\n\n    @override\n    async def _handle_success(self, results: Any) -&gt; None:\n        if self.__success_callback is None:\n            # If no success callback is set, exit early\n            return\n        elif results is None:\n            # If results are None, invoke the success callback without parameters\n            await self.__success_callback.execute()\n        else:\n            # Invoke the success callback with the given results\n            await self.__success_callback.execute(results)\n\n    @override\n    async def _handle_failure(self, exception: Exception) -&gt; None:\n        if self.__failure_callback is None:\n            # If no failure callback is set, exit early\n            return\n        else:\n            # Invoke the failure callback with the provided exception\n            await self.__failure_callback.execute(exception)\n\n    @override\n    def __getstate__(self) -&gt; dict[str, Any]:\n        # Retrieve the state of the base Subscription class\n        state: dict[str, Any] = super().__getstate__()\n\n        # Add the state of the EventSubscriber attributes\n        state[\"__event_callback\"] = self.__event_callback\n        state[\"__success_callback\"] = self.__success_callback\n        state[\"__failure_callback\"] = self.__failure_callback\n        state[\"__once\"] = self.__once\n\n        # Return the complete state for serialization\n        return state\n\n    @override\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        # Restore the state of the base Subscription class\n        super().__setstate__(state)\n\n        # Restore the state of the EventSubscriber attributes\n        self.__event_callback = state[\"__event_callback\"]\n        self.__success_callback = state[\"__success_callback\"]\n        self.__failure_callback = state[\"__failure_callback\"]\n        self.__once = state[\"__once\"]\n</code></pre>"},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber-attributes","title":"Attributes","text":""},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>Retrieve the timestamp when the subscription was created.</p> RETURNS DESCRIPTION <code>datetime</code> <p>The timestamp when the subscription was created.</p>"},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber.once","title":"once  <code>property</code>","text":"<pre><code>once: bool\n</code></pre> <p>Determine if the event subscriber is a one-time subscription.</p> RETURNS DESCRIPTION <code>bool</code> <p>A boolean value indicating if the event subscriber is a one-time subscription.</p>"},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber-functions","title":"Functions","text":""},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe() -&gt; bool\n</code></pre> Source code in <code>pyventus/core/subscriptions/subscription.py</code> <pre><code>@override\ndef unsubscribe(self: Self) -&gt; bool:\n    return self.__teardown_callback(self)\n</code></pre>"},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Execute the event workflow.</p> PARAMETER DESCRIPTION <code>args</code> <p>Positional arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>()</code> </p> <code>kwargs</code> <p>Keyword arguments containing event-specific data.</p> <p> TYPE: <code>Any</code> DEFAULT: <code>{}</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/events/handlers/event_handler.py</code> <pre><code>async def execute(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Execute the event workflow.\n\n    :param args: Positional arguments containing event-specific data.\n    :param kwargs: Keyword arguments containing event-specific data.\n    :return: None.\n    \"\"\"\n    try:\n        # Start the event handling process and store the results\n        results: Any = await self._handle_event(*args, **kwargs)\n    except Exception as exception:\n        # Log the exception that occurred during the event handling.\n        StdOutLogger.error(source=summarized_repr(self), action=\"Exception:\", msg=f\"{repr(exception)}\")\n\n        # Handle the failed completion of the event response.\n        await self._handle_failure(exception=exception)\n    else:\n        # Handle the successful completion of the event response.\n        await self._handle_success(results=results)\n</code></pre>"},{"location":"api/events/subscribers/event_subscriber/#pyventus.events.EventSubscriber.__init__","title":"__init__","text":"<pre><code>__init__(teardown_callback: Callable[[Self], bool], event_callback: EventCallbackType, success_callback: SuccessCallbackType | None, failure_callback: FailureCallbackType | None, force_async: bool, once: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>EventSubscriber</code>.</p> PARAMETER DESCRIPTION <code>teardown_callback</code> <p>A callback function invoked during the unsubscription process to perform cleanup or teardown operations associated with the subscription. It should return <code>True</code> if the cleanup was successful, or <code>False</code> if the teardown has already been executed and the subscription is no longer active.</p> <p> TYPE: <code>Callable[[Self], bool]</code> </p> <code>event_callback</code> <p>The callback to be executed when the event occurs.</p> <p> TYPE: <code>EventCallbackType</code> </p> <code>success_callback</code> <p>The callback to be executed when the event response completes successfully.</p> <p> TYPE: <code>SuccessCallbackType | None</code> </p> <code>failure_callback</code> <p>The callback to be executed when the event response fails.</p> <p> TYPE: <code>FailureCallbackType | None</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously. If <code>True</code>, synchronous callbacks will be converted to run asynchronously in a thread pool, using the <code>asyncio.to_thread</code> function. If <code>False</code>, callbacks will run synchronously or asynchronously as defined.</p> <p> TYPE: <code>bool</code> </p> <code>once</code> <p>Specifies if the event subscriber is a one-time subscription.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/events/subscribers/event_subscriber.py</code> <pre><code>def __init__(\n    self,\n    teardown_callback: Callable[[Self], bool],\n    event_callback: EventCallbackType,\n    success_callback: SuccessCallbackType | None,\n    failure_callback: FailureCallbackType | None,\n    force_async: bool,\n    once: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `EventSubscriber`.\n\n    :param teardown_callback: A callback function invoked during the unsubscription process to perform\n        cleanup or teardown operations associated with the subscription. It should return `True` if the\n        cleanup was successful, or `False` if the teardown has already been executed and the subscription\n        is no longer active.\n    :param event_callback: The callback to be executed when the event occurs.\n    :param success_callback: The callback to be executed when the event response completes successfully.\n    :param failure_callback: The callback to be executed when the event response fails.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n        If `True`, synchronous callbacks will be converted to run asynchronously in a\n        thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n        will run synchronously or asynchronously as defined.\n    :param once: Specifies if the event subscriber is a one-time subscription.\n    \"\"\"\n    # Initialize the base Subscription class with the teardown callback\n    super().__init__(teardown_callback=teardown_callback)\n\n    # Ensure the 'once' parameter is a boolean\n    if not isinstance(once, bool):\n        raise PyventusException(\"The 'once' argument must be a boolean value.\")\n\n    # Wrap and set the event callback\n    self.__event_callback = CallableWrapper[..., Any](event_callback, force_async=force_async)\n\n    # Ensure that the event callback is not a generator.\n    if self.__event_callback.is_generator:\n        raise PyventusException(\"The 'event_callback' cannot be a generator.\")\n\n    # Wrap and set the success callback, if provided.\n    self.__success_callback = (\n        CallableWrapper[..., None](\n            success_callback,\n            force_async=force_async,\n        )\n        if success_callback\n        else None\n    )\n\n    # Ensure that the success callback is not a generator.\n    if self.__success_callback and self.__success_callback.is_generator:\n        raise PyventusException(\"The 'success_callback' cannot be a generator.\")\n\n    # Wrap and set the failure callback, if provided.\n    self.__failure_callback = (\n        CallableWrapper[[Exception], None](\n            failure_callback,\n            force_async=force_async,\n        )\n        if failure_callback\n        else None\n    )\n\n    # Ensure that the failure callback is not a generator.\n    if self.__failure_callback and self.__failure_callback.is_generator:\n        raise PyventusException(\"The 'failure_callback' cannot be a generator.\")\n\n    # Store the one-time subscription flag.\n    self.__once: bool = once\n</code></pre>"},{"location":"api/reactive/","title":"<code>Reactive</code> module","text":"<p>The reactive programming module of Pyventus.</p>"},{"location":"api/reactive/observables/","title":"<code>Observable</code> class","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_OutT]</code></p> <p>A base class that defines a lazy push-style notification mechanism for streaming data to subscribers.</p> <p>Notes:</p> <ul> <li> <p>The <code>Observable</code> class serves as a foundation for implementing various observable types with different     dispatch logic and strategies, encapsulating the essential protocols and workflows for streaming data     to subscribers in a reactive manner.</p> </li> <li> <p>This class is parameterized by the type of value that will be streamed through the observable. This     type parameter is covariant, allowing it to be either the specified type or any subtype.</p> </li> <li> <p>The <code>subscribe()</code> method can be utilized as a regular function, a decorator, or a context manager.     When used as a regular function, it automatically creates and subscribes an observer with the specified     callbacks. As a decorator, it creates and subscribes an observer, using the decorated callback as the     next callback. Finally, when employed as a context manager with the <code>with</code> statement, it enables a     step-by-step definition of the observer's callbacks prior to its subscription, which occurs     immediately after exiting the context.</p> </li> <li> <p>This class has been designed with thread safety in mind. All of its methods synchronize access to     mutable attributes to prevent race conditions when managing observables in a multi-threaded environment.</p> </li> </ul> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>class Observable(ABC, Generic[_OutT]):\n    \"\"\"\n    A base class that defines a lazy push-style notification mechanism for streaming data to subscribers.\n\n    **Notes:**\n\n    -   The `Observable` class serves as a foundation for implementing various observable types with different\n        dispatch logic and strategies, encapsulating the essential protocols and workflows for streaming data\n        to subscribers in a reactive manner.\n\n    -   This class is parameterized by the type of value that will be streamed through the observable. This\n        type parameter is covariant, allowing it to be either the specified type or any subtype.\n\n    -   The `subscribe()` method can be utilized as a regular function, a decorator, or a context manager.\n        When used as a regular function, it automatically creates and subscribes an observer with the specified\n        callbacks. As a decorator, it creates and subscribes an observer, using the decorated callback as the\n        next callback. Finally, when employed as a context manager with the `with` statement, it enables a\n        step-by-step definition of the observer's callbacks prior to its subscription, which occurs\n        immediately after exiting the context.\n\n    -   This class has been designed with *thread safety* in mind. All of its methods synchronize access to\n        mutable attributes to prevent race conditions when managing observables in a multi-threaded environment.\n    \"\"\"\n\n    @final\n    class ObservableSubCtx(Generic[_SubCtxO, _SubCtxT], SubscriptionContext[_SubCtxO, Subscriber[_SubCtxT]]):\n        \"\"\"\n        A context manager for Observable subscriptions.\n\n        **Notes:**\n\n        -   This class establishes a context block for a step-by-step definition of the observer's\n            callbacks prior to the actual subscription, which occurs immediately upon exiting the\n            context block.\n\n        -   This class can be used as either a decorator or a context manager. When used as a\n            decorator, it creates and subscribes an observer, using the decorated callback as\n            the next callback. When employed as a context manager with the `with` statement,\n            it enables a step-by-step definition of the observer's callbacks prior to its\n            subscription, which occurs immediately after exiting the context.\n\n        -   This subscription context can be `stateful`, retaining references to the `observable`\n            and `subscriber`, or `stateless`, which clears the context upon exiting the\n            subscription block.\n\n        -   This class is not intended to be subclassed or manually instantiated.\n        \"\"\"\n\n        # Attributes for the ObservableSubCtx\n        __slots__ = (\"__next_callback\", \"__error_callback\", \"__complete_callback\", \"__force_async\")\n\n        def __init__(self, observable: _SubCtxO, force_async: bool, is_stateful: bool) -&gt; None:\n            \"\"\"\n            Initialize an instance of `ObservableSubCtx`.\n\n            :param observable: The observable to which the observer will be subscribed.\n            :param force_async: Determines whether to force all callbacks to run asynchronously.\n            :param is_stateful: A flag indicating whether the context preserves its state (`stateful`) or\n                not (`stateless`) after exiting the subscription context. If `True`, the context retains its\n                state, allowing access to stored objects, including the `observable` and the `subscriber`\n                object. If `False`, the context is stateless, and the stored state is cleared upon\n                exiting the subscription context to prevent memory leaks.\n            \"\"\"\n            # Initialize the base SubscriptionContext class\n            super().__init__(source=observable, is_stateful=is_stateful)\n\n            # Initialize variables\n            self.__next_callback: NextCallbackType[_SubCtxT] | None = None\n            self.__error_callback: ErrorCallbackType | None = None\n            self.__complete_callback: CompleteCallbackType | None = None\n            self.__force_async: bool = force_async\n\n        @override\n        def _exit(self) -&gt; Subscriber[_SubCtxT]:\n            # Ensure that the source is not None.\n            if self._source is None:  # pragma: no cover\n                raise PyventusException(\"The subscription context is closed.\")\n\n            # Ensure that at least one callback is defined before performing the subscription.\n            if self.__next_callback is None and self.__error_callback is None and self.__complete_callback is None:\n                raise PyventusException(\"At least one callback must be defined before performing the subscription.\")\n\n            # Subscribe the defined callbacks to the specified\n            # observable and store the returned subscriber.\n            subscriber: Subscriber[_SubCtxT] = self._source.subscribe(\n                next_callback=self.__next_callback,\n                error_callback=self.__error_callback,\n                complete_callback=self.__complete_callback,\n                force_async=self.__force_async,\n            )\n\n            # Remove context-specific attributes.\n            del self.__next_callback, self.__error_callback, self.__complete_callback, self.__force_async\n\n            # Return the subscriber.\n            return subscriber\n\n        def on_next(self, callback: NextCallbackType[_SubCtxT]) -&gt; NextCallbackType[_SubCtxT]:\n            \"\"\"\n            Set the observer's next callback.\n\n            :param callback: The callback to be executed when the observable emits a new value.\n            :return: The decorated callback.\n            \"\"\"\n            self.__next_callback = callback\n            return callback\n\n        def on_error(self, callback: ErrorCallbackType) -&gt; ErrorCallbackType:\n            \"\"\"\n            Set the observer's error callback.\n\n            :param callback: The callback to be executed when the observable encounters an error.\n            :return: The decorated callback.\n            \"\"\"\n            self.__error_callback = callback\n            return callback\n\n        def on_complete(self, callback: CompleteCallbackType) -&gt; CompleteCallbackType:\n            \"\"\"\n            Set the observer's complete callback.\n\n            :param callback: The callback that will be executed when the observable has completed emitting values.\n            :return: The decorated callback.\n            \"\"\"\n            self.__complete_callback = callback\n            return callback\n\n        def __call__(\n            self, callback: NextCallbackType[_SubCtxT]\n        ) -&gt; (\n            tuple[NextCallbackType[_SubCtxT], \"Observable.ObservableSubCtx[_SubCtxO, _SubCtxT]\"]\n            | NextCallbackType[_SubCtxT]\n        ):\n            \"\"\"\n            Subscribe the decorated callback as the observer's `next` function for the specified observable.\n\n            :param callback: The callback to be executed when the observable emits a new value.\n            :return: A tuple containing the decorated callback and its subscription context\n                if the context is `stateful`; otherwise, returns the decorated callback alone.\n            \"\"\"\n            # Store the provided callback in the subscription context.\n            self.__next_callback = callback\n\n            # Set error and complete callbacks to None.\n            self.__error_callback = None\n            self.__complete_callback = None\n\n            # Determine if the subscription context is stateful.\n            is_stateful: bool = self._is_stateful\n\n            # Call the exit method to finalize the\n            # subscription process and clean up any necessary context.\n            self.__exit__(None, None, None)\n\n            # Return a tuple containing the decorated callback\n            # and the current subscription context if the context\n            # is stateful; otherwise, return just the callback.\n            return (callback, self) if is_stateful else callback\n\n    @final\n    class Completed(Exception):\n        \"\"\"Exception raised to indicate that an observable sequence has completed.\"\"\"\n\n    @staticmethod\n    def get_valid_subscriber(subscriber: Subscriber[_OutT]) -&gt; Subscriber[_OutT]:\n        \"\"\"\n        Validate and return the specified subscriber.\n\n        :param subscriber: The subscriber to validate.\n        :return: The validated subscriber.\n        :raises PyventusException: If the subscriber is not an instance of `Subscriber`.\n        \"\"\"\n        # Validate that the subscriber is an instance of Subscriber.\n        if not isinstance(subscriber, Subscriber):\n            raise PyventusException(\"The 'subscriber' argument must be an instance of Subscriber.\")\n        return subscriber\n\n    # Attributes for the Observable\n    __slots__ = (\"__subscribers\", \"__thread_lock\", \"__logger\")\n\n    def __init__(self, debug: bool | None = None) -&gt; None:\n        \"\"\"\n        Initialize an instance of `Observable`.\n\n        :param debug: Specifies the debug mode for the logger. If `None`,\n            the mode is determined based on the execution environment.\n        \"\"\"\n        # Initialize the set of subscribers.\n        self.__subscribers: set[Subscriber[_OutT]] = set()\n\n        # Create a lock object for thread synchronization.\n        self.__thread_lock: Lock = Lock()\n\n        # Validate the debug argument.\n        if debug is not None and not isinstance(debug, bool):\n            raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n        # Set up the logger with the appropriate debug mode.\n        self.__logger: Logger = Logger(source=self, debug=debug if debug is not None else bool(gettrace() is not None))\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Retrieve a string representation of the instance.\n\n        :return: A string representation of the instance.\n        \"\"\"\n        return attributes_repr(\n            subscribers=self.__subscribers,\n            thread_lock=self.__thread_lock,\n            debug=self.__logger.debug_enabled,\n        )\n\n    @property\n    def _logger(self) -&gt; Logger:\n        \"\"\"\n        Retrieve the logger instance.\n\n        :return: The logger instance used for logging messages.\n        \"\"\"\n        return self.__logger\n\n    @property\n    def _thread_lock(self) -&gt; Lock:\n        \"\"\"\n        Retrieve the thread lock instance.\n\n        :return: The thread lock instance used to ensure thread-safe operations.\n        \"\"\"\n        return self.__thread_lock\n\n    def _log_subscriber_exception(self, subscriber: Subscriber[_OutT], exception: Exception) -&gt; None:\n        \"\"\"\n        Log an unhandled exception that occurred during the execution of a subscriber's callback.\n\n        :param subscriber: The subscriber instance that encountered the exception.\n        :param exception: The exception instance to be logged.\n        :return: None.\n        \"\"\"\n        self.__logger.error(action=\"Exception:\", msg=f\"{exception!r} at {summarized_repr(subscriber)}.\")\n\n    @final  # Prevent overriding in subclasses to maintain the integrity of the _OutT type.\n    async def _emit_next(self, value: _OutT) -&gt; None:  # type: ignore[misc]\n        \"\"\"\n        Emit the next value to all subscribers.\n\n        This method notifies all subscribers of the next value in the stream.\n\n        :param value: The value to be emitted to all subscribers.\n        :return: None.\n        \"\"\"\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Get all subscribers and filter those with a next callback to optimize execution.\n            subscribers: list[Subscriber[_OutT]] = [\n                subscriber for subscriber in self.__subscribers if subscriber.has_next_callback\n            ]\n\n        # Exit if there are no subscribers.\n        if not subscribers:\n            # Log a debug message if debug mode is enabled.\n            if self.__logger.debug_enabled:\n                self.__logger.debug(\n                    action=\"Emitting Next Value:\",\n                    msg=f\"No subscribers to notify of the next value: {value!r}.\",\n                )\n            return\n\n        # Log the emission of the next value if debug mode is enabled.\n        if self.__logger.debug_enabled:\n            self.__logger.debug(\n                action=\"Emitting Next Value:\",\n                msg=f\"Notifying {len(subscribers)} subscribers of the next value: {value!r}.\",\n            )\n\n        # If there is only one subscriber, handle it directly.\n        if len(subscribers) == 1:\n            try:\n                # Notify the subscriber and await its response.\n                subscriber: Subscriber[_OutT] = subscribers.pop()\n                await subscriber.next(value)\n            except Exception as e:\n                # Log any exceptions that occur during notification.\n                self._log_subscriber_exception(subscriber, e)\n        else:\n            # Notify all subscribers concurrently.\n            results = await gather(*[subscriber.next(value) for subscriber in subscribers], return_exceptions=True)\n\n            # Log any exceptions that occur during notification.\n            for subscriber, result in zip(subscribers, results, strict=True):\n                if isinstance(result, Exception):\n                    self._log_subscriber_exception(subscriber, result)\n\n    @final\n    async def _emit_error(self, exception: Exception) -&gt; None:\n        \"\"\"\n        Emit the error that occurred to all subscribers.\n\n        This method notifies all subscribers of the error that occurred.\n\n        :param exception: The exception to be emitted to all subscribers.\n        :return: None.\n        \"\"\"\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Get all subscribers and filter those with an error callback to optimize execution.\n            subscribers: list[Subscriber[_OutT]] = [\n                subscriber for subscriber in self.__subscribers if subscriber.has_error_callback\n            ]\n\n        # Exit if there are no subscribers.\n        if not subscribers:\n            # Log an error message.\n            self.__logger.error(\n                action=\"Emitting Error:\",\n                msg=f\"No subscribers to notify of the error: {exception!r}.\",\n            )\n            return\n\n        # Log the error emission if debug mode is enabled.\n        if self.__logger.debug_enabled:\n            self.__logger.debug(\n                action=\"Emitting Error:\",\n                msg=f\"Notifying {len(subscribers)} subscribers of the error: {exception!r}.\",\n            )\n\n        # If there is only one subscriber, handle it directly.\n        if len(subscribers) == 1:\n            try:\n                # Notify the subscriber and await its response.\n                subscriber: Subscriber[_OutT] = subscribers.pop()\n                await subscriber.error(exception)\n            except Exception as e:\n                # Log any exceptions that occur during notification.\n                self._log_subscriber_exception(subscriber, e)\n        else:\n            # Notify all subscribers concurrently.\n            results = await gather(*[subscriber.error(exception) for subscriber in subscribers], return_exceptions=True)\n\n            # Log any exceptions that occur during notification.\n            for subscriber, result in zip(subscribers, results, strict=True):\n                if isinstance(result, Exception):\n                    self._log_subscriber_exception(subscriber, result)\n\n    @final\n    async def _emit_complete(self) -&gt; None:\n        \"\"\"\n        Emit the completion signal to all subscribers.\n\n        This method notifies all subscribers that the stream has completed.\n\n        :return: None.\n        \"\"\"\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Get all subscribers and filter those with a complete callback to optimize execution.\n            subscribers: list[Subscriber[_OutT]] = [\n                subscriber for subscriber in self.__subscribers if subscriber.has_complete_callback\n            ]\n\n            # Unsubscribe all observers since the stream has completed.\n            self.__subscribers.clear()\n\n        # Exit if there are no subscribers.\n        if not subscribers:\n            # Log a debug message if debug mode is enabled.\n            if self.__logger.debug_enabled:\n                self.__logger.debug(\n                    action=\"Emitting Completion:\",\n                    msg=\"No subscribers to notify of completion.\",\n                )\n            return\n\n        # Log the emission if debug is enabled.\n        if self.__logger.debug_enabled:\n            self.__logger.debug(\n                action=\"Emitting Completion:\",\n                msg=f\"Notifying {len(subscribers)} subscribers of completion.\",\n            )\n\n        # If there is only one subscriber, handle it directly.\n        if len(subscribers) == 1:\n            try:\n                # Notify the subscriber and await its response.\n                subscriber: Subscriber[_OutT] = subscribers.pop()\n                await subscriber.complete()\n            except Exception as e:\n                # Log any exceptions that occur during notification.\n                self._log_subscriber_exception(subscriber, e)\n        else:\n            # Notify all subscribers concurrently.\n            results = await gather(*[subscriber.complete() for subscriber in subscribers], return_exceptions=True)\n\n            # Log any exceptions that occur during notification.\n            for subscriber, result in zip(subscribers, results, strict=True):\n                if isinstance(result, Exception):\n                    self._log_subscriber_exception(subscriber, result)\n\n    def get_subscribers(self) -&gt; set[Subscriber[_OutT]]:\n        \"\"\"\n        Retrieve all registered subscribers.\n\n        :return: A set of all registered subscribers.\n        \"\"\"\n        with self.__thread_lock:\n            return self.__subscribers.copy()\n\n    def get_subscriber_count(self) -&gt; int:\n        \"\"\"\n        Retrieve the number of registered subscribers.\n\n        :return: The total count of subscribers in the observable.\n        \"\"\"\n        with self.__thread_lock:\n            return len(self.__subscribers)\n\n    def contains_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n        \"\"\"\n        Determine if the specified subscriber is present in the observable.\n\n        :param subscriber: The subscriber to be checked.\n        :return: `True` if the subscriber is found; `False` otherwise.\n        \"\"\"\n        valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n        with self.__thread_lock:\n            return valid_subscriber in self.__subscribers\n\n    @overload\n    def subscribe(\n        self, *, force_async: bool = False, stateful_subctx: bool = False\n    ) -&gt; \"Observable.ObservableSubCtx[Self, _OutT]\": ...\n\n    @overload\n    def subscribe(\n        self,\n        next_callback: NextCallbackType[_OutT] | None = None,\n        error_callback: ErrorCallbackType | None = None,\n        complete_callback: CompleteCallbackType | None = None,\n        *,\n        force_async: bool = False,\n    ) -&gt; Subscriber[_OutT]: ...\n\n    def subscribe(\n        self,\n        next_callback: NextCallbackType[_OutT] | None = None,\n        error_callback: ErrorCallbackType | None = None,\n        complete_callback: CompleteCallbackType | None = None,\n        *,\n        force_async: bool = False,\n        stateful_subctx: bool = False,\n    ) -&gt; Subscriber[_OutT] | \"Observable.ObservableSubCtx[Self, _OutT]\":\n        \"\"\"\n        Subscribe the specified callbacks to the current `Observable`.\n\n        This method can be utilized in three ways:\n\n        -   **As a regular function:** Automatically creates and subscribes an observer\n            with the specified callbacks.\n\n        -   **As a decorator:** Creates and subscribes an observer, using the decorated\n            callback as the next callback.\n\n        -   **As a context manager:** Enables a step-by-step definition of the observer's\n            callbacks prior to subscription, which occurs immediately after exiting the context.\n\n        :param next_callback: The callback to be executed when the observable emits a new value.\n        :param error_callback: The callback to be executed when the observable encounters an error.\n        :param complete_callback: The callback that will be executed when the observable has completed emitting values.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n        :param stateful_subctx: A flag indicating whether the subscription context preserves its state (`stateful`)\n            or not (`stateless`) after exiting the subscription block. If `True`, the context retains its state,\n            allowing access to stored objects, including the `observable` and the `subscriber` object. If `False`,\n            the context is stateless, and the stored state is cleared upon exiting the subscription block to\n            prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n        :return: A `Subscriber` if callbacks are provided; otherwise, an `ObservableSubCtx`.\n        \"\"\"\n        if next_callback is None and error_callback is None and complete_callback is None:\n            # If no callbacks are provided, create a subscription context for progressive definition.\n            return Observable.ObservableSubCtx[Self, _OutT](\n                observable=self,\n                force_async=force_async,\n                is_stateful=stateful_subctx,\n            )\n        else:\n            # Create a subscriber with the provided callbacks.\n            subscriber = Subscriber[_OutT](\n                teardown_callback=self.remove_subscriber,\n                next_callback=next_callback,\n                error_callback=error_callback,\n                complete_callback=complete_callback,\n                force_async=force_async,\n            )\n\n            # Acquire lock to ensure thread safety.\n            with self.__thread_lock:\n                # Add the subscriber to the observable.\n                self.__subscribers.add(subscriber)\n\n            # Log the subscription if debug is enabled\n            if self.__logger.debug_enabled:\n                self.__logger.debug(action=\"Subscribed:\", msg=f\"{subscriber}\")\n\n            # Return the subscriber.\n            return subscriber\n\n    def remove_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n        \"\"\"\n        Remove the specified subscriber from the observable.\n\n        :param subscriber: The subscriber to be removed from the observable.\n        :return: `True` if the subscriber was successfully removed; `False` if\n            the subscriber was not found in the observable.\n        \"\"\"\n        # Get the valid subscriber instance.\n        valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Check if the subscriber is registered; return False if not.\n            if valid_subscriber not in self.__subscribers:\n                return False\n\n            # Remove the subscriber from the observable.\n            self.__subscribers.remove(valid_subscriber)\n\n        # Log the removal if the debug mode is enabled\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Removed:\", msg=f\"{valid_subscriber}\")\n\n        return True\n\n    def remove_all(self) -&gt; bool:\n        \"\"\"\n        Remove all subscribers from the observable.\n\n        :return: `True` if the observable was successfully cleared; `False`\n            if the observable was already empty.\n        \"\"\"\n        # Acquire lock to ensure thread safety\n        with self.__thread_lock:\n            # Check if the observable is already empty\n            if not self.__subscribers:\n                return False\n\n            # Clear the observable\n            self.__subscribers.clear()\n\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Removed:\", msg=\"All subscribers.\")\n\n        return True\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable-classes","title":"Classes","text":""},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx","title":"ObservableSubCtx","text":"<p>               Bases: <code>Generic[_SubCtxO, _SubCtxT]</code>, <code>SubscriptionContext[_SubCtxO, Subscriber[_SubCtxT]]</code></p> <p>A context manager for Observable subscriptions.</p> <p>Notes:</p> <ul> <li> <p>This class establishes a context block for a step-by-step definition of the observer's     callbacks prior to the actual subscription, which occurs immediately upon exiting the     context block.</p> </li> <li> <p>This class can be used as either a decorator or a context manager. When used as a     decorator, it creates and subscribes an observer, using the decorated callback as     the next callback. When employed as a context manager with the <code>with</code> statement,     it enables a step-by-step definition of the observer's callbacks prior to its     subscription, which occurs immediately after exiting the context.</p> </li> <li> <p>This subscription context can be <code>stateful</code>, retaining references to the <code>observable</code>     and <code>subscriber</code>, or <code>stateless</code>, which clears the context upon exiting the     subscription block.</p> </li> <li> <p>This class is not intended to be subclassed or manually instantiated.</p> </li> </ul> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>@final\nclass ObservableSubCtx(Generic[_SubCtxO, _SubCtxT], SubscriptionContext[_SubCtxO, Subscriber[_SubCtxT]]):\n    \"\"\"\n    A context manager for Observable subscriptions.\n\n    **Notes:**\n\n    -   This class establishes a context block for a step-by-step definition of the observer's\n        callbacks prior to the actual subscription, which occurs immediately upon exiting the\n        context block.\n\n    -   This class can be used as either a decorator or a context manager. When used as a\n        decorator, it creates and subscribes an observer, using the decorated callback as\n        the next callback. When employed as a context manager with the `with` statement,\n        it enables a step-by-step definition of the observer's callbacks prior to its\n        subscription, which occurs immediately after exiting the context.\n\n    -   This subscription context can be `stateful`, retaining references to the `observable`\n        and `subscriber`, or `stateless`, which clears the context upon exiting the\n        subscription block.\n\n    -   This class is not intended to be subclassed or manually instantiated.\n    \"\"\"\n\n    # Attributes for the ObservableSubCtx\n    __slots__ = (\"__next_callback\", \"__error_callback\", \"__complete_callback\", \"__force_async\")\n\n    def __init__(self, observable: _SubCtxO, force_async: bool, is_stateful: bool) -&gt; None:\n        \"\"\"\n        Initialize an instance of `ObservableSubCtx`.\n\n        :param observable: The observable to which the observer will be subscribed.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n        :param is_stateful: A flag indicating whether the context preserves its state (`stateful`) or\n            not (`stateless`) after exiting the subscription context. If `True`, the context retains its\n            state, allowing access to stored objects, including the `observable` and the `subscriber`\n            object. If `False`, the context is stateless, and the stored state is cleared upon\n            exiting the subscription context to prevent memory leaks.\n        \"\"\"\n        # Initialize the base SubscriptionContext class\n        super().__init__(source=observable, is_stateful=is_stateful)\n\n        # Initialize variables\n        self.__next_callback: NextCallbackType[_SubCtxT] | None = None\n        self.__error_callback: ErrorCallbackType | None = None\n        self.__complete_callback: CompleteCallbackType | None = None\n        self.__force_async: bool = force_async\n\n    @override\n    def _exit(self) -&gt; Subscriber[_SubCtxT]:\n        # Ensure that the source is not None.\n        if self._source is None:  # pragma: no cover\n            raise PyventusException(\"The subscription context is closed.\")\n\n        # Ensure that at least one callback is defined before performing the subscription.\n        if self.__next_callback is None and self.__error_callback is None and self.__complete_callback is None:\n            raise PyventusException(\"At least one callback must be defined before performing the subscription.\")\n\n        # Subscribe the defined callbacks to the specified\n        # observable and store the returned subscriber.\n        subscriber: Subscriber[_SubCtxT] = self._source.subscribe(\n            next_callback=self.__next_callback,\n            error_callback=self.__error_callback,\n            complete_callback=self.__complete_callback,\n            force_async=self.__force_async,\n        )\n\n        # Remove context-specific attributes.\n        del self.__next_callback, self.__error_callback, self.__complete_callback, self.__force_async\n\n        # Return the subscriber.\n        return subscriber\n\n    def on_next(self, callback: NextCallbackType[_SubCtxT]) -&gt; NextCallbackType[_SubCtxT]:\n        \"\"\"\n        Set the observer's next callback.\n\n        :param callback: The callback to be executed when the observable emits a new value.\n        :return: The decorated callback.\n        \"\"\"\n        self.__next_callback = callback\n        return callback\n\n    def on_error(self, callback: ErrorCallbackType) -&gt; ErrorCallbackType:\n        \"\"\"\n        Set the observer's error callback.\n\n        :param callback: The callback to be executed when the observable encounters an error.\n        :return: The decorated callback.\n        \"\"\"\n        self.__error_callback = callback\n        return callback\n\n    def on_complete(self, callback: CompleteCallbackType) -&gt; CompleteCallbackType:\n        \"\"\"\n        Set the observer's complete callback.\n\n        :param callback: The callback that will be executed when the observable has completed emitting values.\n        :return: The decorated callback.\n        \"\"\"\n        self.__complete_callback = callback\n        return callback\n\n    def __call__(\n        self, callback: NextCallbackType[_SubCtxT]\n    ) -&gt; (\n        tuple[NextCallbackType[_SubCtxT], \"Observable.ObservableSubCtx[_SubCtxO, _SubCtxT]\"]\n        | NextCallbackType[_SubCtxT]\n    ):\n        \"\"\"\n        Subscribe the decorated callback as the observer's `next` function for the specified observable.\n\n        :param callback: The callback to be executed when the observable emits a new value.\n        :return: A tuple containing the decorated callback and its subscription context\n            if the context is `stateful`; otherwise, returns the decorated callback alone.\n        \"\"\"\n        # Store the provided callback in the subscription context.\n        self.__next_callback = callback\n\n        # Set error and complete callbacks to None.\n        self.__error_callback = None\n        self.__complete_callback = None\n\n        # Determine if the subscription context is stateful.\n        is_stateful: bool = self._is_stateful\n\n        # Call the exit method to finalize the\n        # subscription process and clean up any necessary context.\n        self.__exit__(None, None, None)\n\n        # Return a tuple containing the decorated callback\n        # and the current subscription context if the context\n        # is stateful; otherwise, return just the callback.\n        return (callback, self) if is_stateful else callback\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx-functions","title":"Functions","text":""},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.unpack","title":"unpack","text":"<pre><code>unpack() -&gt; tuple[_SourceType | None, _SubscriberType | None]\n</code></pre> <p>Unpack and retrieve the source object and its associated subscriber.</p> <p>This method returns a tuple containing the source object and its subscriber, while also handling the cleanup of associated resources to prevent memory leaks. After retrieving the objects, it deletes internal references to the source and subscriber to ensure they are no longer retained.</p> RETURNS DESCRIPTION <code>tuple[_SourceType | None, _SubscriberType | None]</code> <p>A tuple of the form (source, subscriber). Both may be <code>None</code> if the subscription context has either unpacked the state previously or is stateless.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If this method is called before or during the subscription context, indicating that the resources are not yet available for unpacking.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def unpack(self) -&gt; tuple[_SourceType | None, _SubscriberType | None]:\n    \"\"\"\n    Unpack and retrieve the source object and its associated subscriber.\n\n    This method returns a tuple containing the source object and its subscriber,\n    while also handling the cleanup of associated resources to prevent memory leaks.\n    After retrieving the objects, it deletes internal references to the source and\n    subscriber to ensure they are no longer retained.\n\n    :return: A tuple of the form (source, subscriber). Both may be `None` if the\n        subscription context has either unpacked the state previously or is stateless.\n    :raises PyventusException: If this method is called before or during the subscription\n        context, indicating that the resources are not yet available for unpacking.\n    \"\"\"\n    # Create a tuple with the source object and its subscriber\n    results: tuple[_SourceType | None, _SubscriberType | None] = (self._source, self._subscriber)\n\n    # Perform cleanup by deleting unnecessary references\n    if results[0]:\n        del self.__source\n    if results[1]:\n        del self.__subscriber\n\n    return results\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the subscription context block.</p> <p>This method facilitates the progressive definition of an object that will later be subscribed to the specified source.</p> RETURNS DESCRIPTION <code>Self</code> <p>The subscription context manager.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __enter__(self: Self) -&gt; Self:\n    \"\"\"\n    Enter the subscription context block.\n\n    This method facilitates the progressive definition of an\n    object that will later be subscribed to the specified source.\n\n    :return: The subscription context manager.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None\n</code></pre> <p>Exit the subscription context block.</p> <p>This method subscribes the defined object to the specified source, and performs any necessary cleanup.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the raised exception, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The raised exception object, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback information, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/core/subscriptions/subscription_context.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Exit the subscription context block.\n\n    This method subscribes the defined object to the\n    specified source, and performs any necessary cleanup.\n\n    :param exc_type: The type of the raised exception, if any.\n    :param exc_val: The raised exception object, if any.\n    :param exc_tb: The traceback information, if any.\n    :return: None.\n    \"\"\"\n    # Finalize the subscription and retrieve the subscriber\n    subscriber: _SubscriberType = self._exit()\n\n    # Ensure the subscriber is valid\n    if subscriber is None:  # pragma: no cover\n        raise PyventusException(\"The 'subscriber' argument cannot be None.\")\n\n    # Check if a subscriber has already been set to avoid an override\n    if self.__subscriber:  # pragma: no cover\n        raise PyventusException(\"A 'subscriber' has already been set.\")\n\n    if self.__is_stateful:\n        # Retain the subscriber if the context is stateful\n        self.__subscriber = subscriber\n    else:\n        # Remove context-specific references if stateless\n        del self.__source, self.__subscriber\n\n    # Remove the stateful context flag\n    del self.__is_stateful\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.__init__","title":"__init__","text":"<pre><code>__init__(observable: _SubCtxO, force_async: bool, is_stateful: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>ObservableSubCtx</code>.</p> PARAMETER DESCRIPTION <code>observable</code> <p>The observable to which the observer will be subscribed.</p> <p> TYPE: <code>_SubCtxO</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously.</p> <p> TYPE: <code>bool</code> </p> <code>is_stateful</code> <p>A flag indicating whether the context preserves its state (<code>stateful</code>) or not (<code>stateless</code>) after exiting the subscription context. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>observable</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription context to prevent memory leaks.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def __init__(self, observable: _SubCtxO, force_async: bool, is_stateful: bool) -&gt; None:\n    \"\"\"\n    Initialize an instance of `ObservableSubCtx`.\n\n    :param observable: The observable to which the observer will be subscribed.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n    :param is_stateful: A flag indicating whether the context preserves its state (`stateful`) or\n        not (`stateless`) after exiting the subscription context. If `True`, the context retains its\n        state, allowing access to stored objects, including the `observable` and the `subscriber`\n        object. If `False`, the context is stateless, and the stored state is cleared upon\n        exiting the subscription context to prevent memory leaks.\n    \"\"\"\n    # Initialize the base SubscriptionContext class\n    super().__init__(source=observable, is_stateful=is_stateful)\n\n    # Initialize variables\n    self.__next_callback: NextCallbackType[_SubCtxT] | None = None\n    self.__error_callback: ErrorCallbackType | None = None\n    self.__complete_callback: CompleteCallbackType | None = None\n    self.__force_async: bool = force_async\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.on_next","title":"on_next","text":"<pre><code>on_next(callback: NextCallbackType[_SubCtxT]) -&gt; NextCallbackType[_SubCtxT]\n</code></pre> <p>Set the observer's next callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the observable emits a new value.</p> <p> TYPE: <code>NextCallbackType[_SubCtxT]</code> </p> RETURNS DESCRIPTION <code>NextCallbackType[_SubCtxT]</code> <p>The decorated callback.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def on_next(self, callback: NextCallbackType[_SubCtxT]) -&gt; NextCallbackType[_SubCtxT]:\n    \"\"\"\n    Set the observer's next callback.\n\n    :param callback: The callback to be executed when the observable emits a new value.\n    :return: The decorated callback.\n    \"\"\"\n    self.__next_callback = callback\n    return callback\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.on_error","title":"on_error","text":"<pre><code>on_error(callback: ErrorCallbackType) -&gt; ErrorCallbackType\n</code></pre> <p>Set the observer's error callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the observable encounters an error.</p> <p> TYPE: <code>ErrorCallbackType</code> </p> RETURNS DESCRIPTION <code>ErrorCallbackType</code> <p>The decorated callback.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def on_error(self, callback: ErrorCallbackType) -&gt; ErrorCallbackType:\n    \"\"\"\n    Set the observer's error callback.\n\n    :param callback: The callback to be executed when the observable encounters an error.\n    :return: The decorated callback.\n    \"\"\"\n    self.__error_callback = callback\n    return callback\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.on_complete","title":"on_complete","text":"<pre><code>on_complete(callback: CompleteCallbackType) -&gt; CompleteCallbackType\n</code></pre> <p>Set the observer's complete callback.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback that will be executed when the observable has completed emitting values.</p> <p> TYPE: <code>CompleteCallbackType</code> </p> RETURNS DESCRIPTION <code>CompleteCallbackType</code> <p>The decorated callback.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def on_complete(self, callback: CompleteCallbackType) -&gt; CompleteCallbackType:\n    \"\"\"\n    Set the observer's complete callback.\n\n    :param callback: The callback that will be executed when the observable has completed emitting values.\n    :return: The decorated callback.\n    \"\"\"\n    self.__complete_callback = callback\n    return callback\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.ObservableSubCtx.__call__","title":"__call__","text":"<pre><code>__call__(callback: NextCallbackType[_SubCtxT]) -&gt; tuple[NextCallbackType[_SubCtxT], ObservableSubCtx[_SubCtxO, _SubCtxT]] | NextCallbackType[_SubCtxT]\n</code></pre> <p>Subscribe the decorated callback as the observer's <code>next</code> function for the specified observable.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be executed when the observable emits a new value.</p> <p> TYPE: <code>NextCallbackType[_SubCtxT]</code> </p> RETURNS DESCRIPTION <code>tuple[NextCallbackType[_SubCtxT], ObservableSubCtx[_SubCtxO, _SubCtxT]] | NextCallbackType[_SubCtxT]</code> <p>A tuple containing the decorated callback and its subscription context if the context is <code>stateful</code>; otherwise, returns the decorated callback alone.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def __call__(\n    self, callback: NextCallbackType[_SubCtxT]\n) -&gt; (\n    tuple[NextCallbackType[_SubCtxT], \"Observable.ObservableSubCtx[_SubCtxO, _SubCtxT]\"]\n    | NextCallbackType[_SubCtxT]\n):\n    \"\"\"\n    Subscribe the decorated callback as the observer's `next` function for the specified observable.\n\n    :param callback: The callback to be executed when the observable emits a new value.\n    :return: A tuple containing the decorated callback and its subscription context\n        if the context is `stateful`; otherwise, returns the decorated callback alone.\n    \"\"\"\n    # Store the provided callback in the subscription context.\n    self.__next_callback = callback\n\n    # Set error and complete callbacks to None.\n    self.__error_callback = None\n    self.__complete_callback = None\n\n    # Determine if the subscription context is stateful.\n    is_stateful: bool = self._is_stateful\n\n    # Call the exit method to finalize the\n    # subscription process and clean up any necessary context.\n    self.__exit__(None, None, None)\n\n    # Return a tuple containing the decorated callback\n    # and the current subscription context if the context\n    # is stateful; otherwise, return just the callback.\n    return (callback, self) if is_stateful else callback\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.Completed","title":"Completed","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised to indicate that an observable sequence has completed.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>@final\nclass Completed(Exception):\n    \"\"\"Exception raised to indicate that an observable sequence has completed.\"\"\"\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable-functions","title":"Functions","text":""},{"location":"api/reactive/observables/#pyventus.reactive.Observable.get_valid_subscriber","title":"get_valid_subscriber  <code>staticmethod</code>","text":"<pre><code>get_valid_subscriber(subscriber: Subscriber[_OutT]) -&gt; Subscriber[_OutT]\n</code></pre> <p>Validate and return the specified subscriber.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to validate.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>Subscriber[_OutT]</code> <p>The validated subscriber.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the subscriber is not an instance of <code>Subscriber</code>.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>@staticmethod\ndef get_valid_subscriber(subscriber: Subscriber[_OutT]) -&gt; Subscriber[_OutT]:\n    \"\"\"\n    Validate and return the specified subscriber.\n\n    :param subscriber: The subscriber to validate.\n    :return: The validated subscriber.\n    :raises PyventusException: If the subscriber is not an instance of `Subscriber`.\n    \"\"\"\n    # Validate that the subscriber is an instance of Subscriber.\n    if not isinstance(subscriber, Subscriber):\n        raise PyventusException(\"The 'subscriber' argument must be an instance of Subscriber.\")\n    return subscriber\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.__init__","title":"__init__","text":"<pre><code>__init__(debug: bool | None = None) -&gt; None\n</code></pre> <p>Initialize an instance of <code>Observable</code>.</p> PARAMETER DESCRIPTION <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, the mode is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def __init__(self, debug: bool | None = None) -&gt; None:\n    \"\"\"\n    Initialize an instance of `Observable`.\n\n    :param debug: Specifies the debug mode for the logger. If `None`,\n        the mode is determined based on the execution environment.\n    \"\"\"\n    # Initialize the set of subscribers.\n    self.__subscribers: set[Subscriber[_OutT]] = set()\n\n    # Create a lock object for thread synchronization.\n    self.__thread_lock: Lock = Lock()\n\n    # Validate the debug argument.\n    if debug is not None and not isinstance(debug, bool):\n        raise PyventusException(\"The 'debug' argument must be a boolean value.\")\n\n    # Set up the logger with the appropriate debug mode.\n    self.__logger: Logger = Logger(source=self, debug=debug if debug is not None else bool(gettrace() is not None))\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.get_subscribers","title":"get_subscribers","text":"<pre><code>get_subscribers() -&gt; set[Subscriber[_OutT]]\n</code></pre> <p>Retrieve all registered subscribers.</p> RETURNS DESCRIPTION <code>set[Subscriber[_OutT]]</code> <p>A set of all registered subscribers.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def get_subscribers(self) -&gt; set[Subscriber[_OutT]]:\n    \"\"\"\n    Retrieve all registered subscribers.\n\n    :return: A set of all registered subscribers.\n    \"\"\"\n    with self.__thread_lock:\n        return self.__subscribers.copy()\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.get_subscriber_count","title":"get_subscriber_count","text":"<pre><code>get_subscriber_count() -&gt; int\n</code></pre> <p>Retrieve the number of registered subscribers.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of subscribers in the observable.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def get_subscriber_count(self) -&gt; int:\n    \"\"\"\n    Retrieve the number of registered subscribers.\n\n    :return: The total count of subscribers in the observable.\n    \"\"\"\n    with self.__thread_lock:\n        return len(self.__subscribers)\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.contains_subscriber","title":"contains_subscriber","text":"<pre><code>contains_subscriber(subscriber: Subscriber[_OutT]) -&gt; bool\n</code></pre> <p>Determine if the specified subscriber is present in the observable.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be checked.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber is found; <code>False</code> otherwise.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def contains_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n    \"\"\"\n    Determine if the specified subscriber is present in the observable.\n\n    :param subscriber: The subscriber to be checked.\n    :return: `True` if the subscriber is found; `False` otherwise.\n    \"\"\"\n    valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n    with self.__thread_lock:\n        return valid_subscriber in self.__subscribers\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.subscribe","title":"subscribe","text":"<pre><code>subscribe(*, force_async: bool = False, stateful_subctx: bool = False) -&gt; ObservableSubCtx[Self, _OutT]\n</code></pre><pre><code>subscribe(next_callback: NextCallbackType[_OutT] | None = None, error_callback: ErrorCallbackType | None = None, complete_callback: CompleteCallbackType | None = None, *, force_async: bool = False) -&gt; Subscriber[_OutT]\n</code></pre> <pre><code>subscribe(next_callback: NextCallbackType[_OutT] | None = None, error_callback: ErrorCallbackType | None = None, complete_callback: CompleteCallbackType | None = None, *, force_async: bool = False, stateful_subctx: bool = False) -&gt; Subscriber[_OutT] | ObservableSubCtx[Self, _OutT]\n</code></pre> <p>Subscribe the specified callbacks to the current <code>Observable</code>.</p> <p>This method can be utilized in three ways:</p> <ul> <li> <p>As a regular function: Automatically creates and subscribes an observer     with the specified callbacks.</p> </li> <li> <p>As a decorator: Creates and subscribes an observer, using the decorated     callback as the next callback.</p> </li> <li> <p>As a context manager: Enables a step-by-step definition of the observer's     callbacks prior to subscription, which occurs immediately after exiting the context.</p> </li> </ul> PARAMETER DESCRIPTION <code>next_callback</code> <p>The callback to be executed when the observable emits a new value.</p> <p> TYPE: <code>NextCallbackType[_OutT] | None</code> DEFAULT: <code>None</code> </p> <code>error_callback</code> <p>The callback to be executed when the observable encounters an error.</p> <p> TYPE: <code>ErrorCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>complete_callback</code> <p>The callback that will be executed when the observable has completed emitting values.</p> <p> TYPE: <code>CompleteCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>stateful_subctx</code> <p>A flag indicating whether the subscription context preserves its state (<code>stateful</code>) or not (<code>stateless</code>) after exiting the subscription block. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>observable</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Subscriber[_OutT] | ObservableSubCtx[Self, _OutT]</code> <p>A <code>Subscriber</code> if callbacks are provided; otherwise, an <code>ObservableSubCtx</code>.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def subscribe(\n    self,\n    next_callback: NextCallbackType[_OutT] | None = None,\n    error_callback: ErrorCallbackType | None = None,\n    complete_callback: CompleteCallbackType | None = None,\n    *,\n    force_async: bool = False,\n    stateful_subctx: bool = False,\n) -&gt; Subscriber[_OutT] | \"Observable.ObservableSubCtx[Self, _OutT]\":\n    \"\"\"\n    Subscribe the specified callbacks to the current `Observable`.\n\n    This method can be utilized in three ways:\n\n    -   **As a regular function:** Automatically creates and subscribes an observer\n        with the specified callbacks.\n\n    -   **As a decorator:** Creates and subscribes an observer, using the decorated\n        callback as the next callback.\n\n    -   **As a context manager:** Enables a step-by-step definition of the observer's\n        callbacks prior to subscription, which occurs immediately after exiting the context.\n\n    :param next_callback: The callback to be executed when the observable emits a new value.\n    :param error_callback: The callback to be executed when the observable encounters an error.\n    :param complete_callback: The callback that will be executed when the observable has completed emitting values.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n    :param stateful_subctx: A flag indicating whether the subscription context preserves its state (`stateful`)\n        or not (`stateless`) after exiting the subscription block. If `True`, the context retains its state,\n        allowing access to stored objects, including the `observable` and the `subscriber` object. If `False`,\n        the context is stateless, and the stored state is cleared upon exiting the subscription block to\n        prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n    :return: A `Subscriber` if callbacks are provided; otherwise, an `ObservableSubCtx`.\n    \"\"\"\n    if next_callback is None and error_callback is None and complete_callback is None:\n        # If no callbacks are provided, create a subscription context for progressive definition.\n        return Observable.ObservableSubCtx[Self, _OutT](\n            observable=self,\n            force_async=force_async,\n            is_stateful=stateful_subctx,\n        )\n    else:\n        # Create a subscriber with the provided callbacks.\n        subscriber = Subscriber[_OutT](\n            teardown_callback=self.remove_subscriber,\n            next_callback=next_callback,\n            error_callback=error_callback,\n            complete_callback=complete_callback,\n            force_async=force_async,\n        )\n\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Add the subscriber to the observable.\n            self.__subscribers.add(subscriber)\n\n        # Log the subscription if debug is enabled\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Subscribed:\", msg=f\"{subscriber}\")\n\n        # Return the subscriber.\n        return subscriber\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.remove_subscriber","title":"remove_subscriber","text":"<pre><code>remove_subscriber(subscriber: Subscriber[_OutT]) -&gt; bool\n</code></pre> <p>Remove the specified subscriber from the observable.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be removed from the observable.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber was successfully removed; <code>False</code> if the subscriber was not found in the observable.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def remove_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n    \"\"\"\n    Remove the specified subscriber from the observable.\n\n    :param subscriber: The subscriber to be removed from the observable.\n    :return: `True` if the subscriber was successfully removed; `False` if\n        the subscriber was not found in the observable.\n    \"\"\"\n    # Get the valid subscriber instance.\n    valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n\n    # Acquire lock to ensure thread safety.\n    with self.__thread_lock:\n        # Check if the subscriber is registered; return False if not.\n        if valid_subscriber not in self.__subscribers:\n            return False\n\n        # Remove the subscriber from the observable.\n        self.__subscribers.remove(valid_subscriber)\n\n    # Log the removal if the debug mode is enabled\n    if self.__logger.debug_enabled:\n        self.__logger.debug(action=\"Removed:\", msg=f\"{valid_subscriber}\")\n\n    return True\n</code></pre>"},{"location":"api/reactive/observables/#pyventus.reactive.Observable.remove_all","title":"remove_all","text":"<pre><code>remove_all() -&gt; bool\n</code></pre> <p>Remove all subscribers from the observable.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the observable was successfully cleared; <code>False</code> if the observable was already empty.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def remove_all(self) -&gt; bool:\n    \"\"\"\n    Remove all subscribers from the observable.\n\n    :return: `True` if the observable was successfully cleared; `False`\n        if the observable was already empty.\n    \"\"\"\n    # Acquire lock to ensure thread safety\n    with self.__thread_lock:\n        # Check if the observable is already empty\n        if not self.__subscribers:\n            return False\n\n        # Clear the observable\n        self.__subscribers.clear()\n\n    if self.__logger.debug_enabled:\n        self.__logger.debug(action=\"Removed:\", msg=\"All subscribers.\")\n\n    return True\n</code></pre>"},{"location":"api/reactive/observables/observable_task/","title":"<code>ObservableTask</code> class","text":"<p>               Bases: <code>Generic[_OutT]</code>, <code>Observable[_OutT]</code></p> <p>An observable subclass that encapsulates a unit of work and offers a mechanism for streaming its results reactively.</p> <p>Notes:</p> <ul> <li> <p>The <code>ObservableTask</code> class facilitates deferred execution of tasks, allowing subscribers to receive results     incrementally as they become available.</p> </li> <li> <p>This class supports the encapsulation of tasks that can be either standard functions or methods, as well as     generator functions.</p> </li> <li> <p>Results are streamed to subscribers in a lazy manner, meaning they are produced on demand rather than all     at once.</p> </li> </ul> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>class ObservableTask(Generic[_OutT], Observable[_OutT]):\n    \"\"\"\n    An observable subclass that encapsulates a unit of work and offers a mechanism for streaming its results reactively.\n\n    **Notes:**\n\n    -   The `ObservableTask` class facilitates deferred execution of tasks, allowing subscribers to receive results\n        incrementally as they become available.\n\n    -   This class supports the encapsulation of tasks that can be either standard functions or methods, as well as\n        generator functions.\n\n    -   Results are streamed to subscribers in a lazy manner, meaning they are produced on demand rather than all\n        at once.\n    \"\"\"\n\n    # Attributes for the ObservableTask\n    __slots__ = (\"__callback\", \"__args\", \"__kwargs\", \"__processing_service\")\n\n    def __init__(\n        self,\n        callback: ObservableTaskCallbackType[_OutT],\n        args: tuple[Any, ...] | None = None,\n        kwargs: dict[str, Any] | None = None,\n        debug: bool | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `ObservableTask`.\n\n        :param callback: The callback to be encapsulated and made observable.\n        :param args: Positional arguments to be passed to the callback.\n        :param kwargs: Keyword arguments to be passed to the callback.\n        :param debug: Specifies the debug mode for the logger. If `None`,\n            the mode is determined based on the execution environment.\n        \"\"\"\n        # Initialize the base Observable class with the given debug value.\n        super().__init__(debug=debug)\n\n        # Validate the args argument.\n        if args and not isinstance(args, tuple):\n            raise PyventusException(\"The 'args' argument must be a tuple.\")\n\n        # Validate the kwargs argument.\n        if kwargs and not isinstance(kwargs, dict):\n            raise PyventusException(\"The 'kwargs' argument must be a dictionary.\")\n\n        # Wrap and set the callback along with its arguments.\n        self.__callback = CallableWrapper[..., _OutT](callback, force_async=False)\n        self.__args: tuple[Any, ...] = args if args else ()\n        self.__kwargs: dict[str, Any] = kwargs if kwargs else {}\n\n        # Set up an AsyncIO processing service for handling the callback execution.\n        self.__processing_service: AsyncIOProcessingService = AsyncIOProcessingService()\n\n    @override\n    def __repr__(self) -&gt; str:\n        return formatted_repr(\n            instance=self,\n            info=(\n                attributes_repr(\n                    callback=self.__callback,\n                    args=self.__args,\n                    kwargs=self.__kwargs,\n                    processing_service=self.__processing_service,\n                )\n                + f\", {super().__repr__()}\"\n            ),\n        )\n\n    async def __execute(self) -&gt; None:\n        \"\"\"\n        Execute the main callback and emit results to subscribers.\n\n        This method invokes the callback of the ObservableTask with\n        the provided arguments and emits results to subscribers in\n        a lazy-push manner.\n\n        :return: None.\n        \"\"\"\n        try:\n            if self.__callback.is_generator:\n                # Stream values from the generator callback and emit each value to subscribers.\n                async for g_value in self.__callback.stream(*self.__args, **self.__kwargs):\n                    await self._emit_next(value=g_value)\n            else:\n                # Execute the regular callback and emit the result to subscribers.\n                r_value: _OutT = await self.__callback.execute(*self.__args, **self.__kwargs)\n                await self._emit_next(value=r_value)\n\n                # Indicate that the callback execution is complete.\n                raise Completed from None\n        except Observable.Completed:\n            # Notify subscribers that the observable\n            # has completed emitting values.\n            await self._emit_complete()\n        except Exception as exception:\n            # Notify subscribers of any errors\n            # encountered during execution.\n            await self._emit_error(exception)\n\n    async def wait_for_tasks(self) -&gt; None:\n        \"\"\"\n        Wait for all background tasks associated with the `ObservableTask` to complete.\n\n        It ensures that any ongoing tasks are finished before proceeding.\n\n        :return: None.\n        \"\"\"\n        # Await the completion of all background tasks.\n        await self.__processing_service.wait_for_tasks()\n\n    @contextmanager\n    def to_thread(\n        self, executor: ThreadPoolExecutor | None = None, shutdown: bool = False\n    ) -&gt; Generator[Self, None, None]:\n        \"\"\"\n        Configure the execution context block for processing the `ObservableTask` using a thread-based executor.\n\n        This method allows the `ObservableTask` to be executed in a separate thread, utilizing the specified\n        executor. Upon exiting the context, the observable task is executed within the provided executor.\n\n        :param executor: An optional `ThreadPoolExecutor` instance for executing the `ObservableTask`.\n            If `None`, a new `ThreadPoolExecutor` with default settings will be created and automatically\n            shut down after execution.\n        :param shutdown: A flag indicating whether to shut down the specified executor upon exiting the\n            context. If the executor is `None`, the new executor will always be shut down when the\n            context is exited.\n        :return: The current ObservableTask instance.\n        \"\"\"\n        # Yield the current ObservableTask\n        # instance for use within the context.\n        yield self\n\n        if executor:\n            # Execute the observable task using the provided executor.\n            self(executor=executor)\n\n            # Shut down the provided executor if the shutdown flag is set to True.\n            if shutdown:\n                executor.shutdown()\n        else:\n            # Create a new ThreadPoolExecutor, execute the observable task\n            # within that new thread, and shut it down after execution.\n            new_executor = ThreadPoolExecutor()\n            self(executor=new_executor)\n            new_executor.shutdown()\n\n    def __enter__(self: Self) -&gt; Self:\n        \"\"\"\n        Enter the execution context of the observable task.\n\n        This method facilitates interaction with the observable task object\n        and ensures that the task is executed upon exiting the context block.\n\n        :return: The observable task instance.\n        \"\"\"\n        return self\n\n    def __exit__(\n        self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n    ) -&gt; None:\n        \"\"\"\n        Exit the execution context of the observable task.\n\n        This method triggers the execution of the observable task\n        upon exiting the context block.\n\n        :param exc_type: The type of the raised exception, if any.\n        :param exc_val: The raised exception object, if any.\n        :param exc_tb: The traceback information, if any.\n        :return: None.\n        \"\"\"\n        # Execute the observable task.\n        self(executor=None)\n\n    def __call__(self, executor: ThreadPoolExecutor | None = None) -&gt; None:\n        \"\"\"\n        Execute the current `ObservableTask`.\n\n        **Notes:**\n\n        -   When a thread-based executor is provided, the execution of\n            the `ObservableTask` is submitted to that thread.\n\n        -   If no executor is provided, the execution is submitted to\n            the AsyncIO processing service of the current `ObservableTask`\n            instance.\n\n        -   The execution behavior within the AsyncIO processing service\n            depends on whether an AsyncIO event loop is running. For more\n            information, refer to the `AsyncIOProcessingService`.\n\n        :param executor: An optional thread-based executor instance for\n            processing the `ObservableTask`'s execution.\n        :return: None.\n        \"\"\"\n        if executor is None:\n            # Submit the ObservableTask's execution to the AsyncIO processing service.\n            self.__processing_service.submit(self.__execute)\n        else:\n            # Ensure the provided executor is a ThreadPoolExecutor instance.\n            if not isinstance(executor, ThreadPoolExecutor):\n                raise PyventusException(\"The 'executor' argument must be an instance of ThreadPoolExecutor.\")\n\n            # Submit the ObservableTask's execution to the specified thread-based executor.\n            executor.submit(self.__processing_service.submit, self.__execute)\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask-functions","title":"Functions","text":""},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.get_valid_subscriber","title":"get_valid_subscriber  <code>staticmethod</code>","text":"<pre><code>get_valid_subscriber(subscriber: Subscriber[_OutT]) -&gt; Subscriber[_OutT]\n</code></pre> <p>Validate and return the specified subscriber.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to validate.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>Subscriber[_OutT]</code> <p>The validated subscriber.</p> RAISES DESCRIPTION <code>PyventusException</code> <p>If the subscriber is not an instance of <code>Subscriber</code>.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>@staticmethod\ndef get_valid_subscriber(subscriber: Subscriber[_OutT]) -&gt; Subscriber[_OutT]:\n    \"\"\"\n    Validate and return the specified subscriber.\n\n    :param subscriber: The subscriber to validate.\n    :return: The validated subscriber.\n    :raises PyventusException: If the subscriber is not an instance of `Subscriber`.\n    \"\"\"\n    # Validate that the subscriber is an instance of Subscriber.\n    if not isinstance(subscriber, Subscriber):\n        raise PyventusException(\"The 'subscriber' argument must be an instance of Subscriber.\")\n    return subscriber\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.get_subscribers","title":"get_subscribers","text":"<pre><code>get_subscribers() -&gt; set[Subscriber[_OutT]]\n</code></pre> <p>Retrieve all registered subscribers.</p> RETURNS DESCRIPTION <code>set[Subscriber[_OutT]]</code> <p>A set of all registered subscribers.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def get_subscribers(self) -&gt; set[Subscriber[_OutT]]:\n    \"\"\"\n    Retrieve all registered subscribers.\n\n    :return: A set of all registered subscribers.\n    \"\"\"\n    with self.__thread_lock:\n        return self.__subscribers.copy()\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.get_subscriber_count","title":"get_subscriber_count","text":"<pre><code>get_subscriber_count() -&gt; int\n</code></pre> <p>Retrieve the number of registered subscribers.</p> RETURNS DESCRIPTION <code>int</code> <p>The total count of subscribers in the observable.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def get_subscriber_count(self) -&gt; int:\n    \"\"\"\n    Retrieve the number of registered subscribers.\n\n    :return: The total count of subscribers in the observable.\n    \"\"\"\n    with self.__thread_lock:\n        return len(self.__subscribers)\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.contains_subscriber","title":"contains_subscriber","text":"<pre><code>contains_subscriber(subscriber: Subscriber[_OutT]) -&gt; bool\n</code></pre> <p>Determine if the specified subscriber is present in the observable.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be checked.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber is found; <code>False</code> otherwise.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def contains_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n    \"\"\"\n    Determine if the specified subscriber is present in the observable.\n\n    :param subscriber: The subscriber to be checked.\n    :return: `True` if the subscriber is found; `False` otherwise.\n    \"\"\"\n    valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n    with self.__thread_lock:\n        return valid_subscriber in self.__subscribers\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.subscribe","title":"subscribe","text":"<pre><code>subscribe(*, force_async: bool = False, stateful_subctx: bool = False) -&gt; ObservableSubCtx[Self, _OutT]\n</code></pre><pre><code>subscribe(next_callback: NextCallbackType[_OutT] | None = None, error_callback: ErrorCallbackType | None = None, complete_callback: CompleteCallbackType | None = None, *, force_async: bool = False) -&gt; Subscriber[_OutT]\n</code></pre> <pre><code>subscribe(next_callback: NextCallbackType[_OutT] | None = None, error_callback: ErrorCallbackType | None = None, complete_callback: CompleteCallbackType | None = None, *, force_async: bool = False, stateful_subctx: bool = False) -&gt; Subscriber[_OutT] | ObservableSubCtx[Self, _OutT]\n</code></pre> <p>Subscribe the specified callbacks to the current <code>Observable</code>.</p> <p>This method can be utilized in three ways:</p> <ul> <li> <p>As a regular function: Automatically creates and subscribes an observer     with the specified callbacks.</p> </li> <li> <p>As a decorator: Creates and subscribes an observer, using the decorated     callback as the next callback.</p> </li> <li> <p>As a context manager: Enables a step-by-step definition of the observer's     callbacks prior to subscription, which occurs immediately after exiting the context.</p> </li> </ul> PARAMETER DESCRIPTION <code>next_callback</code> <p>The callback to be executed when the observable emits a new value.</p> <p> TYPE: <code>NextCallbackType[_OutT] | None</code> DEFAULT: <code>None</code> </p> <code>error_callback</code> <p>The callback to be executed when the observable encounters an error.</p> <p> TYPE: <code>ErrorCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>complete_callback</code> <p>The callback that will be executed when the observable has completed emitting values.</p> <p> TYPE: <code>CompleteCallbackType | None</code> DEFAULT: <code>None</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>stateful_subctx</code> <p>A flag indicating whether the subscription context preserves its state (<code>stateful</code>) or not (<code>stateless</code>) after exiting the subscription block. If <code>True</code>, the context retains its state, allowing access to stored objects, including the <code>observable</code> and the <code>subscriber</code> object. If <code>False</code>, the context is stateless, and the stored state is cleared upon exiting the subscription block to prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Subscriber[_OutT] | ObservableSubCtx[Self, _OutT]</code> <p>A <code>Subscriber</code> if callbacks are provided; otherwise, an <code>ObservableSubCtx</code>.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def subscribe(\n    self,\n    next_callback: NextCallbackType[_OutT] | None = None,\n    error_callback: ErrorCallbackType | None = None,\n    complete_callback: CompleteCallbackType | None = None,\n    *,\n    force_async: bool = False,\n    stateful_subctx: bool = False,\n) -&gt; Subscriber[_OutT] | \"Observable.ObservableSubCtx[Self, _OutT]\":\n    \"\"\"\n    Subscribe the specified callbacks to the current `Observable`.\n\n    This method can be utilized in three ways:\n\n    -   **As a regular function:** Automatically creates and subscribes an observer\n        with the specified callbacks.\n\n    -   **As a decorator:** Creates and subscribes an observer, using the decorated\n        callback as the next callback.\n\n    -   **As a context manager:** Enables a step-by-step definition of the observer's\n        callbacks prior to subscription, which occurs immediately after exiting the context.\n\n    :param next_callback: The callback to be executed when the observable emits a new value.\n    :param error_callback: The callback to be executed when the observable encounters an error.\n    :param complete_callback: The callback that will be executed when the observable has completed emitting values.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n    :param stateful_subctx: A flag indicating whether the subscription context preserves its state (`stateful`)\n        or not (`stateless`) after exiting the subscription block. If `True`, the context retains its state,\n        allowing access to stored objects, including the `observable` and the `subscriber` object. If `False`,\n        the context is stateless, and the stored state is cleared upon exiting the subscription block to\n        prevent memory leaks. The term 'subctx' refers to 'Subscription Context'.\n    :return: A `Subscriber` if callbacks are provided; otherwise, an `ObservableSubCtx`.\n    \"\"\"\n    if next_callback is None and error_callback is None and complete_callback is None:\n        # If no callbacks are provided, create a subscription context for progressive definition.\n        return Observable.ObservableSubCtx[Self, _OutT](\n            observable=self,\n            force_async=force_async,\n            is_stateful=stateful_subctx,\n        )\n    else:\n        # Create a subscriber with the provided callbacks.\n        subscriber = Subscriber[_OutT](\n            teardown_callback=self.remove_subscriber,\n            next_callback=next_callback,\n            error_callback=error_callback,\n            complete_callback=complete_callback,\n            force_async=force_async,\n        )\n\n        # Acquire lock to ensure thread safety.\n        with self.__thread_lock:\n            # Add the subscriber to the observable.\n            self.__subscribers.add(subscriber)\n\n        # Log the subscription if debug is enabled\n        if self.__logger.debug_enabled:\n            self.__logger.debug(action=\"Subscribed:\", msg=f\"{subscriber}\")\n\n        # Return the subscriber.\n        return subscriber\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.remove_subscriber","title":"remove_subscriber","text":"<pre><code>remove_subscriber(subscriber: Subscriber[_OutT]) -&gt; bool\n</code></pre> <p>Remove the specified subscriber from the observable.</p> PARAMETER DESCRIPTION <code>subscriber</code> <p>The subscriber to be removed from the observable.</p> <p> TYPE: <code>Subscriber[_OutT]</code> </p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber was successfully removed; <code>False</code> if the subscriber was not found in the observable.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def remove_subscriber(self, subscriber: Subscriber[_OutT]) -&gt; bool:\n    \"\"\"\n    Remove the specified subscriber from the observable.\n\n    :param subscriber: The subscriber to be removed from the observable.\n    :return: `True` if the subscriber was successfully removed; `False` if\n        the subscriber was not found in the observable.\n    \"\"\"\n    # Get the valid subscriber instance.\n    valid_subscriber: Subscriber[_OutT] = self.get_valid_subscriber(subscriber)\n\n    # Acquire lock to ensure thread safety.\n    with self.__thread_lock:\n        # Check if the subscriber is registered; return False if not.\n        if valid_subscriber not in self.__subscribers:\n            return False\n\n        # Remove the subscriber from the observable.\n        self.__subscribers.remove(valid_subscriber)\n\n    # Log the removal if the debug mode is enabled\n    if self.__logger.debug_enabled:\n        self.__logger.debug(action=\"Removed:\", msg=f\"{valid_subscriber}\")\n\n    return True\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.remove_all","title":"remove_all","text":"<pre><code>remove_all() -&gt; bool\n</code></pre> <p>Remove all subscribers from the observable.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the observable was successfully cleared; <code>False</code> if the observable was already empty.</p> Source code in <code>pyventus/reactive/observables/observable.py</code> <pre><code>def remove_all(self) -&gt; bool:\n    \"\"\"\n    Remove all subscribers from the observable.\n\n    :return: `True` if the observable was successfully cleared; `False`\n        if the observable was already empty.\n    \"\"\"\n    # Acquire lock to ensure thread safety\n    with self.__thread_lock:\n        # Check if the observable is already empty\n        if not self.__subscribers:\n            return False\n\n        # Clear the observable\n        self.__subscribers.clear()\n\n    if self.__logger.debug_enabled:\n        self.__logger.debug(action=\"Removed:\", msg=\"All subscribers.\")\n\n    return True\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.__init__","title":"__init__","text":"<pre><code>__init__(callback: ObservableTaskCallbackType[_OutT], args: tuple[Any, ...] | None = None, kwargs: dict[str, Any] | None = None, debug: bool | None = None) -&gt; None\n</code></pre> <p>Initialize an instance of <code>ObservableTask</code>.</p> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be encapsulated and made observable.</p> <p> TYPE: <code>ObservableTaskCallbackType[_OutT]</code> </p> <code>args</code> <p>Positional arguments to be passed to the callback.</p> <p> TYPE: <code>tuple[Any, ...] | None</code> DEFAULT: <code>None</code> </p> <code>kwargs</code> <p>Keyword arguments to be passed to the callback.</p> <p> TYPE: <code>dict[str, Any] | None</code> DEFAULT: <code>None</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, the mode is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>def __init__(\n    self,\n    callback: ObservableTaskCallbackType[_OutT],\n    args: tuple[Any, ...] | None = None,\n    kwargs: dict[str, Any] | None = None,\n    debug: bool | None = None,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `ObservableTask`.\n\n    :param callback: The callback to be encapsulated and made observable.\n    :param args: Positional arguments to be passed to the callback.\n    :param kwargs: Keyword arguments to be passed to the callback.\n    :param debug: Specifies the debug mode for the logger. If `None`,\n        the mode is determined based on the execution environment.\n    \"\"\"\n    # Initialize the base Observable class with the given debug value.\n    super().__init__(debug=debug)\n\n    # Validate the args argument.\n    if args and not isinstance(args, tuple):\n        raise PyventusException(\"The 'args' argument must be a tuple.\")\n\n    # Validate the kwargs argument.\n    if kwargs and not isinstance(kwargs, dict):\n        raise PyventusException(\"The 'kwargs' argument must be a dictionary.\")\n\n    # Wrap and set the callback along with its arguments.\n    self.__callback = CallableWrapper[..., _OutT](callback, force_async=False)\n    self.__args: tuple[Any, ...] = args if args else ()\n    self.__kwargs: dict[str, Any] = kwargs if kwargs else {}\n\n    # Set up an AsyncIO processing service for handling the callback execution.\n    self.__processing_service: AsyncIOProcessingService = AsyncIOProcessingService()\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.wait_for_tasks","title":"wait_for_tasks  <code>async</code>","text":"<pre><code>wait_for_tasks() -&gt; None\n</code></pre> <p>Wait for all background tasks associated with the <code>ObservableTask</code> to complete.</p> <p>It ensures that any ongoing tasks are finished before proceeding.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>async def wait_for_tasks(self) -&gt; None:\n    \"\"\"\n    Wait for all background tasks associated with the `ObservableTask` to complete.\n\n    It ensures that any ongoing tasks are finished before proceeding.\n\n    :return: None.\n    \"\"\"\n    # Await the completion of all background tasks.\n    await self.__processing_service.wait_for_tasks()\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.to_thread","title":"to_thread","text":"<pre><code>to_thread(executor: ThreadPoolExecutor | None = None, shutdown: bool = False) -&gt; Generator[Self, None, None]\n</code></pre> <p>Configure the execution context block for processing the <code>ObservableTask</code> using a thread-based executor.</p> <p>This method allows the <code>ObservableTask</code> to be executed in a separate thread, utilizing the specified executor. Upon exiting the context, the observable task is executed within the provided executor.</p> PARAMETER DESCRIPTION <code>executor</code> <p>An optional <code>ThreadPoolExecutor</code> instance for executing the <code>ObservableTask</code>. If <code>None</code>, a new <code>ThreadPoolExecutor</code> with default settings will be created and automatically shut down after execution.</p> <p> TYPE: <code>ThreadPoolExecutor | None</code> DEFAULT: <code>None</code> </p> <code>shutdown</code> <p>A flag indicating whether to shut down the specified executor upon exiting the context. If the executor is <code>None</code>, the new executor will always be shut down when the context is exited.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Generator[Self, None, None]</code> <p>The current ObservableTask instance.</p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>@contextmanager\ndef to_thread(\n    self, executor: ThreadPoolExecutor | None = None, shutdown: bool = False\n) -&gt; Generator[Self, None, None]:\n    \"\"\"\n    Configure the execution context block for processing the `ObservableTask` using a thread-based executor.\n\n    This method allows the `ObservableTask` to be executed in a separate thread, utilizing the specified\n    executor. Upon exiting the context, the observable task is executed within the provided executor.\n\n    :param executor: An optional `ThreadPoolExecutor` instance for executing the `ObservableTask`.\n        If `None`, a new `ThreadPoolExecutor` with default settings will be created and automatically\n        shut down after execution.\n    :param shutdown: A flag indicating whether to shut down the specified executor upon exiting the\n        context. If the executor is `None`, the new executor will always be shut down when the\n        context is exited.\n    :return: The current ObservableTask instance.\n    \"\"\"\n    # Yield the current ObservableTask\n    # instance for use within the context.\n    yield self\n\n    if executor:\n        # Execute the observable task using the provided executor.\n        self(executor=executor)\n\n        # Shut down the provided executor if the shutdown flag is set to True.\n        if shutdown:\n            executor.shutdown()\n    else:\n        # Create a new ThreadPoolExecutor, execute the observable task\n        # within that new thread, and shut it down after execution.\n        new_executor = ThreadPoolExecutor()\n        self(executor=new_executor)\n        new_executor.shutdown()\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the execution context of the observable task.</p> <p>This method facilitates interaction with the observable task object and ensures that the task is executed upon exiting the context block.</p> RETURNS DESCRIPTION <code>Self</code> <p>The observable task instance.</p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>def __enter__(self: Self) -&gt; Self:\n    \"\"\"\n    Enter the execution context of the observable task.\n\n    This method facilitates interaction with the observable task object\n    and ensures that the task is executed upon exiting the context block.\n\n    :return: The observable task instance.\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.__exit__","title":"__exit__","text":"<pre><code>__exit__(exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None) -&gt; None\n</code></pre> <p>Exit the execution context of the observable task.</p> <p>This method triggers the execution of the observable task upon exiting the context block.</p> PARAMETER DESCRIPTION <code>exc_type</code> <p>The type of the raised exception, if any.</p> <p> TYPE: <code>type[BaseException] | None</code> </p> <code>exc_val</code> <p>The raised exception object, if any.</p> <p> TYPE: <code>BaseException | None</code> </p> <code>exc_tb</code> <p>The traceback information, if any.</p> <p> TYPE: <code>TracebackType | None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>def __exit__(\n    self, exc_type: type[BaseException] | None, exc_val: BaseException | None, exc_tb: TracebackType | None\n) -&gt; None:\n    \"\"\"\n    Exit the execution context of the observable task.\n\n    This method triggers the execution of the observable task\n    upon exiting the context block.\n\n    :param exc_type: The type of the raised exception, if any.\n    :param exc_val: The raised exception object, if any.\n    :param exc_tb: The traceback information, if any.\n    :return: None.\n    \"\"\"\n    # Execute the observable task.\n    self(executor=None)\n</code></pre>"},{"location":"api/reactive/observables/observable_task/#pyventus.reactive.ObservableTask.__call__","title":"__call__","text":"<pre><code>__call__(executor: ThreadPoolExecutor | None = None) -&gt; None\n</code></pre> <p>Execute the current <code>ObservableTask</code>.</p> <p>Notes:</p> <ul> <li> <p>When a thread-based executor is provided, the execution of     the <code>ObservableTask</code> is submitted to that thread.</p> </li> <li> <p>If no executor is provided, the execution is submitted to     the AsyncIO processing service of the current <code>ObservableTask</code>     instance.</p> </li> <li> <p>The execution behavior within the AsyncIO processing service     depends on whether an AsyncIO event loop is running. For more     information, refer to the <code>AsyncIOProcessingService</code>.</p> </li> </ul> PARAMETER DESCRIPTION <code>executor</code> <p>An optional thread-based executor instance for processing the <code>ObservableTask</code>'s execution.</p> <p> TYPE: <code>ThreadPoolExecutor | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observables/observable_task.py</code> <pre><code>def __call__(self, executor: ThreadPoolExecutor | None = None) -&gt; None:\n    \"\"\"\n    Execute the current `ObservableTask`.\n\n    **Notes:**\n\n    -   When a thread-based executor is provided, the execution of\n        the `ObservableTask` is submitted to that thread.\n\n    -   If no executor is provided, the execution is submitted to\n        the AsyncIO processing service of the current `ObservableTask`\n        instance.\n\n    -   The execution behavior within the AsyncIO processing service\n        depends on whether an AsyncIO event loop is running. For more\n        information, refer to the `AsyncIOProcessingService`.\n\n    :param executor: An optional thread-based executor instance for\n        processing the `ObservableTask`'s execution.\n    :return: None.\n    \"\"\"\n    if executor is None:\n        # Submit the ObservableTask's execution to the AsyncIO processing service.\n        self.__processing_service.submit(self.__execute)\n    else:\n        # Ensure the provided executor is a ThreadPoolExecutor instance.\n        if not isinstance(executor, ThreadPoolExecutor):\n            raise PyventusException(\"The 'executor' argument must be an instance of ThreadPoolExecutor.\")\n\n        # Submit the ObservableTask's execution to the specified thread-based executor.\n        executor.submit(self.__processing_service.submit, self.__execute)\n</code></pre>"},{"location":"api/reactive/observables/observable_utils/","title":"Observable Utils","text":""},{"location":"api/reactive/observables/observable_utils/#pyventus.reactive.observables.observable_utils-functions","title":"Functions","text":""},{"location":"api/reactive/observables/observable_utils/#pyventus.reactive.observables.observable_utils.as_observable_task","title":"as_observable_task","text":"<pre><code>as_observable_task(callback: Callable[_P, ObservableTaskCallbackReturnType[_OutT]]) -&gt; Callable[_P, ObservableTask[_OutT]]\n</code></pre><pre><code>as_observable_task(*, debug: bool) -&gt; Callable[[Callable[_P, ObservableTaskCallbackReturnType[_OutT]]], Callable[_P, ObservableTask[_OutT]]]\n</code></pre> <pre><code>as_observable_task(callback: Callable[_P, ObservableTaskCallbackReturnType[_OutT]] | None = None, /, *, debug: bool | None = None) -&gt; Callable[_P, ObservableTask[_OutT]] | Callable[[Callable[_P, ObservableTaskCallbackReturnType[_OutT]]], Callable[_P, ObservableTask[_OutT]]]\n</code></pre> <p>Convert a given callback into an observable task.</p> <p>Notes:</p> <ul> <li> <p>The decorated callback can be either a standard <code>sync</code> or <code>async</code> function, as well as     a <code>sync</code> or <code>async</code> generator to stream data through the <code>ObservableTask</code>.</p> </li> <li> <p>It is important to note that the decorated callback is executed not upon calling the output     function, but rather when the <code>ObservableTask</code> produced by the output function is executed.</p> </li> </ul> PARAMETER DESCRIPTION <code>callback</code> <p>The callback to be encapsulated and made observable.</p> <p> TYPE: <code>Callable[_P, ObservableTaskCallbackReturnType[_OutT]] | None</code> DEFAULT: <code>None</code> </p> <code>debug</code> <p>Specifies the debug mode for the logger. If <code>None</code>, the mode is determined based on the execution environment.</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>Callable[_P, ObservableTask[_OutT]] | Callable[[Callable[_P, ObservableTaskCallbackReturnType[_OutT]]], Callable[_P, ObservableTask[_OutT]]]</code> <p>A function that, upon invocation, generates an <code>ObservableTask</code>.</p> Source code in <code>pyventus/reactive/observables/observable_utils.py</code> <pre><code>def as_observable_task(\n    callback: Callable[_P, ObservableTaskCallbackReturnType[_OutT]] | None = None, /, *, debug: bool | None = None\n) -&gt; (\n    Callable[_P, ObservableTask[_OutT]]\n    | Callable[[Callable[_P, ObservableTaskCallbackReturnType[_OutT]]], Callable[_P, ObservableTask[_OutT]]]\n):\n    \"\"\"\n    Convert a given callback into an observable task.\n\n    **Notes:**\n\n    -   The decorated callback can be either a standard `sync` or `async` function, as well as\n        a `sync` or `async` generator to stream data through the `ObservableTask`.\n\n    -   It is important to note that the decorated callback is executed not upon calling the output\n        function, but rather when the `ObservableTask` produced by the output function is executed.\n\n    :param callback: The callback to be encapsulated and made observable.\n    :param debug: Specifies the debug mode for the logger. If `None`,\n        the mode is determined based on the execution environment.\n    :return: A function that, upon invocation, generates an `ObservableTask`.\n    \"\"\"\n\n    def decorator(\n        _callback: Callable[_P, ObservableTaskCallbackReturnType[_OutT]],\n    ) -&gt; Callable[_P, ObservableTask[_OutT]]:\n        @wraps(_callback)\n        def helper(*args: _P.args, **kwargs: _P.kwargs) -&gt; ObservableTask[_OutT]:\n            # Create an ObservableTask instance based on the provided callback.\n            return ObservableTask[_OutT](callback=_callback, args=args, kwargs=kwargs, debug=debug)\n\n        return helper\n\n    return decorator(callback) if callback is not None else decorator\n</code></pre>"},{"location":"api/reactive/observers/observer/","title":"<code>Observer</code> class","text":"<p>               Bases: <code>ABC</code>, <code>Generic[_InT]</code></p> <p>A base class that defines the workflow and essential protocols for responding to notifications from an observable.</p> <p>Notes:</p> <ul> <li>This class is parameterized by the type of value that will be received in the <code>next</code> method.</li> </ul> Source code in <code>pyventus/reactive/observers/observer.py</code> <pre><code>class Observer(ABC, Generic[_InT]):\n    \"\"\"\n    A base class that defines the workflow and essential protocols for responding to notifications from an observable.\n\n    **Notes:**\n\n    -   This class is parameterized by the type of value that will be received in the `next` method.\n\n    \"\"\"\n\n    # Allow subclasses to define __slots__\n    __slots__ = ()\n\n    @abstractmethod\n    async def next(self, value: _InT) -&gt; None:\n        \"\"\"\n        Handle the next value emitted by the observable.\n\n        :param value: The value emitted by the observable.\n        :return: None.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def error(self, exception: Exception) -&gt; None:\n        \"\"\"\n        Handle an error that occurs in the observable.\n\n        :param exception: The exception that was raised by the observable.\n        :return: None.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def complete(self) -&gt; None:\n        \"\"\"\n        Handle the completion of the observable.\n\n        :return: None.\n        \"\"\"\n        pass\n</code></pre>"},{"location":"api/reactive/observers/observer/#pyventus.reactive.Observer-functions","title":"Functions","text":""},{"location":"api/reactive/observers/observer/#pyventus.reactive.Observer.next","title":"next  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>next(value: _InT) -&gt; None\n</code></pre> <p>Handle the next value emitted by the observable.</p> PARAMETER DESCRIPTION <code>value</code> <p>The value emitted by the observable.</p> <p> TYPE: <code>_InT</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observers/observer.py</code> <pre><code>@abstractmethod\nasync def next(self, value: _InT) -&gt; None:\n    \"\"\"\n    Handle the next value emitted by the observable.\n\n    :param value: The value emitted by the observable.\n    :return: None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/reactive/observers/observer/#pyventus.reactive.Observer.error","title":"error  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>error(exception: Exception) -&gt; None\n</code></pre> <p>Handle an error that occurs in the observable.</p> PARAMETER DESCRIPTION <code>exception</code> <p>The exception that was raised by the observable.</p> <p> TYPE: <code>Exception</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observers/observer.py</code> <pre><code>@abstractmethod\nasync def error(self, exception: Exception) -&gt; None:\n    \"\"\"\n    Handle an error that occurs in the observable.\n\n    :param exception: The exception that was raised by the observable.\n    :return: None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/reactive/observers/observer/#pyventus.reactive.Observer.complete","title":"complete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>complete() -&gt; None\n</code></pre> <p>Handle the completion of the observable.</p> RETURNS DESCRIPTION <code>None</code> <p>None.</p> Source code in <code>pyventus/reactive/observers/observer.py</code> <pre><code>@abstractmethod\nasync def complete(self) -&gt; None:\n    \"\"\"\n    Handle the completion of the observable.\n\n    :return: None.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/","title":"<code>Subscriber</code> class","text":"<p>               Bases: <code>Generic[_InT]</code>, <code>Observer[_InT]</code>, <code>Subscription</code></p> <p>A class that represents an <code>Observer</code> subscribed to an <code>Observable</code>.</p> <p>Notes:</p> <ul> <li> <p>This class combines the <code>Observer</code> interface with the <code>Subscription</code>     base class, offering a convenient way to both respond to state changes     emitted by an observable and manage the subscription lifecycle.</p> </li> <li> <p>This class is not intended to be subclassed or instantiated directly.</p> </li> </ul> Source code in <code>pyventus/reactive/subscribers/subscriber.py</code> <pre><code>@final\nclass Subscriber(Generic[_InT], Observer[_InT], Subscription):\n    \"\"\"\n    A class that represents an `Observer` subscribed to an `Observable`.\n\n    **Notes:**\n\n    -   This class combines the `Observer` interface with the `Subscription`\n        base class, offering a convenient way to both respond to state changes\n        emitted by an observable and manage the subscription lifecycle.\n\n    -   This class is not intended to be subclassed or instantiated directly.\n    \"\"\"\n\n    # Attributes for the Subscriber\n    __slots__ = (\"__next_callback\", \"__error_callback\", \"__complete_callback\")\n\n    def __init__(\n        self,\n        teardown_callback: Callable[[Self], bool],\n        next_callback: NextCallbackType[_InT] | None,\n        error_callback: ErrorCallbackType | None,\n        complete_callback: CompleteCallbackType | None,\n        force_async: bool,\n    ) -&gt; None:\n        \"\"\"\n        Initialize an instance of `Subscriber`.\n\n        :param teardown_callback: A callback function invoked during the unsubscription process to perform\n            cleanup or teardown operations associated with the subscription. It should return `True` if the\n            cleanup was successful, or `False` if the teardown has already been executed and the subscription\n            is no longer active.\n        :param next_callback: The callback to be executed when the observable emits a new value.\n        :param error_callback: The callback to be executed when the observable encounters an error.\n        :param complete_callback: The callback that will be executed when the observable has completed emitting values.\n        :param force_async: Determines whether to force all callbacks to run asynchronously.\n            If `True`, synchronous callbacks will be converted to run asynchronously in a\n            thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n            will run synchronously or asynchronously as defined.\n        \"\"\"\n        # Initialize the base Subscription class with the teardown callback\n        super().__init__(teardown_callback=teardown_callback)\n\n        # Ensure that at least one of the callbacks (next, error, or complete) is defined.\n        if next_callback is None and error_callback is None and complete_callback is None:\n            raise PyventusException(\"At least one of the callbacks (next, error, or complete) must be defined.\")\n\n        # Wrap and set the next callback, if provided\n        self.__next_callback = (\n            CallableWrapper[[_InT], None](\n                next_callback,\n                force_async=force_async,\n            )\n            if next_callback\n            else None\n        )\n\n        # Ensure that the next callback is not a generator.\n        if self.__next_callback and self.__next_callback.is_generator:\n            raise PyventusException(\"The 'next_callback' cannot be a generator.\")\n\n        # Wrap and set the error callback, if provided\n        self.__error_callback = (\n            CallableWrapper[[Exception], None](\n                error_callback,\n                force_async=force_async,\n            )\n            if error_callback\n            else None\n        )\n\n        # Ensure that the error callback is not a generator.\n        if self.__error_callback and self.__error_callback.is_generator:\n            raise PyventusException(\"The 'error_callback' cannot be a generator.\")\n\n        # Wrap and set the complete callback, if provided\n        self.__complete_callback = (\n            CallableWrapper[[], None](\n                complete_callback,\n                force_async=force_async,\n            )\n            if complete_callback\n            else None\n        )\n\n        # Ensure that the complete callback is not a generator.\n        if self.__complete_callback and self.__complete_callback.is_generator:\n            raise PyventusException(\"The 'complete_callback' cannot be a generator.\")\n\n    @override\n    def __repr__(self) -&gt; str:\n        return formatted_repr(\n            instance=self,\n            info=(\n                attributes_repr(\n                    next_callback=self.__next_callback,\n                    error_callback=self.__error_callback,\n                    complete_callback=self.__complete_callback,\n                )\n                + f\", {super().__repr__()}\"\n            ),\n        )\n\n    @property\n    def has_next_callback(self) -&gt; bool:\n        \"\"\"\n        Determine whether the subscriber has a next callback assigned.\n\n        :return: `True` if the subscriber has a next callback assigned; otherwise, `False`.\n        \"\"\"\n        return self.__next_callback is not None\n\n    @property\n    def has_error_callback(self) -&gt; bool:\n        \"\"\"\n        Determine whether the subscriber has an error callback assigned.\n\n        :return: `True` if the subscriber has an error callback assigned; otherwise, `False`.\n        \"\"\"\n        return self.__error_callback is not None\n\n    @property\n    def has_complete_callback(self) -&gt; bool:\n        \"\"\"\n        Determine whether the subscriber has a complete callback assigned.\n\n        :return: `True` if the subscriber has a complete callback assigned; otherwise, `False`.\n        \"\"\"\n        return self.__complete_callback is not None\n\n    @override\n    async def next(self, value: _InT) -&gt; None:\n        if self.__next_callback is None:\n            # If no next callback is set, exit early\n            return\n        else:\n            # Invoke the next callback with the provided value\n            await self.__next_callback.execute(value)\n\n    @override\n    async def error(self, exception: Exception) -&gt; None:\n        if self.__error_callback is None:\n            # If no error callback is set, exit early\n            return\n        else:\n            # Invoke the error callback with the provided exception\n            await self.__error_callback.execute(exception)\n\n    @override\n    async def complete(self) -&gt; None:\n        if self.__complete_callback is None:\n            # If no complete callback is set, exit early\n            return\n        else:\n            # Invoke the complete callback\n            await self.__complete_callback.execute()\n\n    @override\n    def __getstate__(self) -&gt; dict[str, Any]:\n        # Retrieve the state of the base Subscription class\n        state: dict[str, Any] = super().__getstate__()\n\n        # Add the state of the Subscriber attributes\n        state[\"__next_callback\"] = self.__next_callback\n        state[\"__error_callback\"] = self.__error_callback\n        state[\"__complete_callback\"] = self.__complete_callback\n\n        # Return the complete state for serialization\n        return state\n\n    @override\n    def __setstate__(self, state: dict[str, Any]) -&gt; None:\n        # Restore the state of the base Subscription class\n        super().__setstate__(state)\n\n        # Restore the state of the Subscriber attributes\n        self.__next_callback = state[\"__next_callback\"]\n        self.__error_callback = state[\"__error_callback\"]\n        self.__complete_callback = state[\"__complete_callback\"]\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber-attributes","title":"Attributes","text":""},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.timestamp","title":"timestamp  <code>property</code>","text":"<pre><code>timestamp: datetime\n</code></pre> <p>Retrieve the timestamp when the subscription was created.</p> RETURNS DESCRIPTION <code>datetime</code> <p>The timestamp when the subscription was created.</p>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.has_next_callback","title":"has_next_callback  <code>property</code>","text":"<pre><code>has_next_callback: bool\n</code></pre> <p>Determine whether the subscriber has a next callback assigned.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber has a next callback assigned; otherwise, <code>False</code>.</p>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.has_error_callback","title":"has_error_callback  <code>property</code>","text":"<pre><code>has_error_callback: bool\n</code></pre> <p>Determine whether the subscriber has an error callback assigned.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber has an error callback assigned; otherwise, <code>False</code>.</p>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.has_complete_callback","title":"has_complete_callback  <code>property</code>","text":"<pre><code>has_complete_callback: bool\n</code></pre> <p>Determine whether the subscriber has a complete callback assigned.</p> RETURNS DESCRIPTION <code>bool</code> <p><code>True</code> if the subscriber has a complete callback assigned; otherwise, <code>False</code>.</p>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber-functions","title":"Functions","text":""},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.unsubscribe","title":"unsubscribe","text":"<pre><code>unsubscribe() -&gt; bool\n</code></pre> Source code in <code>pyventus/core/subscriptions/subscription.py</code> <pre><code>@override\ndef unsubscribe(self: Self) -&gt; bool:\n    return self.__teardown_callback(self)\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.__init__","title":"__init__","text":"<pre><code>__init__(teardown_callback: Callable[[Self], bool], next_callback: NextCallbackType[_InT] | None, error_callback: ErrorCallbackType | None, complete_callback: CompleteCallbackType | None, force_async: bool) -&gt; None\n</code></pre> <p>Initialize an instance of <code>Subscriber</code>.</p> PARAMETER DESCRIPTION <code>teardown_callback</code> <p>A callback function invoked during the unsubscription process to perform cleanup or teardown operations associated with the subscription. It should return <code>True</code> if the cleanup was successful, or <code>False</code> if the teardown has already been executed and the subscription is no longer active.</p> <p> TYPE: <code>Callable[[Self], bool]</code> </p> <code>next_callback</code> <p>The callback to be executed when the observable emits a new value.</p> <p> TYPE: <code>NextCallbackType[_InT] | None</code> </p> <code>error_callback</code> <p>The callback to be executed when the observable encounters an error.</p> <p> TYPE: <code>ErrorCallbackType | None</code> </p> <code>complete_callback</code> <p>The callback that will be executed when the observable has completed emitting values.</p> <p> TYPE: <code>CompleteCallbackType | None</code> </p> <code>force_async</code> <p>Determines whether to force all callbacks to run asynchronously. If <code>True</code>, synchronous callbacks will be converted to run asynchronously in a thread pool, using the <code>asyncio.to_thread</code> function. If <code>False</code>, callbacks will run synchronously or asynchronously as defined.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>pyventus/reactive/subscribers/subscriber.py</code> <pre><code>def __init__(\n    self,\n    teardown_callback: Callable[[Self], bool],\n    next_callback: NextCallbackType[_InT] | None,\n    error_callback: ErrorCallbackType | None,\n    complete_callback: CompleteCallbackType | None,\n    force_async: bool,\n) -&gt; None:\n    \"\"\"\n    Initialize an instance of `Subscriber`.\n\n    :param teardown_callback: A callback function invoked during the unsubscription process to perform\n        cleanup or teardown operations associated with the subscription. It should return `True` if the\n        cleanup was successful, or `False` if the teardown has already been executed and the subscription\n        is no longer active.\n    :param next_callback: The callback to be executed when the observable emits a new value.\n    :param error_callback: The callback to be executed when the observable encounters an error.\n    :param complete_callback: The callback that will be executed when the observable has completed emitting values.\n    :param force_async: Determines whether to force all callbacks to run asynchronously.\n        If `True`, synchronous callbacks will be converted to run asynchronously in a\n        thread pool, using the `asyncio.to_thread` function. If `False`, callbacks\n        will run synchronously or asynchronously as defined.\n    \"\"\"\n    # Initialize the base Subscription class with the teardown callback\n    super().__init__(teardown_callback=teardown_callback)\n\n    # Ensure that at least one of the callbacks (next, error, or complete) is defined.\n    if next_callback is None and error_callback is None and complete_callback is None:\n        raise PyventusException(\"At least one of the callbacks (next, error, or complete) must be defined.\")\n\n    # Wrap and set the next callback, if provided\n    self.__next_callback = (\n        CallableWrapper[[_InT], None](\n            next_callback,\n            force_async=force_async,\n        )\n        if next_callback\n        else None\n    )\n\n    # Ensure that the next callback is not a generator.\n    if self.__next_callback and self.__next_callback.is_generator:\n        raise PyventusException(\"The 'next_callback' cannot be a generator.\")\n\n    # Wrap and set the error callback, if provided\n    self.__error_callback = (\n        CallableWrapper[[Exception], None](\n            error_callback,\n            force_async=force_async,\n        )\n        if error_callback\n        else None\n    )\n\n    # Ensure that the error callback is not a generator.\n    if self.__error_callback and self.__error_callback.is_generator:\n        raise PyventusException(\"The 'error_callback' cannot be a generator.\")\n\n    # Wrap and set the complete callback, if provided\n    self.__complete_callback = (\n        CallableWrapper[[], None](\n            complete_callback,\n            force_async=force_async,\n        )\n        if complete_callback\n        else None\n    )\n\n    # Ensure that the complete callback is not a generator.\n    if self.__complete_callback and self.__complete_callback.is_generator:\n        raise PyventusException(\"The 'complete_callback' cannot be a generator.\")\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.next","title":"next  <code>async</code>","text":"<pre><code>next(value: _InT) -&gt; None\n</code></pre> Source code in <code>pyventus/reactive/subscribers/subscriber.py</code> <pre><code>@override\nasync def next(self, value: _InT) -&gt; None:\n    if self.__next_callback is None:\n        # If no next callback is set, exit early\n        return\n    else:\n        # Invoke the next callback with the provided value\n        await self.__next_callback.execute(value)\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.error","title":"error  <code>async</code>","text":"<pre><code>error(exception: Exception) -&gt; None\n</code></pre> Source code in <code>pyventus/reactive/subscribers/subscriber.py</code> <pre><code>@override\nasync def error(self, exception: Exception) -&gt; None:\n    if self.__error_callback is None:\n        # If no error callback is set, exit early\n        return\n    else:\n        # Invoke the error callback with the provided exception\n        await self.__error_callback.execute(exception)\n</code></pre>"},{"location":"api/reactive/subscribers/subscriber/#pyventus.reactive.Subscriber.complete","title":"complete  <code>async</code>","text":"<pre><code>complete() -&gt; None\n</code></pre> Source code in <code>pyventus/reactive/subscribers/subscriber.py</code> <pre><code>@override\nasync def complete(self) -&gt; None:\n    if self.__complete_callback is None:\n        # If no complete callback is set, exit early\n        return\n    else:\n        # Invoke the complete callback\n        await self.__complete_callback.execute()\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":"<p>\ud83c\udfd7\ufe0f Work in Progress</p> <p>The Tutorials section is currently being rebuilt.</p> <p>     \u2003\u2003Welcome to the Tutorials section, where you can learn the key concepts and features of Pyventus through step-by-step examples. These tutorials are designed to be user-friendly, covering a range of topics from the basics to more advanced concepts. </p> <p>     \u2003\u2003By following these tutorials, you'll gain a solid understanding of Pyventus' core abstractions and how to effectively apply them when building your applications. The tutorials are organized in a progressive manner, allowing you to gradually enhance your knowledge and skills. </p> <p> </p> <p> Let's kickstart your Pyventus experience! </p>"}]}