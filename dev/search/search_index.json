{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Pyventus","text":"<p>Documentation: https://mdapena.github.io/pyventus</p> <p>Source Code: https://github.com/mdapena/pyventus</p> <p>     \u2003\u2003Pyventus is a powerful Python package for event-driven programming. It offers a comprehensive suite     of tools to easily define, emit, and orchestrate events. With Pyventus, you can build scalable, extensible, and     loosely-coupled event-driven applications. </p>"},{"location":"#key-features","title":"Key Features","text":"<p>     Pyventus offers several key features, such as: </p> <ul> <li>Sync and Async Support \u2500  Whether your code is synchronous or asynchronous, Pyventus allows you to define event handlers as either sync or async callbacks and emit events from both scopes.  </li> <li>Customization \u2500  Whether you choose official emitters or custom ones, Pyventus allows you to customize the behavior and capabilities of the event emitters to perfectly align with your unique requirements. </li> <li>An Intuitive API \u2500  Pyventus provides a user-friendly API for defining events, emitters, and handlers. Its design simplifies the process of working with events, enabling you to organize your code around discrete events and their associated actions. </li> <li>Runtime Flexibility \u2500  Pyventus' runtime flexibility allows you to switch seamlessly between different built-in or custom event emitter implementations on the fly, providing a dynamic and adaptable environment for event-driven programming. </li> <li>Reliable Event Handling \u2500  Pyventus allows you to define handlers to customize how events are processed upon completion. Attach success and failure logic to take targeted actions based on the outcome of each event execution.  </li> <li>Scalability and Maintainability \u2500  By adopting an event-driven approach with Pyventus, you can create scalable and maintainable code thanks to the loose coupling between its components that enables extensibility and modularity. </li> <li>Comprehensive Documentation \u2500  Pyventus provides a comprehensive documentation suite that includes API references, usage examples, and tutorials to effectively leverage all the features and capabilities of the package. </li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>     \u2003\u2003Pyventus is published as a Python package      and can be installed using <code>pip</code>, ideally in a virtual environment     for proper dependency isolation. To get started, open up a terminal and install Pyventus with the following command: </p> <pre><code>pip install pyventus\n</code></pre> <p>     \u2003\u2003Pyventus by default relies on the Python standard library and requires Python 3.10 or higher with no      additional dependencies. However, this package also includes alternative integrations to access additional features      such as Redis Queue, Celery, and FastAPI. For more information on this matter, please refer to the      Optional Dependencies     section. </p>"},{"location":"#a-simple-example","title":"A Simple Example","text":"<p>     \u2003\u2003Experience the power of Pyventus through a simple <code>Hello, World!</code> example that illustrates     the core concepts and basic usage of the package. By following this example, you\u2019ll learn how to subscribe to events     and emit them within your application. </p> Hello, World! Example<pre><code>from pyventus.events import EventLinker, EventEmitter, AsyncIOEventEmitter\n\n\n@EventLinker.on(\"GreetEvent\")\ndef handle_greet_event():\n    print(\"Hello, World!\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"GreetEvent\")\n</code></pre> You can also work with <code>async</code> functions and contexts... Hello, World! Example (Async version)<pre><code>from pyventus.events import EventLinker, EventEmitter, AsyncIOEventEmitter\n\n\n@EventLinker.on(\"GreetEvent\")\nasync def handle_greet_event():\n    print(\"Hello, World!\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"GreetEvent\")\n</code></pre> <p>     \u2003\u2003As we can see from the <code>Hello, World!</code> example, Pyventus follows a simple and intuitive      workflow for defining and emitting events. Let's recap the essential steps involved: </p> <ol> <li> Importing Necessary Modules:  We first imported the required modules from Pyventus,  which encompassed the <code>EventLinker</code> class, the <code>EventEmitter</code> interface, and the <code>AsyncIOEventEmitter</code> implementation. </li> <li> Linking Events to Callbacks:  Next, we used the <code>@EventLinker.on()</code> decorator to define and link the string event <code>GreetEvent</code>  to the function <code>handle_greet_event()</code>, which will print 'Hello, World!' to the console whenever the <code>GreetEvent</code> is emitted. </li> <li> Instantiating an Event Emitter:  After that, and in order to trigger our event, we needed to create an instance of the event emitter class. While  <code>AsyncIOEventEmitter</code> was utilized, any built-in or custom implementation could be employed. </li> <li> Triggering the Event: Finally, by using the <code>emit()</code> method of the event emitter instance, we were able to trigger the  <code>GreetEvent</code>, which resulted in the execution of the <code>handle_greet_event()</code> callback. </li> </ol> <p>     \u2003\u2003Having gained a clear understanding of the workflow showcased in the <code>Hello, World!</code> example,     you are now well-equipped to explore more intricate event-driven scenarios and fully harness the capabilities of      Pyventus in your own projects. For a deep dive into the package's functionalities, you can refer to the      Pyventus Tutorials or API. </p>"},{"location":"#a-practical-example","title":"A Practical Example","text":"<p>     \u2003\u2003To showcase Pyventus' event-driven capabilities in a real-world scenario, we will explore a practical      example of implementing a voltage sensor using an event-driven architecture (crucial for such scenarios). The      purpose of this example is to create an efficient voltage sensor that can seamlessly handle real-time data      and respond appropriately to specific voltage conditions. </p> Example \u2500 Monitoring Voltage Levels Across Devices (Context) <p> </p> <p> \u2003\u2003A common aspect found in many systems is the need to monitor and respond to changes in sensor data.     Whether it's pressure sensors, temperature sensors, or other types, capturing and reacting to sensor data is crucial     for effective system operation. In our practical example, we will focus on a specific scenario: building a sensor      system that monitors voltage levels across devices. The goal of our voltage sensor is to detect potential issues,     such as low or high voltage conditions, and respond appropriately in real-time. </p> <p>     \u2003\u2003To accomplish our goal, we will define a <code>VoltageSensor</code> class to read voltage levels and emit      events based on predefined thresholds. We will create event handlers to respond to these events, performing actions      such as activating eco-mode for low voltage or implementing high-voltage protection. Additionally, a shared event      handler will provide general notifications for out-of-range voltage situations. The code example below illustrates      the implementation of this system. </p> Voltage Sensor System with Pyventus (Practical Example)<pre><code>import asyncio\nimport random\n\nfrom pyventus.events import EventEmitter, EventLinker, AsyncIOEventEmitter\n\n\nclass VoltageSensor:\n\n    def __init__(self, name: str, low: float, high: float, event_emitter: EventEmitter) -&gt; None:\n        # Initialize the VoltageSensor object with the provided parameters\n        self._name: str = name\n        self._low: float = low\n        self._high: float = high\n        self._event_emitter: EventEmitter = event_emitter\n\n    async def __call__(self) -&gt; None:\n        # Start voltage readings for the sensor\n        print(f\"Starting voltage readings for: {self._name}\")\n        print(f\"Low: {self._low:.3g}v | High: {self._high:.3g}v\\n-----------\\n\")\n\n        while True:\n            # Simulate sensor readings\n            voltage: float = random.uniform(0, 5)\n            print(\"\\tSensor Reading:\", \"\\033[32m\", f\"{voltage:.3g}v\", \"\\033[0m\")\n\n            # Emit events based on voltage readings\n            if voltage &lt; self._low:\n                self._event_emitter.emit(\"LowVoltageEvent\", sensor=self._name, voltage=voltage)\n            elif voltage &gt; self._high:\n                self._event_emitter.emit(\"HighVoltageEvent\", sensor=self._name, voltage=voltage)\n\n            await asyncio.sleep(1)\n\n\n@EventLinker.on(\"LowVoltageEvent\")\ndef handle_low_voltage_event(sensor: str, voltage: float):\n    print(f\"\ud83e\udeab Turning on eco-mode for '{sensor}'. ({voltage:.3g}v)\\n\")\n    # Perform action for low voltage...\n\n\n@EventLinker.on(\"HighVoltageEvent\")\nasync def handle_high_voltage_event(sensor: str, voltage: float):\n    print(f\"\u26a1 Starting high-voltage protection for '{sensor}'. ({voltage:.3g}v)\\n\")\n    # Perform action for high voltage...\n\n\n@EventLinker.on(\"LowVoltageEvent\", \"HighVoltageEvent\")\ndef handle_voltage_event(sensor: str, voltage: float):\n    print(f\"\\033[31m\\nSensor '{sensor}' out of range.\\033[0m (Voltage: {voltage:.3g})\")\n    # Perform notification for out of range voltage...\n\n\nasync def main():\n    # Initialize the sensor and run the sensor readings\n    sensor = VoltageSensor(name=\"PressureSensor\", low=0.5, high=3.9, event_emitter=AsyncIOEventEmitter())\n    await asyncio.gather(sensor(), )  # Add new sensors inside the 'gather' for multi-device monitoring\n\n\nasyncio.run(main())\n</code></pre> <p>     \u2003\u2003As we can see from this practical example, Pyventus enables us to easily build an event-driven system      for voltage sensors that is flexible, efficient, and highly responsive. With its intuitive API and support for both     synchronous and asynchronous operations, we were able to effectively monitor voltage levels, detect anomalies, and      trigger appropriate actions in real-time. </p>"},{"location":"#support-for-synchronous-and-asynchronous-code","title":"Support for Synchronous and Asynchronous Code","text":"<p>     \u2003\u2003Pyventus is designed from the ground up to seamlessly support both synchronous and asynchronous     programming models. Its unified sync/async API allows you to define event callbacks and emit events across      <code>sync</code> and <code>async</code> contexts. </p>"},{"location":"#subscribing-event-handlers-with-sync-and-async-callbacks","title":"Subscribing Event Handlers with <code>Sync</code> and <code>Async</code> Callbacks","text":"<pre><code>@EventLinker.on(\"MyEvent\")\ndef sync_event_callback():\n    pass  # Synchronous event handling\n\n\n@EventLinker.on(\"MyEvent\")\nasync def async_event_callback():\n    pass  # Asynchronous event handling\n</code></pre> You can optimize the execution of your callbacks based on their workload... <p>     \u2003\u2003By default, event handlers in Pyventus are executed concurrently during an event emission, running their     <code>sync</code> and <code>async</code> callbacks as defined. However, if you have a <code>sync</code> callback     that involves I/O or non-CPU bound operations, you can enable the <code>force_async</code> parameter to offload it     to a thread pool, ensuring optimal performance and responsiveness. The <code>force_async</code> parameter utilizes      the <code>asyncio.to_thread()</code>     function to execute <code>sync</code> callbacks asynchronously. </p> <pre><code>@EventLinker.on(\"BlockingIO\", force_async=True)\ndef blocking_io():\n    print(f\"start blocking_io at {time.strftime('%X')}\")\n    # Note that time.sleep() can be replaced with any blocking\n    # IO-bound operation, such as file operations.\n    time.sleep(1)\n    print(f\"blocking_io complete at {time.strftime('%X')}\")\n</code></pre>"},{"location":"#emitting-events-from-sync-and-async-contexts","title":"Emitting Events from <code>Sync</code> and <code>Async</code> Contexts","text":"<pre><code># Emitting an event within a sync function\ndef sync_function(event_emitter: EventEmitter):\n    event_emitter.emit(\"MyEvent\")\n\n\n# Emitting an event within an async function\nasync def async_function(event_emitter: EventEmitter):\n    event_emitter.emit(\"MyEvent\")\n</code></pre> Event propagation within different contexts... <p>     \u2003\u2003While Pyventus provides a base <code>EventEmitter</code> class with a unified sync/async API, the      specific propagation behavior when emitting events may vary depending on the concrete <code>EventEmitter</code>     used. For example, the <code>AsyncIOEventEmitter</code> implementation leverages the <code>AsyncIO</code> event     loop to schedule callbacks added from asynchronous contexts without blocking. But alternative emitters could      structure propagation differently to suit their needs. </p>"},{"location":"#runtime-flexibility-and-customization","title":"Runtime Flexibility and Customization","text":"<p>     \u2003\u2003At its core, Pyventus utilizes a modular event emitter design that allows you to switch seamlessly     between different built-in or custom event emitter      implementations on the fly. Whether you opt for official emitters or decide to create your custom ones, Pyventus      allows you to tailor the behavior and capabilities of the event emitters to perfectly align with your unique      requirements. </p>"},{"location":"#swapping-event-emitter-implementations-at-runtime","title":"Swapping Event Emitter Implementations at Runtime","text":"<p>     \u2003\u2003By leveraging the principle of dependency inversion and using the base <code>EventEmitter</code> as a     dependency, you can change the concrete implementation on the fly. Let's demonstrate this using the AsyncIO      Event Emitter and the Executor Event Emitter:  </p> Event Emitter Runtime Flexibility Example<pre><code>from pyventus.events import EventLinker, EventEmitter, AsyncIOEventEmitter, ExecutorEventEmitter\n\n\n@EventLinker.on(\"GreetEvent\")\ndef handle_greet_event(name: str = \"World\"):\n    print(f\"Hello, {name}!\")\n\n\nif __name__ == \"__main__\":\n    def main(event_emitter: EventEmitter) -&gt; None:\n        event_emitter.emit(\"GreetEvent\", name=type(event_emitter).__name__)\n\n\n    main(event_emitter=AsyncIOEventEmitter())\n    with ExecutorEventEmitter() as executor_event_emitter:\n        main(event_emitter=executor_event_emitter)\n</code></pre>"},{"location":"#defining-custom-event-emitters","title":"Defining Custom Event Emitters","text":"<p>     \u2003\u2003To illustrate Pyventus' customization capabilities, we will define and implement a custom event emitter     class for the FastAPI framework. This class will efficiently handle the execution of event emissions through its      background tasks workflow. </p> Custom Event Emitter Example<pre><code>from fastapi import BackgroundTasks\n\nfrom pyventus.events import EventEmitter, EventLinker\n\n\nclass FastAPIEventEmitter(EventEmitter):\n    \"\"\"A custom event emitter that uses the FastAPI background tasks.\"\"\"\n\n    def __init__(self, background_tasks: BackgroundTasks):\n        super().__init__(event_linker=EventLinker, debug=False)\n        self._background_tasks = background_tasks\n\n    def _process(self, event_emission: EventEmitter.EventEmission) -&gt; None:\n        self._background_tasks.add_task(event_emission)  # Process the event emission as a background task\n</code></pre> Official <code>FastAPIEventEmitter</code> Integration. <p>     In case you're interested in integrating Pyventus with FastAPI, you can refer to the official Pyventus      FastAPI Event Emitter implementation. </p>"},{"location":"#event-objects-and-global-events","title":"Event Objects and Global Events","text":"<p>     \u2003\u2003In addition to string events, Pyventus also supports Event Objects, which provide a structured way to      define events and encapsulate relevant data payloads. </p> Event Object Example<pre><code>@dataclass  # Define a Python dataclass representing the event and its payload.\nclass OrderCreatedEvent:\n    order_id: int\n    payload: dict[str, any]\n\n\n@EventLinker.on(OrderCreatedEvent)  # Subscribe event handlers to the event.\ndef handle_order_created_event(event: OrderCreatedEvent):\n    # Pyventus will automatically pass the Event Object \n    # as the first positional argument.\n    print(f\"Event Object: {event}\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\n    event=OrderCreatedEvent(  # Emit an instance of the event!\n        order_id=6452879,\n        payload={},\n    ),\n)\n</code></pre> <p>     \u2003\u2003Furthermore, Pyventus provides support for Global Events, which are particularly useful for      implementing cross-cutting concerns such as logging, monitoring, or analytics. By subscribing event handlers to     <code>...</code> or <code>Ellipsis</code>, you can capture all events that may occur within that      <code>EventLinker</code> context. </p> Global Event Example<pre><code>@EventLinker.on(...)\ndef handle_any_event(*args, **kwargs):\n    print(f\"Perform logging...\\nArgs: {args}\\tKwargs: {kwargs}\")\n\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()\nevent_emitter.emit(\"GreetEvent\", name=\"Pyventus\")\n</code></pre>"},{"location":"#success-and-error-handling","title":"Success and Error Handling","text":"<p>     \u2003\u2003With Pyventus, you can customize how events are handled upon completion, whether they succeed or      encounter errors. This customization is achieved by using either the EventLinker's <code>on()</code> or      <code>once()</code> decorator within a <code>with</code> statement block. Inside this block, you can      define not only the event callbacks but also the overall workflow of the event. Now, let\u2019s explore      this simple yet powerful Pythonic syntax of Pyventus through an example. </p> Success and Error Handling Example<pre><code>from pyventus.events import EventLinker, EventEmitter, AsyncIOEventEmitter\n\n# Create an event linker for the \"DivisionEvent\"\nwith EventLinker.on(\"DivisionEvent\") as linker:\n    @linker.on_event\n    def divide(a: float, b: float) -&gt; float:\n        return a / b\n\n    @linker.on_success\n    def handle_success(result: float) -&gt; None:\n        print(f\"Division result: {result:.3g}\")\n\n    @linker.on_failure\n    def handle_failure(e: Exception) -&gt; None:\n        print(f\"Oops, something went wrong: {e}\")\n\nevent_emitter: EventEmitter = AsyncIOEventEmitter()  # Create an event emitter\nevent_emitter.emit(\"DivisionEvent\", a=1, b=0)  # Example: Division by zero\nevent_emitter.emit(\"DivisionEvent\", a=1, b=2)  # Example: Valid division\n</code></pre> <p>     \u2003\u2003As we have seen from the example, Pyventus offers a reliable and Pythonic solution for customizing      event handling. By utilizing the EventLinker and its decorators within a <code>with</code> statement block, we     were able to define the <code>DivisionEvent</code> and specify the callbacks for division, success, and failure     cases. </p>"},{"location":"#continuous-evolution","title":"Continuous Evolution","text":"<p>     \u2003\u2003Pyventus continuously adapts to support developers across technological and programming domains. Its     aim is to remain at the forefront of event-driven design. Future development may introduce new official event      emitters, expanding compatibility with different technologies through seamless integration. </p> <p>     \u2003\u2003Current default emitters provide reliable out-of-the-box capabilities for common use cases. They     efficiently handle core event operations and lay the foundation for building event-driven applications. </p> Driving Innovation Through Collaboration <p>     \u2003\u2003Pyventus is an open source project that welcomes community involvement. If you wish to contribute     additional event emitters, improvements, or bug fixes, please check the Contributing      section for guidelines on collaborating. Together, we can further the possibilities of event-driven development. </p>"},{"location":"#license","title":"License","text":"<p>     \u2003\u2003Pyventus is distributed as open source software and is released under the MIT License.      You can view the full text of the license in the <code>LICENSE</code>      file located in the Pyventus repository. </p>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>     Thank you for being interested in contributing to Pyventus! Your involvement is greatly appreciated \u2764\ufe0f </p>"},{"location":"contributing/#getting-started","title":"Getting Started","text":"<p>     \u2003\u2003Before creating an issue or pull request, please make sure to check if a similar discussion already     exists. We encourage you to actively participate by engaging in existing issues. </p>"},{"location":"contributing/#reporting-issues","title":"Reporting Issues","text":"<p>     \u2003\u2003If you have any questions, bug reports, or feature requests, please open a new issue or discussion.      When reporting issues, be sure to provide clear steps to reproduce the problem. For security vulnerabilities,      please refer to our security policy. </p>"},{"location":"contributing/#submitting-changes","title":"Submitting Changes","text":"<p>     \u2003\u2003We greatly appreciate your contributions and want to ensure they align with the project's goals and      quality standards. Unless your proposed change is trivial, such as fixing a typo or tweaking documentation, we     recommend creating an issue or discussion to talk about the proposed change before submitting a pull request.      This allows us to provide feedback, clarify requirements, and ensure your efforts are focused in the right      direction. To make a contribution, please follow these steps: </p> <ol> <li>Fork the repository and create a new branch.</li> <li>Implement your changes in the branch.</li> <li>Ensure that formatting, linting, and tests pass.</li> <li>Whenever possible, include tests to cover the lines of code you added or modified.</li> <li>Commit your changes and submit a pull request with a clear, detailed message.</li> </ol> <p>     \u2003\u2003We'll review your pull request to ensure it meets our quality standards before merging it into the main     codebase. Please feel free to ask any questions along the way! </p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":"<p>     \u2003\u2003We recommend developing in a virtual environment to      isolate project dependencies. To set up your development environment, follow these steps: </p> <ol> <li> <p>Create a virtual environment:</p> <pre><code>python -m venv venv\n</code></pre> </li> <li> <p>Activate the environment with:</p>  macOS Windows Linux <pre><code>. venv/bin/activate\n</code></pre> <pre><code>. venv/Scripts/activate\n</code></pre> <pre><code>. venv/bin/activate\n</code></pre> </li> <li> <p>Install development dependencies:</p> <pre><code>pip install -e .[dev]\n</code></pre> </li> </ol>"},{"location":"contributing/#running-the-tests","title":"Running the Tests","text":"<p>     During development, you have two options to run the test suite: </p> ManualUsing Hatch <pre><code>pytest -v\n</code></pre> <pre><code>hatch run tests:test\n</code></pre> <p>Validating New Event Emitters</p> <p><p>     When implementing new event emitters, it is crucial to ensure their seamless integration with other     event emitters and the entire package. To achieve this, we kindly request that you utilize the provided test      suite specifically designed for testing new event emitters. </p></p>"},{"location":"contributing/#checking-types","title":"Checking Types","text":"<p>     You can use the mypy tool to check the static typing of your code. Simply run the     following command: </p> ManualUsing Hatch <pre><code>mypy\n</code></pre> <pre><code>hatch run tests:typing\n</code></pre>"},{"location":"contributing/#code-coverage","title":"Code Coverage","text":"<p>     To check the code coverage of your changes, run the following command: </p> ManualUsing Hatch <pre><code>coverage run -m pytest -v\n</code></pre> <pre><code>hatch run tests:cov\n</code></pre>"},{"location":"contributing/#pyventus-documentation","title":"Pyventus Documentation","text":"<p>     \u2003\u2003The documentation for our project is written in Markdown and built using Material for MkDocs.     Additionally, the API documentation is generated from the docstrings using mkdocstrings.     To begin working on the documentation in a development environment, simply execute the following command: </p> ManualUsing Hatch <pre><code>mkdocs serve --dev-addr localhost:8000\n</code></pre> <pre><code>hatch run docs:serve\n</code></pre>"},{"location":"contributing/#project-structure-and-conventions","title":"Project Structure and Conventions","text":"<p>     \u2003\u2003This project follows the src-layout convention     for Python packages. This convention improves code organization, facilitates easy testing and usage, and allows      developers to install the package in editable mode.     By adhering to this convention, we can validate the package thoroughly in a realistic environment, leading to a      higher quality and user-friendly product. </p>"},{"location":"contributing/#code-standards","title":"Code Standards","text":"<p>     We strive for a high-quality and maintainable codebase. To achieve this, we have established the following code      standards: </p> <ul> <li>PEP-8 Compliance \u2500  Please follow the guidelines outlined in PEP-8 for consistent code formatting.  Adhering to these standards ensures readability and maintainability across our codebase. </li> <li>Black Formatter \u2500  We recommend using the Black code formatter to ensure consistent style and formatting. By automatically enforcing a standard style, the Black formatter saves you time and effort in manual formatting. </li> <li>Meaningful Naming \u2500  Use descriptive and meaningful names for variables, functions, and classes. Clear and intuitive naming enhances code  comprehension, making it easier for everyone to understand and work with the code. </li> <li>Modularity and Reusability \u2500  Encourage the development of modular and reusable code. Breaking down complex tasks into smaller, self-contained  components promotes maintainability, reduces complexity, and allows for scalability and extensibility. </li> <li>Optimization and Efficiency \u2500  Strive for efficient code by considering algorithmic complexity and optimizing where necessary. Writing code that is both correct and performant ensures responsive and scalable applications. </li> </ul>"},{"location":"contributing/#documentation-style","title":"Documentation Style","text":"<p>     \u2003\u2003Clear and comprehensive documentation facilitates collaboration and understanding. When contributing     to this project, please ensure that you document the following items using properly formatted docstrings: </p> <ul> <li>Modules.</li> <li>Class definitions.</li> <li>Function definitions.</li> <li>Module-level variables.</li> </ul> <p>     \u2003\u2003Pyventus uses Sphinx docstrings formatted according to     PEP 257 guidelines. For more examples and detailed guidance on using Sphinx-style docstrings, we encourage     you to consult the official Sphinx documentation. </p>"},{"location":"contributing/#pre-submission-testing-and-validation","title":"Pre-Submission Testing and Validation","text":"<p>     \u2003\u2003Before submitting your pull request, it is crucial to ensure that your changes pass all the necessary     checks. To do so, simply run the following command: </p> <pre><code>hatch run tests:all\n</code></pre> <p>     \u2003\u2003The above command will trigger the Hatch project manager to initiate the comprehensive testing process     across all supported Python versions. It will run tests, perform typing checks, ensure code formatting, and measure     code coverage. This ensures that your changes meet the required quality standards. </p> <p>Testing for Individual Python Versions</p> <p><p>     If you want to test for specific Python versions, you can do so by specifying the desired versions in the      command, as follows: </p></p> Python 3.10Python 3.11Python 3.12Python 3.13 <pre><code>hatch run +py=3.10 tests:all\n</code></pre> <pre><code>hatch run +py=3.11 tests:all\n</code></pre> <pre><code>hatch run +py=3.12 tests:all\n</code></pre> <pre><code>hatch run +py=3.13 tests:all\n</code></pre> <p>Troubleshooting Hatch Environment Errors</p> <p><p>     If commands run successfully when executed manually but produce unexpected errors or misbehavior when run      within a Hatch environment, even though the dependencies are declared correctly, this could indicate an      issue with the Hatch environment cache. To resolve potential cache-related issues, you can remove the      environment and clear its cache by running: </p></p> <pre><code>hatch env remove [ENV_NAME]\n</code></pre> <p><p>     Alternatively, you can remove all environments and their cache by running the following command: </p></p> <pre><code>hatch env prune\n</code></pre>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>     \u2003\u2003This project and everyone participating in it is governed by the Pyventus Code of Conduct.      By participating, you are expected to uphold this code. Please report unacceptable behavior. </p>"},{"location":"contributing/#thanks-in-advance","title":"Thanks in Advance!","text":"<p>     \u2003\u2003Thank you for considering contributing to this project. Your contributions are valuable      and greatly appreciated. If you have any questions or need further clarification, please don't      hesitate to reach out. We look forward to collaborating with you to enhance this project! </p> <p></p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>     \u2003\u2003Welcome to the Getting Started section! This guide will help you install and configure Pyventus in     your project. For more detailed information on how to use this package, you can refer to the Pyventus      Tutorials or API Reference. </p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>     \u2003\u2003By default, Pyventus' core functionalities and default event emitter implementations, such as the     AsyncIO Event Emitter, and the Executor Event Emitter,      only require Python 3.10+ with no additional dependencies. However, these requirements may expand if you opt to      use alternative built-in event emitter implementations. </p>"},{"location":"getting-started/#installation","title":"Installation","text":"<p>     \u2003\u2003Pyventus is published as a Python package      and can be installed using <code>pip</code>, ideally in a virtual environment     for proper dependency isolation. To get started, open up a terminal and install Pyventus with the following command: </p> <pre><code>pip install pyventus\n</code></pre>"},{"location":"getting-started/#optional-dependencies","title":"Optional Dependencies","text":"<p>     \u2003\u2003 While Pyventus primarily relies on the Python standard library, it also supports optional dependencies     to access additional features, as shown below: </p>"},{"location":"getting-started/#supported-library-integrations","title":"Supported Library Integrations","text":"<ul> <li> Celery \u2500  Pyventus integrates with Celery using the <code>CeleryEventEmitter</code>, enabling event emissions to be executed on Celery worker nodes to improve task processing. To install Pyventus with Celery  support, use the following command:  <pre><code>pip install pyventus[celery] (1)\n</code></pre> </li> <ol> <li> <p>Optional Package Dependencies     \u2003\u2003This package includes some optional dependencies. For more information, please visit the     Celery bundles documentation.</p> <p>These optional dependencies can be installed as described in their individual documentation. For example:    <pre><code>pip install celery[...]\n</code></pre></p> </li> </ol> <li> Redis Queue (RQ) \u2500  Pyventus integrates with Redis Queue (RQ) using the <code>RQEventEmitter</code>, allowing  event emissions to run as background jobs through RQ's asynchronous workers. To install Pyventus with RQ support, use the following command:  <pre><code>pip install pyventus[rq]\n</code></pre> </li> </ul> <ul> <li> FastAPI \u2500  Pyventus integrates with the FastAPI framework using the <code>FastAPIEventEmitter</code>,  enabling event-driven architectures to be built directly into FastAPI applications. The emitter leverages FastAPI's  background tasks to asynchronously process event emissions without blocking responses. To install Pyventus with  FastAPI integration, use the following command:  <pre><code>pip install pyventus[fastapi] (1)\n</code></pre> </li> <ol> <li> <p>Optional Package Dependencies     \u2003\u2003This package includes some optional dependencies. For more information, please visit the     FastAPI optional dependencies.</p> <p>These optional dependencies can be installed as described in their individual documentation. For example:    <pre><code>pip install fastapi[...]\n</code></pre></p> </li> </ol> </ul> <p>You can install all of them with:</p> <pre><code>pip install pyventus[all]\n</code></pre> <p></p>"},{"location":"getting-started/#supported-framework-integrations","title":"Supported Framework Integrations","text":""},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#0.7.0","title":"v0.7.0 Unreleased","text":""},{"location":"release-notes/#0.7.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li> <p>The <code>typing-extensions</code> package is now a required dependency for Pyventus. This dependency has been added to support advanced typing features in older versions of Python.</p> </li> <li> <p>All previous event-driven features must now be imported from the inner package <code>pyventus.events</code> instead of directly from <code>pyventus</code>. These changes were necessary due to the integration of the reactive programming paradigm. This series of refactors were implemented not only to ensure an organized codebase but also to establish a clear boundary between event handling and reactive programming features, enabling optimized imports based on the required paradigm.</p> </li> <li> <p>The inheritance structure of the <code>EventEmitter</code> has been replaced with composition using the new <code>ProcessingService</code> interface. This interface establishes a common ground for processing calls, such as event emissions, in a decoupled and flexible manner. The <code>EventEmitter</code> is now a concrete class that requires a <code>ProcessingService</code> instance, referred to as <code>event_processor</code>, for initialization. These changes not only preserve the overall behavior and workflow of the <code>EventEmitter</code> but also enhance its modularity and flexibility.</p> </li> <li> <p>The <code>EventLinker</code> class has experienced multiple method renames and return type modifications to align with the new redesigned codebase, enhancing the API for improved usability and intuitiveness. Below is a detailed list of the breaking changes made to the <code>EventLinker</code> class:</p> <ul> <li>The inner class <code>EventLinkageWrapper</code> was renamed to <code>EventLinkerSubCtx</code> for consistency with the new concept of a subscription context and now extends from the base class <code>SubscriptionContext</code>. The overall workflow remains roughly the same but was reworked to align with its base class and introduce optimizations based on user needs.</li> <li>The method <code>get_events()</code> now returns a <code>set</code> of all registered events instead of a <code>list</code> with non-duplicated events.</li> <li>The method <code>get_event_handlers()</code> was renamed to <code>get_subscribers()</code> for consistency, and it now returns a <code>set</code>of all registered subscribers instead of a <code>list</code> with non-duplicated subscribers.</li> <li>The method <code>get_events_by_event_handler()</code> was renamed to <code>get_events_from_subscribers()</code> for consistency. It now returns a <code>set</code> of events associated with the specified subscribers instead of a <code>list</code> of non-duplicated events associated with the specified subscribers. This method now also supports retrieving events from multiple subscribers instead of only one at a time.</li> <li>The method <code>get_event_handlers_by_events()</code> was renamed to <code>get_subscribers_from_events()</code> for consistency. It now returns a <code>set</code> of subscribers associated with the specified events instead of a <code>list</code> of non-duplicated subscribers associated with the provided events. Additionally, a new flag called <code>pop_onetime_subscribers</code> was added to remove and return those subscribers that are one-time subscriptions.</li> <li>The method <code>unsubscribe()</code> was renamed to <code>remove()</code> for consistency with the new concept of subscription and the encapsulation of the unsubscription process through the <code>teardown_callback</code>. This method now allows you to remove one event and subscriber from the registry at a time instead of multiple events of the given subscriber.</li> <li>The method <code>remove_event_handler()</code> was renamed to <code>remove_subscriber()</code> for consistency.</li> <li>Parameters named <code>event_handler</code> were renamed to <code>subscriber</code> for consistency.</li> </ul> </li> <li> <p>The <code>EventHandler</code> has been refactored from a class to an interface, outlining the overall workflow and essential protocols for event handling. However, the previous implementation of the <code>EventHandler</code> has been transitioned to one of its concrete classes named <code>EventSubscriber</code>. This new <code>EventSubscriber</code> class not only implements the <code>EventHandler</code> interface but also combines it with the <code>Subscription</code> base class, providing a convenient way to both handle event responses and manage the subscription lifecycle.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-added","title":"Added","text":"<ul> <li> <p>Added a reactive programming module to expand Python's event-driven capabilities for data-oriented processes and the ability to react efficiently to state changes over time.</p> <ul> <li>Added the <code>Observable</code> base class, which defines a lazy push-style notification mechanism for streaming data to subscribers.</li> <li>Added the <code>ObservableTask</code> class, an observable subclass that encapsulates a unit of work and offers a mechanism for streaming its results reactively.</li> <li>Added the <code>as_observable_task()</code> decorator to easily convert any given callable into an observable task.</li> <li>Added the <code>Observer</code> interface, which defines the overall workflow and essential protocols for responding to notifications from an observable.</li> <li>Added the <code>Subscriber</code> class, which combines the <code>Observer</code> interface with the <code>Subscription</code> base class to provide a convenient way to respond to state changes emitted by an observable and manage the subscription lifecycle.</li> </ul> </li> <li> <p>Added the <code>Unsubscribable</code> interface, which provides a standardized method for objects to unsubscribe from a source and release any associated resources.</p> </li> <li> <p>Added the <code>Subscription</code> base class to simplify subscription management and resource cleanup with a <code>teardown_callback</code> that is called during unsubscription.</p> </li> <li> <p>Added the <code>SubscriptionContext</code> base class, which defines the overall workflow for subscription contexts, allowing the user to define step-by-step the object that will later be subscribed to the specified source.</p> </li> <li> <p>Added a new package global exception called <code>PyventusImportException</code>, which is a custom Pyventus exception for handling missing imports within the library.</p> </li> <li> <p>Added the <code>MultiBidict</code> data structure, a generic multikeyed, multivalued bidirectional dictionary that offers a flexible mapping structure for efficient lookups, updates, and deletions of keys and their corresponding values.</p> </li> <li> <p>Introduced the <code>ProcessingService</code> interface to define flexible execution strategies for various use cases. This release includes the following concrete implementations:</p> <ul> <li><code>AsyncIOProcessingService</code>: A processing service that utilizes the <code>AsyncIO</code> framework to handle the execution of calls.</li> <li><code>CeleryProcessingService</code>: A processing service that utilizes the <code>Celery</code> framework to handle the execution of calls.</li> <li><code>ExecutorProcessingService</code>: A processing service that utilizes the Python's <code>Executor</code> to handle the execution of calls.</li> <li><code>FastAPIProcessingService</code>: A processing service that uses FastAPI's <code>BackgroundTasks</code> to handle the execution of calls.</li> <li><code>RedisProcessingService</code>: A processing service that utilizes the <code>Redis Queue</code> framework to handle the execution of calls.</li> </ul> </li> <li> <p>Added the <code>CallableWrapper</code> class to encapsulate callables and provide a unified asynchronous interface for their execution.</p> </li> <li> <p>Added new features to the <code>EventLinker</code> class, including the following methods:</p> <ul> <li>Introduced the <code>get_valid_subscriber()</code> method for a centralized mechanism to validate event subscribers.</li> <li>Added the <code>is_empty()</code> method to efficiently check if the main registry is empty.</li> <li>Added the <code>get_event_count()</code> method to return the total number of events in the registry.</li> <li>Added the <code>get_subscriber_count()</code> method to return the total number of subscribers in the registry.</li> <li>Added the <code>get_event_count_from_subscriber()</code> method to return the number of events for a specific subscriber.</li> <li>Added the <code>get_subscriber_count_from_event()</code> method to return the number of subscribers for a specific event.</li> <li>Added the <code>contains_event()</code> method to check if a specific event is present in the registry.</li> <li>Added the <code>contains_subscriber()</code> method to check if a specific subscriber is present in the registry.</li> <li>Added the <code>are_linked()</code> method to determine if a specific event is linked to a given subscriber.</li> <li>Introduced the <code>stateful_subctx</code> parameter in the <code>once()</code> and <code>on()</code> methods to configure the <code>EventLinkerSubCtx</code> behavior and optimize the subscription context based on user needs.</li> </ul> </li> <li> <p>Introduced the <code>EventSubscriber</code> class, which combines event handling capabilities with subscription lifecycle management.</p> </li> <li> <p>A new <code>benchmarks</code> package has been added to the <code>tests</code> directory for performance evaluation of Pyventus. This release introduces the <code>EventEmitterBenchmark</code>, which measures the efficiency of the <code>EventEmitter</code> in handling event emissions.</p> </li> <li> <p>Added a set of utilities for creating preconfigured event emitter instances, making the setup process easier. These utilities also provide retro compatibility with the previous class-based design.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-changed","title":"Changed","text":"<ul> <li> <p>Enhanced the <code>emit()</code> method in the <code>EventEmitter</code> to support the emission of global events (<code>...</code>).</p> </li> <li> <p>Moved callback utilities to a dedicated module within <code>pyventus.core</code> for improved organization and reusability.</p> </li> <li> <p>Standardized the structure of Python classes and their representation, including the use of the <code>@override()</code> decorator for consistency and <code>mypy</code> static type checking.</p> </li> <li> <p>Standardized the structure of the <code>pyproject.toml</code> file.</p> </li> <li> <p>Enhanced Pyventus logs by adding process and thread IDs for better debugging.</p> </li> <li> <p>Switched from the <code>Black</code> formatter to <code>Ruff</code> for improved development efficiency and enhanced code quality.</p> </li> <li> <p>Refactored all project docstrings to follow a standardized format, enhancing consistency and clarity in the documentation.</p> </li> <li> <p>Upgraded several development dependencies in the <code>pyproject.toml</code>, including <code>pytest-asyncio</code> from version <code>0.21.0</code> to <code>0.24.0</code>, to enable global configuration of the <code>asyncio_mode</code>.</p> </li> <li> <p>Simplified the <code>EventCallbackType</code> type alias by removing the unnecessary <code>ParamSpec</code>.</p> </li> <li> <p>Refactored the test suite to improve validation across all package features, ensuring correctness and achieving 100% code coverage.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-optimized","title":"Optimized","text":"<ul> <li> <p>The time complexity of the <code>emit()</code> method in the <code>EventEmitter</code> class has been significantly optimized. It has been reduced from \\(O(N \\cdot T)\\) to \\(O(N \\cdot L_{avg})\\), where:</p> <ul> <li>\\(N\\): Represents the total number of subscribers involved in the event emission, including those registered to the global event and those specific to the event being emitted.</li> <li>\\(T\\): Denotes the total number of elements in the event linker registry, encompassing all subscriber lists combined. In mathematical terms, \\(T\\) is defined as \\(\\sum_{e}^{E} S_{e}\\), where \\(S_{e}\\) corresponds to the number of subscribers for the event \\(e\\), and \\(E\\) encompasses all events.</li> <li>\\(L_{avg}\\): Represents the average number of events linked to one-time subscribers during event emission.</li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0This optimization results from the more efficient management of one-time subscribers by the event linker during event emission. Instead of traversing the entire event linker registry (\\(T\\)) to remove each one-time subscriber involved in the event emission (\\(N\\)), it now iterates solely through the linked events (\\(L\\)). This improvement is particularly beneficial when all subscribers engaged in the event emission are one-time subscriptions. However, in scenarios without one-time subscribers during an event emission, both implementations have the same time complexity of \\(O(N)\\).</p> </li> <li> <p>Major optimizations have been implemented for the <code>EventLinker</code> class through the integration of the <code>MultiBidict</code> data structure. This data structure is a multikeyed, multivalued bidirectional dictionary implementation that enables efficient lookups, updates, and deletions of events and their corresponding subscribers. Despite utilizing a bidirectional mapping structure, its memory footprint remains minimal due to the use of references between keys and values instead of duplication, which limits the impact to the additional dictionary and set data structures.</p> <ul> <li> <p>The time complexity of the method <code>get_subscribers()</code>, previously known as <code>get_event_handlers()</code>, has been significantly reduced from \\(O(T)\\) to \\(O(S)\\), where:</p> <ul> <li>\\(T\\): Denotes the total number of elements in the event linker registry, encompassing all subscriber lists combined.</li> <li>\\(S\\): Corresponds to the total number of registered subscribers without duplications.</li> </ul> </li> <li> <p>The time complexity of the <code>get_events_from_subscribers()</code>, previously known as <code>get_events_by_event_handler()</code>, has been reduced from \\(O(T)\\) to \\(O(L)\\), where:</p> <ul> <li>\\(T\\): Denotes the total number of elements in the event linker registry, encompassing all subscriber lists combined.</li> <li>\\(L\\): Represents the total number of events linked to the given subscriber.</li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0It is important to note that the new method of <code>get_events_from_subscribers()</code> can receive not only one subscriber as before but also multiple subscribers to retrieve the associated events. In cases where multiple subscribers are provided, the time complexity of the overall method would be \\(O(N \\cdot L_{avg})\\), where \\(N\\) corresponds to the number of distinct subscribers for which to query the linked events, and \\(L_{avg}\\) represents the average number of events associated with each subscriber.</p> </li> <li> <p>The time complexity of the method <code>remove_subscriber()</code>, previously known as <code>remove_event_handler()</code>, has been significantly reduced from \\(O(T)\\) to \\(O(L)\\), where:</p> <ul> <li>\\(T\\): Denotes the total number of elements in the event linker registry, encompassing all subscriber lists combined.</li> <li>\\(L\\): Represents the total number of events linked to the given subscriber.</li> </ul> </li> <li> <p>The time complexity of the method <code>remove()</code>, previously known as <code>unsubscribe()</code>, has been enhanced from \\(O(S)\\) to a constant time complexity of \\(O(1)\\), where \\(S\\) represents the size of the subscriber list registered for the given event. It is important to note that while the previous comparison was made based on the <code>unsubscribe()</code> method handling just one event, under similar conditions to the <code>remove()</code> method, the previous implementation actually supported removing the subscriber from multiple events. The achievement of the new \\(O(1)\\) time complexity is based on the efficiency of <code>set</code> operations in Python.</p> </li> </ul> </li> <li> <p>Introduced <code>__slots__</code> in several classes to optimize memory usage and enhance attribute access speed.</p> </li> </ul>"},{"location":"release-notes/#0.7.0-benchmarks","title":"Benchmarks","text":"<p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Finally, to provide a quick visualization of the overall improvements and illustrate the time complexity enhancements of this upcoming release, a series of benchmarks were conducted. These benchmarks were specifically designed for the event emission process, as it encompasses all event-driven features and provides a clear overview of the improvements. Following this, a detailed explanation of the benchmarks and their results is presented.</p> <ul> <li> <p>Methodology: The benchmarks utilized a volume testing approach to assess how different subscription counts affect the event emission time.</p> </li> <li> <p>Environment: The benchmarks were conducted in the following environment:</p> <ul> <li>Operating System: Windows 11 64bit (v10.0.22631)</li> <li>CPU: AMD Ryzen 5 2600, 3400.0 MHz, 6 cores, 12 logical processors</li> <li>Total Memory: 16 GB</li> <li>Python Version: 3.12.7</li> </ul> </li> <li> <p>Setup: The benchmark setup consisted of two key components: a main Python script that managed the overall workflow of the benchmarks and the <code>EventEmitterBenchmark</code> class, which was essential for standardizing and organizing the performance tests. Following this, the main workflow of the benchmarks will be outlined, including the required packages and the adjustable settings available for different tests.</p> <p> Benchmark Workflow and Settings (<code>main.py</code>) <p>Before running the benchmarks, make sure all necessary packages are installed. You can install them using the following <code>pip</code> command:</p> <pre><code>pip install pyventus[tests]\n</code></pre> <p>Additionally, an extra package is required for visualizing the results: <code>matplotlib</code>. You can also install it with a <code>pip</code> command as follows:</p> <pre><code>pip install matplotlib\n</code></pre> <p>Once the packages are installed, you can configure the benchmarks in the <code>main.py</code> script as needed and execute it. The script will first install Pyventus <code>v0.6.0</code>, run the benchmarks in a separate process, and then uninstall it. Next, it will install the current version of Pyventus and run the benchmarks again in another process. Finally, the results for each version will be saved in a <code>JSON</code> file, and plots will be generated based on the benchmark reports.</p> main.py<pre><code>import gc\nimport os\nimport subprocess\nimport sys\nfrom concurrent.futures import ProcessPoolExecutor\nfrom dataclasses import asdict\nfrom json import dumps\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef run_event_emitter_benchmarks():\n    from tests.benchmarks.event_emitter_benchmark import EventEmitterBenchmark\n\n    print(f\"Pyventus v{EventEmitterBenchmark.PYVENTUS_VERSION}\\n\")\n    print(\"Starting benchmarks...\")\n\n    # Define a list of benchmarks to run with different configurations.\n    benchmarks: list[EventEmitterBenchmark] = [\n        # Benchmark with SINGLE event subscription mode and NONE one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.SINGLE,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.NONE,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),          \n        # Benchmark with SINGLE event subscription mode and ALL one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.SINGLE,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.ALL,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),\n        # Benchmark with ALL event subscription mode and ALL one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.ALL,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.ALL,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=5,\n            num_executions=1250,\n        ),\n        # Benchmark with RANDOM event subscription mode and RANDOM one-time subscriptions.\n        EventEmitterBenchmark(\n            event_subscription_mode=EventEmitterBenchmark.EventSubscriptionMode.RANDOM,\n            onetime_subscription_mode=EventEmitterBenchmark.OneTimeSubscriptionMode.RANDOM,\n            subscription_sizes=[100, 500, 1000, 5000, 10000],\n            num_repeats=3,\n            num_executions=500,\n        ),\n    ]\n\n    # Initialize an empty list to store reports generated by the benchmarks.\n    reports: list[EventEmitterBenchmark.Report] = []\n\n    # Iterate through each benchmark and execute it.\n    for benchmark in benchmarks:\n        reports.append(benchmark())\n\n    # Return the list of reports.\n    return reports\n\ndef plot_event_emitter_benchmark_comparison(\n    title: str, subscription_sizes: list[int], benchmark_bars: dict[tuple[str, str], list[float]], output_file: str\n) -&gt; None:\n    # Prepare the x positions for the bars based on the number of subscription sizes\n    x_positions = np.arange(len(subscription_sizes))\n    bar_width = 0.355  # Width of each bar\n    bar_offset = 0  # Offset for positioning bars\n\n    # Create a figure and axis for the plot\n    fig, ax = plt.subplots(figsize=(9.6, 5), layout=\"constrained\")\n\n    # Initialize the maximum y-value for setting the y-axis limit later\n    max_y_value = 0\n\n    # Loop through each benchmark report to create bars\n    for (label, color), heights in benchmark_bars.items():\n        # Calculate the offset for the current set of bars\n        current_offset = bar_width * bar_offset\n\n        # Create bars for the current benchmark data\n        bars = ax.bar(x=(x_positions + current_offset), height=heights, width=bar_width, label=label, color=color)\n\n        # Add labels on top of the bars with formatted emission times\n        ax.bar_label(bars, padding=2, fontsize=10, fmt=lambda value: f\"{value:.5f}\")\n\n        # Update the maximum y-value if the current heights exceed it\n        max_y_value = max(max(heights), max_y_value)\n\n        # Increment the offset for the next set of bars\n        bar_offset += 1\n\n    # Set plot title and labels\n    ax.set_title(title, fontsize=10, pad=0)\n    ax.legend(loc=\"upper left\", ncols=3)\n    ax.set_xlabel(\"Subscription Count\", labelpad=7)\n    ax.set_ylabel(\"Event Emission Time (seconds)\", labelpad=7)\n\n    # Set x-ticks to correspond to subscription sizes\n    ax.set_xticks(x_positions + (bar_width / 2), subscription_sizes)\n\n    # Set y-axis limit to accommodate the highest bar with some padding\n    ax.set_ylim(ymax=max_y_value + (max_y_value * 0.15), auto=True)\n\n    # Save the plot to the specified filename\n    plt.savefig(output_file)\n\ndef main():\n    def clear_console():\n        \"\"\"Clear the console based on the operating system.\"\"\"\n        if os.name == \"nt\":  # For Windows\n            os.system(\"cls\")\n        else:  # For macOS and Linux\n            os.system(\"clear\")\n\n    def uninstall_pyventus() -&gt; None:\n        \"\"\"Uninstall the currently installed version of pyventus using pip.\"\"\"\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"uninstall\", \"-y\", \"pyventus\"])\n\n    def install_pyventus(version: str = \"\") -&gt; None:\n        \"\"\"Install pyventus using pip, with an optional version parameter.\"\"\"\n        version = (\".\" if version == \".\" else (f\"pyventus=={version}\" if version else \"pyventus\"))\n        subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", version])\n\n    # Uninstall the currently installed version of pyventus to avoid conflicts\n    # and ensure a clean environment for the installation of the specified version (0.6.0).\n    uninstall_pyventus()\n    install_pyventus(version=\"0.6.0\")\n    clear_console()\n\n    # Run the benchmark with pyventus v0.6.0 in a separate process to avoid conflicts.\n    with ProcessPoolExecutor() as executor:\n        fut = executor.submit(run_event_emitter_benchmarks)\n        pyventus_v060_reports = fut.result()\n        clear_console()\n\n    # Remove executor reference\n    del executor\n\n    # Uninstall the current version of pyventus again to prepare for the next version.\n    uninstall_pyventus()\n    install_pyventus(version=\".\")\n    clear_console()\n\n    # Force a garbage collection.\n    gc.collect()\n\n    # Run the benchmark with the current version of pyventus (0.7.0) in a separate process.\n    with ProcessPoolExecutor() as executor:\n        fut = executor.submit(run_event_emitter_benchmarks)\n        pyventus_v070_reports = fut.result()\n        clear_console()\n\n    print(\"Almost done. Saving reports...\")\n\n    # Save the reports for pyventus v0.6.0 to a JSON file.\n    with open(\"dist/pyventus_v060_eeb_reports.json\", \"w\") as f1:\n        f1.write(f\"{dumps([asdict(report) for report in pyventus_v060_reports])}\\n\")\n\n    # Save the reports for pyventus v0.7.0 to a JSON file.\n    with open(\"dist/pyventus_v070_eeb_reports.json\", \"w\") as f2:\n        f2.write(f\"{dumps([asdict(report) for report in pyventus_v070_reports])}\\n\")\n\n    clear_console()\n\n    # Indicate that charts are being generated.\n    print(\"Generating charts...\")\n\n    # Generate comparison charts for the two versions of pyventus.\n    for i, (v060_report, v070_report) in enumerate(zip(pyventus_v060_reports, pyventus_v070_reports, strict=False)):\n        plot_event_emitter_benchmark_comparison(\n            title=(\n                f\"Impact of Subscription Count on Event Emission Time: Comparison of Pyventus v0.6.0 and v0.7.0\\n\"\n                f\"(Event Subscription: {v060_report.event_subscription_mode.capitalize()}, \"\n                f\"One-time Subscription: {v060_report.onetime_subscription_mode.capitalize()}, \"\n                f\"Repeats: {v060_report.num_repeats}, Executions: {v060_report.num_executions})\\n\"\n            ),\n            subscription_sizes=v060_report.subscription_sizes,\n            benchmark_bars={\n                (\"Pyventus v0.6.0\", \"#0aaec4\"): [\n                    measurement.execution_time for measurement in v060_report.measurements\n                ],\n                (\"Pyventus v0.7.0\", \"#fba700\"): [\n                    measurement.execution_time for measurement in v070_report.measurements\n                ],\n            },\n            output_file=f\"dist/pyventus_eeb_chart_{i}.png\",\n        )\n\n    print(\"All Done!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>As shown in the previous script, the <code>EventEmitterBenchmark</code> class provides several parameters that can be configured to tailor the performance tests for various scenarios. This flexibility enables a comprehensive evaluation of the event emission process. Below are the key configurations available in the <code>EventEmitterBenchmark</code> class:</p> <ul> <li> <p>Event Subscription Mode: This parameter defines how event subscriptions behave during the benchmark.</p> <ul> <li>Single: In this mode, each subscriber is limited to a single event.</li> <li>Random: This mode allows subscribers to register for the specified event along with a random selection of additional events from the registry.</li> <li>All: When this mode is selected, subscribers will register for the specified event as well as all other registered events.</li> </ul> </li> <li> <p>One-Time Subscription Mode: This parameter defines how one-time subscriptions are handled in the benchmark.</p> <ul> <li>None: In this mode, no one-time subscribers will be registered; the <code>once</code> property is always set to <code>False</code>.</li> <li>Random: This mode randomizes the <code>once</code> property, allowing for a mix of one-time and regular subscriptions.</li> <li>All: When this mode is selected, all subscriptions are treated as one-time subscriptions; the <code>once</code> property is always set to <code>True</code>.</li> </ul> </li> <li> <p>Subscription Sizes: This parameter specifies a list of varying subscription sizes used in the benchmark.</p> <ul> <li> <p>A mathematical formula is employed to proportionally subdivide the number of events and subscribers based on the specified subscription size.</p> <ul> <li>Number of Events: Calculated as: \\(\\lfloor \\sqrt{num\\_subscriptions} \\rfloor\\).</li> <li>Subscribers per Event: Calculated as: \\(\\lfloor num\\_subscriptions/num\\_events \\rfloor\\).</li> <li>Remaining Subscribers: Calculated as: \\(num\\_subscriptions - num\\_events \\cdot num\\_subscribers\\).</li> </ul> </li> <li> <p>Note that depending on the selected event subscription mode, the number of subscribers per event may exceed the calculated proportion. For instance, if the event subscription mode is set to <code>ALL</code>, each subscriber will be registered across all event sets, resulting in each event set's length being equal to the subscription size.</p> </li> </ul> </li> <li> <p>Number of Repeats: This parameter indicates how many times the benchmark is repeated.</p> </li> <li> <p>Number of Executions: This parameter represents the total number of executions performed during the benchmark.</p> </li> </ul> <li> <p>Metrics Collected: The main metric used to assess the efficiency of the event emission process during the performance tests is the Event Emission Time. This metric tracks the time (in seconds) that it takes to complete the event emission process for each subscription size.</p> </li> <li> <p>Calculation Method: To determine the event emission time for a given subscription size, the event emission process is executed multiple times (as specified by <code>num_executions</code>) and repeated for a number of iterations (as declared by <code>num_repeats</code>). The elapsed time for each execution is recorded, and the median of these recorded times is calculated to establish the event emission time for that repetition, which helps reduce the impact of outliers. Once all repetitions are completed, the final event emission time is determined by calculating the mean of the medians from each repetition. Additionally, to minimize timing noise, the garbage collector is disabled during the tests, and the <code>perf_counter</code> function is used for accurate measurements.</p> </li> <li> <p>Results: </p> <ul> <li> <p>Event Emitter Benchmark 01: This benchmark was configured with the event subscription mode set to Single and the one-time subscription mode set to None. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=NONE)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 1555.6348432,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"None\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0021713468276594356\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.0022923071408520593\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.002319530000003561\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.00234521428777057\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.002376250000902652\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=NONE)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 2232.0822847000018,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"None\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0021696501370083562\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.002224228570831580\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00229092857083158\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.002311342857417113\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.00235225142652442\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00217135 0.00216965 0.08% faster 500 Event Emission Time (s) 0.00229231 0.00222423 2.97% faster 1000 Event Emission Time (s) 0.00231953 0.00229093 1.23% faster 1000 Event Emission Time (s) 0.00234521 0.00231134 1.44% faster 10000 Event Emission Time (s) 0.00237625 0.00235225 1.01% faster </p> </li> <li> <p>Event Emitter Benchmark 02: This benchmark was configured with the event subscription mode set to Single and the one-time subscription mode set to All. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 1613.8905598000001,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.00215918000001238\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.002478313333360442\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00263769000002866\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.0049624499999026707\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.009284669999897231\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=SINGLE, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 2257.228092499994,\n  \"event_subscription_mode\": \"Single\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.002121700000892163\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.0022747199998723815\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.00231161000054562\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.0023325299973394723\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.0023679700057022275\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00215918 0.00212170 1.74% faster 500 Event Emission Time (s) 0.00247831 0.00227472 8.21% faster 1000 Event Emission Time (s) 0.00263769 0.00231161 12.36% faster 5000 Event Emission Time (s) 0.00496245 0.00233253 53% faster 10000 Event Emission Time (s) 0.00928467 0.00236797 74.5% faster </p> </li> <li> <p>Event Emitter Benchmark 03: This benchmark was configured with the event subscription mode set to All and the one-time subscription mode set to All. The test was repeated 5 times, with 1,250 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=ALL, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 16962.5048258,\n  \"event_subscription_mode\": \"All\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0032661600000665203\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.009857880000072327\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.02087080000010246\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.30020038000020577\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 1.607526350000171\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=ALL, onetime_subscription_mode=ALL)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 9898.425464699998,\n  \"event_subscription_mode\": \"All\",\n  \"onetime_subscription_mode\": \"All\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 5,\n  \"num_executions\": 1250,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.002867740001238417\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.007017190001351992\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.01340035999965039\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.10753672999926493\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.2562398899979598\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00326616 0.00286774 12.2% faster 500 Event Emission Time (s) 0.00985788 0.00701719 28.82% faster 1000 Event Emission Time (s) 0.02087080 0.01340036 35.79% faster 5000 Event Emission Time (s) 0.30020038 0.10753673 64.18% faster 10000 Event Emission Time (s) 1.60752635 0.25623989 84.06% faster </p> </li> <li> <p>Event Emitter Benchmark 04: This benchmark was configured with both the event and one-time subscription modes set to Random. The test was repeated 3 times, with 500 executions for each benchmark repetition.</p> <p> Benchmark Report (<code>JSON</code> format) pyventus_v060_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=RANDOM, onetime_subscription_mode=RANDOM)\",\n  \"pyventus_version\": \"0.6.0\",\n  \"benchmark_duration\": 12883.082557200003,\n  \"event_subscription_mode\": \"Random\",\n  \"onetime_subscription_mode\": \"Random\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 3,\n  \"num_executions\": 500,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0020576499997938904\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.007661850000052557\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.026361883333568887\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 1.1266335333342188\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 6.6018846833333855\n    }\n  ]\n}\n</code></pre> pyventus_v070_eeb_report.json<pre><code>{\n  \"title\": \"EventEmitterBenchmark(event_subscription_mode=RANDOM, onetime_subscription_mode=RANDOM)\",\n  \"pyventus_version\": \"0.7.0\",\n  \"benchmark_duration\": 1836.9729208999997,\n  \"event_subscription_mode\": \"Random\",\n  \"onetime_subscription_mode\": \"Random\",\n  \"subscription_sizes\": [\n    100,\n    500,\n    1000,\n    5000,\n    10000\n  ],\n  \"num_repeats\": 3,\n  \"num_executions\": 500,\n  \"measurements\": [\n    {\n      \"num_subscriptions\": 100,\n      \"execution_time\": 0.0020046499994350597\n    },\n    {\n      \"num_subscriptions\": 500,\n      \"execution_time\": 0.004163983332546195\n    },\n    {\n      \"num_subscriptions\": 1000,\n      \"execution_time\": 0.006543066667897317\n    },\n    {\n      \"num_subscriptions\": 5000,\n      \"execution_time\": 0.03050753333324489\n    },\n    {\n      \"num_subscriptions\": 10000,\n      \"execution_time\": 0.07419393333475455\n    }\n  ]\n}\n</code></pre> </p> <p> Subscription Size Metric Pyventus <code>v0.6.0</code> Pyventus <code>v0.7.0</code> Improvement 100 Event Emission Time (s) 0.00205765 0.00200465 2.64% faster 500 Event Emission Time (s) 0.00766185 0.00416398 45.65% faster 1000 Event Emission Time (s) 0.02636188 0.00654307 75.18% faster 5000 Event Emission Time (s) 1.12663353 0.03050753 97.29% faster 10000 Event Emission Time (s) 6.60188468 0.07419393 98.88% faster </p> </li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0As shown in the previous tables, reports, and charts, the improvements made to the event-driven features are significant, especially when one-time subscribers are involved and randomized. It's important to note that these optimizations apply not only to the event emission process but also to other components, such as the <code>EventLinker</code>.</p> </li>"},{"location":"release-notes/#0.6.0","title":"v0.6.0 October 19, 2024","text":""},{"location":"release-notes/#0.6.0-added","title":"Added","text":"<ul> <li>Added support for Python <code>3.13</code>, ensuring compatibility with the latest features and improvements.</li> <li>Added <code>mike</code> package integration to <code>mkdocs-material</code> for documentation versioning. This allows users to access previous documentation alongside new changes, ensuring that legacy content remains intact for reference. Additionally, a new <code>dev</code> documentation has been introduced to showcase the current development of the package, including unreleased features and updates.</li> </ul>"},{"location":"release-notes/#0.6.0-changed","title":"Changed","text":"<ul> <li>Updated documentation links from absolute to relative paths to prevent broken links and avoid redirecting users to incorrect documentation versions, ensuring consistent navigation throughout the docs.</li> <li>Upgraded the <code>download-artifact</code> and <code>cache</code> actions to <code>v4</code> in the <code>publish-to-pypi.yml</code> workflow.</li> <li>Updated the <code>deploy-docs.yml</code> workflow to deploy both <code>dev</code> and versioned documentation using <code>mike</code>'s CLI commands.</li> </ul>"},{"location":"release-notes/#0.6.0-fixed","title":"Fixed","text":"<ul> <li>Fixed broken links to non-versioned documentation by adding a custom <code>404.html</code> page to <code>gh-pages</code>, which redirects users to the first version of the documentation when no version is specified, or to a new custom 404 page with helpful suggestions.</li> </ul>"},{"location":"release-notes/#0.5.0","title":"v0.5.0 April 9, 2024","text":""},{"location":"release-notes/#0.5.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li>Removed the base <code>Event</code> class due to improved event semantics and unnecessary redundancy.</li> <li>Renamed the <code>get_event_registry()</code> method of <code>EventLinker</code> to <code>get_registry()</code>.</li> <li>Renamed the <code>__event_registry</code> inner property of <code>EventLinker</code> to <code>__registry</code>.</li> <li>Renamed the <code>get_events_by_handler()</code> method of <code>EventLinker</code> to <code>get_events_by_event_handler()</code>.</li> <li>Renamed the <code>get_handlers_by_events()</code> method of <code>EventLinker</code> to <code>get_event_handlers_by_events()</code>.</li> <li>Renamed the protected method <code>_executor_callback()</code> of the <code>ExecutorEventEmitter</code> to <code>_callback()</code>.</li> <li>Renamed the task name of <code>CeleryEventEmitter</code> from <code>_executor</code> to <code>pyventus_executor</code> to avoid collisions with other task names.</li> </ul>"},{"location":"release-notes/#0.5.0-added","title":"Added","text":"<ul> <li>Added <code>__slots__</code> to <code>EventLinkageWrapper</code> class for more efficient memory usage.</li> <li>Extended support for subscription and emission of any <code>dataclass</code> object, removing the limitation of only <code>Event</code> subclasses.</li> <li>Added the <code>force_async</code> parameter to the <code>EventHandler</code> class and <code>EventLinker</code> subscription methods to be able to optimize the execution of <code>sync</code> callbacks based on their workload.</li> <li>Introduced a new event semantic where the Python <code>...</code> (Ellipsis) is now used to refer to all events on a subscription, like the <code>onAny()</code> method but with a Pythonic syntax.</li> <li>Added the <code>mkdocs-material social cards</code> plugin, which provides a preview of the documentation content when shared on social media platforms.</li> </ul>"},{"location":"release-notes/#0.5.0-changed","title":"Changed","text":"<ul> <li>Standardized the order of static methods, class methods, and instance methods for improved readability.</li> <li>Applied Python best practices to optimize the methods within the <code>EventLinker</code> and <code>EventEmitter</code> classes.</li> <li>Improved validation of variable instances in the event emitters, <code>EventLinker</code>, and <code>EventHandler</code>.</li> <li>Updated and improved the test suite to ensure accurate validation and consistency.</li> <li>Enabled creation date for the mkdocs <code>git-revision-date-localized</code> plugin.</li> <li>Replaced the mkdocs <code>git-authors</code> plugin with the <code>git-committers</code> plugin.</li> <li>Updated and improved the package description.</li> <li>Updated the tutorial section to incorporate recent changes.</li> <li>Enhanced the documentation index page and README file with new examples and better descriptions to showcase the unique features of Pyventus.</li> </ul>"},{"location":"release-notes/#0.5.0-removed","title":"Removed","text":"<ul> <li>Removed the default value of the <code>once</code> flag in the <code>EventHandler</code> class.</li> </ul>"},{"location":"release-notes/#0.5.0-fixed","title":"Fixed","text":"<ul> <li>Fixed and standardized all package docstrings and code comments for consistency and clarity.</li> <li>Addressed minor errors and details in the documentation.</li> </ul>"},{"location":"release-notes/#0.4.1","title":"v0.4.1 January 30, 2024","text":""},{"location":"release-notes/#0.4.1-changed","title":"Changed","text":"<ul> <li>Optimized the size of the source distribution (sdist) build by including only essential files and directories, such as the <code>/src</code> and <code>/tests</code> directories, as well as the following files: <code>.gitignore</code>, <code>pyproject.toml</code>, <code>CITATION.cff</code>, <code>README</code>, and <code>LICENSE</code>.</li> <li>Refactored documentation dependencies into an optional dependency called <code>docs</code>.</li> <li>Updated the <code>deploy-docs.yml</code> GitHub workflow to leverage the new optional dependency <code>docs</code>.</li> <li>Updated the <code>EventEmission</code> class with the <code>@final</code> decorator from the typing module, indicating that it is meant for internal use only and should not be subclassed.</li> </ul>"},{"location":"release-notes/#0.4.1-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors and details in the documentation.</li> </ul>"},{"location":"release-notes/#0.4.0","title":"v0.4.0 January 6, 2024","text":""},{"location":"release-notes/#0.4.0-added","title":"Added","text":"<ul> <li>Added <code>FastAPIEventEmitter</code> implementation to facilitate seamless integration with the <code>FastAPI</code> framework.</li> <li>Added tests for <code>FastAPIEventEmitter</code> to validate its behavior and ensure proper operation.</li> <li>Added documentation for <code>FastAPIEventEmitter</code>, including tutorials and API references.</li> <li>Integrated the <code>Coveralls.io</code> workflow to generate coverage badge and reports.</li> <li>Included coverage badges on the main documentation page and the readme file.</li> <li>Introduced permalinks within the documentation for easy navigation.</li> </ul>"},{"location":"release-notes/#0.4.0-changed","title":"Changed","text":"<ul> <li>Updated <code>pyproject.toml</code> with the new optional dependency for <code>FastAPI</code> integration.</li> </ul>"},{"location":"release-notes/#0.4.0-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors in the Pyventus documentation to improve accuracy and clarity.</li> </ul>"},{"location":"release-notes/#0.3.0","title":"v0.3.0 December 29, 2023","text":""},{"location":"release-notes/#0.3.0-breaking-changes","title":"Breaking Changes","text":"<ul> <li>Introduced <code>EventEmission</code> object to encapsulate the processing of event emissions. This changes the <code>_execute()</code> method of <code>EventEmitter</code> but provides a cleaner, more scalable, and efficient approach.</li> <li>Renamed all debug flags from <code>debug_mode</code> to <code>debug</code> for enhanced clarity and consistency.</li> <li>Renamed EventEmitter's <code>_execute()</code> method to <code>_process()</code> to better reflect its purpose of processing event emissions.</li> </ul>"},{"location":"release-notes/#0.3.0-added","title":"Added","text":"<ul> <li>Added <code>CeleryEventEmitter</code> implementation to leverage the Celery distributed task queue for event handling.</li> <li>Added tests for <code>CeleryEventEmitter</code> to validate its behavior and ensure proper operation.</li> <li>Added documentation for <code>CeleryEventEmitter</code>, including tutorials and API references.</li> </ul>"},{"location":"release-notes/#0.3.0-changed","title":"Changed","text":"<ul> <li>Restructured the documentation for event emitters tutorials and API references to improve organization and clarity.</li> <li>Updated the <code>contributing.md</code> page to include the Troubleshooting Hatch Environment Errors section.</li> <li>Updated the <code>EventEmitter</code> API documentation to include the <code>EventEmission</code> class reference.</li> <li>Updated <code>pyproject.toml</code> with the new optional dependency for <code>Celery</code> integration.</li> <li>Updated <code>mypy</code> ignore flags to properly silence specific false positive error codes.</li> </ul>"},{"location":"release-notes/#0.3.0-fixed","title":"Fixed","text":"<ul> <li>Addressed minor errors in the Pyventus documentation.</li> </ul>"},{"location":"release-notes/#0.2.1","title":"v0.2.1 December 17, 2023","text":""},{"location":"release-notes/#0.2.1-changed","title":"Changed","text":"<ul> <li>Updated docstring links throughout the package to refer to the official documentation.</li> <li>Updated the <code>RQEventEmitter</code> API Reference and Tutorials docs to reflect the new optional import.</li> </ul>"},{"location":"release-notes/#0.2.1-fixed","title":"Fixed","text":"<ul> <li>Resolved the issue where the <code>RQEventEmitter</code> class was automatically imported in the main package, requiring the installation of its optional dependency to use any of the package's core functionalities. It is now fully optional.</li> <li>Fixed issues with invalid links in the documentation.</li> </ul>"},{"location":"release-notes/#0.2.0","title":"v0.2.0 December 16, 2023","text":""},{"location":"release-notes/#0.2.0-added","title":"Added","text":"<ul> <li>Introduced the <code>publish to PyPI</code> workflow, automating the uploading of package builds when new releases are created.</li> <li>Added the <code>mkdocs-git-authors</code> plugin to display git authors of a markdown page in the documentation.</li> <li>Added badges to the main page of the documentation as well as the readme file.</li> <li>Added a code of conduct for the project, using the Contributor Covenant v2.1.</li> <li>Included a <code>CITATION.cff</code> file to facilitate academic citations.</li> </ul>"},{"location":"release-notes/#0.2.0-changed","title":"Changed","text":"<ul> <li>Renamed the <code>tests.yml</code> workflow to <code>run-tests.yml</code>.</li> <li>Updated the <code>deploy-docs.yml</code> workflow with the <code>mkdocs-git-authors</code> plugin dependency.</li> <li>Modified the <code>mkdocs.yml</code> config file by adding the <code>site_url</code> and <code>site_author</code> properties.</li> <li>Updated the <code>pyproject.toml</code> file with the <code>mkdocs-git-authors</code> plugin dependency and python package keywords.</li> </ul>"},{"location":"release-notes/#0.2.0-fixed","title":"Fixed","text":"<ul> <li>Fixed the python version in the <code>deploy-docs.yml</code> workflow.</li> <li>Resolved issues with relative links in the documentation.</li> </ul>"},{"location":"release-notes/#0.1.0","title":"v0.1.0 December 15, 2023","text":""},{"location":"release-notes/#initial-implementation","title":"Initial Implementation","text":"<p>\u2003\u2003This release introduces Pyventus v0.1.0, a modern and robust Python package for event-driven programming. Pyventus provides developers with a comprehensive suite of tools and utilities to define, emit, and orchestrate events. It empowers developers to build scalable, extensible, and loosely-coupled event-driven applications.</p> <ul> <li>Implementation Details: The first implementation includes all the core functionalities of the package, encompassing events, event linkers, event emitters, event handlers, and more.</li> <li>Testing and Coverage: This release includes a test suite that verifies the correctness of the package implementation. It also integrates code coverage, achieving 100% test coverage. The tests are configured to run automatically via GitHub Actions on both push and pull requests to the master branch.</li> <li>Formatter and Lint Configuration: A formatter and lint configuration have been added to the project. This ensures consistent code style, maintainability, and adherence to the established coding standards defined in the project documentation.</li> <li>Documentation: Additionally, this release includes comprehensive documentation for the package. The documentation covers the main page, a detailed getting started guide, tutorials, API reference, and release notes.</li> </ul> <p></p>"},{"location":"api/","title":"API Reference","text":"<p>\ud83c\udfd7\ufe0f Work in Progress</p> <p>The API section is currently being rebuilt.</p> <p>     \u2003\u2003Welcome to the Pyventus API Reference, a comprehensive guide that provides detailed information about     the classes, functions, parameters, attributes, and other components available in Pyventus. </p> <p>     \u2003\u2003In the API Reference, you will find detailed documentation for each component, including clear explanations,     parameter details, return values, and usage examples. You can navigate through the reference using the search     functionality or by browsing the different sections and categories to find the specific information you need. </p> <p> </p> <p> Let's explore the Pyventus API Reference! </p> <p></p>"},{"location":"tutorials/","title":"Tutorials","text":"<p>\ud83c\udfd7\ufe0f Work in Progress</p> <p>The Tutorials section is currently being rebuilt.</p> <p>     \u2003\u2003Welcome to the Tutorials section, where you can learn the key concepts and features of Pyventus     through step-by-step examples. These tutorials are designed to be user-friendly, covering a range of topics     from the basics to more advanced concepts. </p> <p>     \u2003\u2003By following these tutorials, you'll gain a solid understanding of Pyventus' core abstractions and     how to effectively apply them when building event-driven applications. The tutorials are organized in a      progressive manner, allowing you to gradually enhance your knowledge and skills. </p> <p> </p> <p> Let's kickstart your Pyventus experience! </p>"}]}